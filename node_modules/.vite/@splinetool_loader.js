import {
  AxesHelper,
  BackSide,
  Box3,
  Box3Helper,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  Camera,
  CameraHelper,
  ClampToEdgeWrapping,
  Color,
  ConeGeometry,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeUVReflectionMapping,
  CubicBezierCurve,
  CylinderGeometry,
  DepthTexture,
  DirectionalLight,
  DirectionalLightHelper,
  DodecahedronGeometry,
  DoubleSide,
  EllipseCurve,
  Euler,
  EventDispatcher,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  Fog,
  FrontSide,
  Group,
  HemisphereLight,
  IcosahedronGeometry,
  LatheGeometry,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineSegments,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  Loader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  NearestFilter,
  NormalBlending,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  PointLightHelper,
  QuadraticBezierCurve,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShaderLib,
  ShaderMaterial,
  Shape,
  ShapeGeometry,
  ShapePath,
  Sphere,
  SphereGeometry,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Texture,
  TorusKnotGeometry,
  Triangle,
  Uint32BufferAttribute,
  UniformsLib,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  __spreadProps,
  __spreadValues,
  sRGBEncoding
} from "./chunk-YJK4BVSX.js";

// node_modules/three/examples/jsm/loaders/FontLoader.js
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      let json;
      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
        json = JSON.parse(text.substring(65, text.length - 2));
      }
      const font = scope.parse(json);
      if (onLoad)
        onLoad(font);
    }, onProgress, onError);
  }
  parse(json) {
    return new Font(json);
  }
};
var Font = class {
  constructor(data) {
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl2 = paths.length; p < pl2; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}
Font.prototype.isFont = true;

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      const taskConfig = {
        attributeIDs: this.defaultAttributeIDs,
        attributeTypes: this.defaultAttributeTypes,
        useUniqueIDs: false
      };
      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);
    }, onProgress, onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs
    };
    this.decodeGeometry(buffer, taskConfig).then(callback);
  }
  decodeGeometry(buffer, taskConfig) {
    for (const attribute in taskConfig.attributeTypes) {
      const type = taskConfig.attributeTypes[attribute];
      if (type.BYTES_PER_ELEMENT !== void 0) {
        taskConfig.attributeTypes[attribute] = type.name;
      }
    }
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const attribute = geometryData.attributes[i];
      const name = attribute.name;
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      geometry.setAttribute(name, new BufferAttribute(array, itemSize));
    }
    return geometry;
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn2 = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn2.substring(fn2.indexOf("{") + 1, fn2.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module2) => {
          const draco = module2.draco;
          const decoder = new draco.Decoder();
          const decoderBuffer = new draco.DecoderBuffer();
          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
          try {
            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index)
              buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoderBuffer);
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function mergeBufferGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0)
        attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
    mergedGeometry.userData.mergedUserData.push(geometry.userData);
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeBufferAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeBufferAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.");
      return null;
    }
    if (TypedArray === void 0)
      TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.array.length;
  }
  const array = new TypedArray(arrayLength);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    array.set(attributes[i].array, offset);
    offset += attributes[i].array.length;
  }
  return new BufferAttribute(array, itemSize, normalized);
}

// node_modules/@splinetool/loader/build/SplineLoader.js
var zf = Object.create;
var fa = Object.defineProperty;
var Vf = Object.getOwnPropertyDescriptor;
var Ff = Object.getOwnPropertyNames;
var Uf = Object.getPrototypeOf;
var jf = Object.prototype.hasOwnProperty;
var kf = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports);
var Hf = (i, r) => {
  for (var e in r)
    fa(i, e, { get: r[e], enumerable: true });
};
var Wf = (i, r, e, t) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let o of Ff(r))
      !jf.call(i, o) && o !== e && fa(i, o, { get: () => r[o], enumerable: !(t = Vf(r, o)) || t.enumerable });
  return i;
};
var qf = (i, r, e) => (e = i != null ? zf(Uf(i)) : {}, Wf(r || !i || !i.__esModule ? fa(e, "default", { value: i, enumerable: true }) : e, i));
var mf = kf((ma, pf) => {
  (function(i, r) {
    typeof ma == "object" && typeof pf < "u" ? r(ma) : typeof define == "function" && define.amd ? define(["exports"], r) : r((i = typeof globalThis < "u" ? globalThis : i || self).SVDJS = {});
  })(ma, function(i) {
    "use strict";
    i.SVD = function(r, e, t, o, n) {
      if (e = e === void 0 || e, t = t === void 0 || t, n = 1e-64 / (o = o || Math.pow(2, -52)), !r)
        throw new TypeError("Matrix a is not defined");
      var s, a, l, c, u, m, p, d, f, g, x, y, v = r[0].length, P = r.length;
      if (P < v)
        throw new TypeError("Invalid matrix: m < n");
      for (var S = [], b = [], E = [], w = e === "f" ? P : v, h = g = p = 0; h < P; h++)
        b[h] = new Array(w).fill(0);
      for (h = 0; h < v; h++)
        E[h] = new Array(v).fill(0);
      var _, N = new Array(v).fill(0);
      for (h = 0; h < P; h++)
        for (s = 0; s < v; s++)
          b[h][s] = r[h][s];
      for (h = 0; h < v; h++) {
        for (S[h] = p, f = 0, l = h + 1, s = h; s < P; s++)
          f += Math.pow(b[s][h], 2);
        if (f < n)
          p = 0;
        else
          for (d = (m = b[h][h]) * (p = m < 0 ? Math.sqrt(f) : -Math.sqrt(f)) - f, b[h][h] = m - p, s = l; s < v; s++) {
            for (f = 0, a = h; a < P; a++)
              f += b[a][h] * b[a][s];
            for (m = f / d, a = h; a < P; a++)
              b[a][s] = b[a][s] + m * b[a][h];
          }
        for (N[h] = p, f = 0, s = l; s < v; s++)
          f += Math.pow(b[h][s], 2);
        if (f < n)
          p = 0;
        else {
          for (d = (m = b[h][h + 1]) * (p = m < 0 ? Math.sqrt(f) : -Math.sqrt(f)) - f, b[h][h + 1] = m - p, s = l; s < v; s++)
            S[s] = b[h][s] / d;
          for (s = l; s < P; s++) {
            for (f = 0, a = l; a < v; a++)
              f += b[s][a] * b[h][a];
            for (a = l; a < v; a++)
              b[s][a] = b[s][a] + f * S[a];
          }
        }
        g < (x = Math.abs(N[h]) + Math.abs(S[h])) && (g = x);
      }
      if (t)
        for (h = v - 1; 0 <= h; h--) {
          if (p !== 0) {
            for (d = b[h][h + 1] * p, s = l; s < v; s++)
              E[s][h] = b[h][s] / d;
            for (s = l; s < v; s++) {
              for (f = 0, a = l; a < v; a++)
                f += b[h][a] * E[a][s];
              for (a = l; a < v; a++)
                E[a][s] = E[a][s] + f * E[a][h];
            }
          }
          for (s = l; s < v; s++)
            E[h][s] = 0, E[s][h] = 0;
          E[h][h] = 1, p = S[h], l = h;
        }
      if (e) {
        if (e === "f")
          for (h = v; h < P; h++) {
            for (s = v; s < P; s++)
              b[h][s] = 0;
            b[h][h] = 1;
          }
        for (h = v - 1; 0 <= h; h--) {
          for (l = h + 1, p = N[h], s = l; s < w; s++)
            b[h][s] = 0;
          if (p !== 0) {
            for (d = b[h][h] * p, s = l; s < w; s++) {
              for (f = 0, a = l; a < P; a++)
                f += b[a][h] * b[a][s];
              for (m = f / d, a = h; a < P; a++)
                b[a][s] = b[a][s] + m * b[a][h];
            }
            for (s = h; s < P; s++)
              b[s][h] = b[s][h] / p;
          } else
            for (s = h; s < P; s++)
              b[s][h] = 0;
          b[h][h] = b[h][h] + 1;
        }
      }
      for (o *= g, a = v - 1; 0 <= a; a--)
        for (var I = 0; I < 50; I++) {
          for (_ = false, l = a; 0 <= l; l--) {
            if (Math.abs(S[l]) <= o) {
              _ = true;
              break;
            }
            if (Math.abs(N[l - 1]) <= o)
              break;
          }
          if (!_) {
            for (u = 0, c = l - (f = 1), h = l; h < a + 1 && (m = f * S[h], S[h] = u * S[h], !(Math.abs(m) <= o)); h++)
              if (p = N[h], N[h] = Math.sqrt(m * m + p * p), u = p / (d = N[h]), f = -m / d, e)
                for (s = 0; s < P; s++)
                  x = b[s][c], y = b[s][h], b[s][c] = x * u + y * f, b[s][h] = -x * f + y * u;
          }
          if (y = N[a], l === a) {
            if (y < 0 && (N[a] = -y, t))
              for (s = 0; s < v; s++)
                E[s][a] = -E[s][a];
            break;
          }
          for (g = N[l], m = (((x = N[a - 1]) - y) * (x + y) + ((p = S[a - 1]) - (d = S[a])) * (p + d)) / (2 * d * x), p = Math.sqrt(m * m + 1), m = ((g - y) * (g + y) + d * (x / (m < 0 ? m - p : m + p) - d)) / g, h = l + (f = u = 1); h < a + 1; h++) {
            if (p = S[h], x = N[h], d = f * p, p *= u, y = Math.sqrt(m * m + d * d), m = g * (u = m / (S[h - 1] = y)) + p * (f = d / y), p = -g * f + p * u, d = x * f, x *= u, t)
              for (s = 0; s < v; s++)
                g = E[s][h - 1], y = E[s][h], E[s][h - 1] = g * u + y * f, E[s][h] = -g * f + y * u;
            if (y = Math.sqrt(m * m + d * d), m = (u = m / (N[h - 1] = y)) * p + (f = d / y) * x, g = -f * p + u * x, e)
              for (s = 0; s < P; s++)
                x = b[s][h - 1], y = b[s][h], b[s][h - 1] = x * u + y * f, b[s][h] = -x * f + y * u;
          }
          S[l] = 0, S[a] = m, N[a] = g;
        }
      for (h = 0; h < v; h++)
        N[h] < o && (N[h] = 0);
      return { u: b, q: N, v: E };
    }, i.VERSION = "1.1.1", Object.defineProperty(i, "__esModule", { value: true });
  });
});
function ha(i, r) {
  return Object.setPrototypeOf(i, r), i;
}
function lc(i) {
  return Array.isArray(i) ? i : [i];
}
var $f = typeof global == "object" && global && global.Object === Object && global;
var Ni = $f;
var Xf = typeof self == "object" && self && self.Object === Object && self;
var Yf = Ni || Xf || Function("return this")();
var Ge = Yf;
var Kf = Ge.Symbol;
var nt = Kf;
var cc = Object.prototype;
var Qf = cc.hasOwnProperty;
var Jf = cc.toString;
var wn = nt ? nt.toStringTag : void 0;
function Zf(i) {
  var r = Qf.call(i, wn), e = i[wn];
  try {
    i[wn] = void 0;
    var t = true;
  } catch {
  }
  var o = Jf.call(i);
  return t && (r ? i[wn] = e : delete i[wn]), o;
}
var uc = Zf;
var eh = Object.prototype;
var th = eh.toString;
function rh(i) {
  return th.call(i);
}
var pc = rh;
var oh = "[object Null]";
var nh = "[object Undefined]";
var mc = nt ? nt.toStringTag : void 0;
function ih(i) {
  return i == null ? i === void 0 ? nh : oh : mc && mc in Object(i) ? uc(i) : pc(i);
}
var yt = ih;
function sh(i) {
  return i != null && typeof i == "object";
}
var Ze = sh;
var ah = "[object Symbol]";
function lh(i) {
  return typeof i == "symbol" || Ze(i) && yt(i) == ah;
}
var fo = lh;
function ch(i, r) {
  for (var e = -1, t = i == null ? 0 : i.length, o = Array(t); ++e < t; )
    o[e] = r(i[e], e, i);
  return o;
}
var Ci = ch;
var uh = Array.isArray;
var Re = uh;
var ph = 1 / 0;
var dc = nt ? nt.prototype : void 0;
var fc = dc ? dc.toString : void 0;
function hc(i) {
  if (typeof i == "string")
    return i;
  if (Re(i))
    return Ci(i, hc) + "";
  if (fo(i))
    return fc ? fc.call(i) : "";
  var r = i + "";
  return r == "0" && 1 / i == -ph ? "-0" : r;
}
var gc = hc;
function mh(i) {
  var r = typeof i;
  return i != null && (r == "object" || r == "function");
}
var et = mh;
function dh(i) {
  return i;
}
var Li = dh;
var fh = "[object AsyncFunction]";
var hh = "[object Function]";
var gh = "[object GeneratorFunction]";
var yh = "[object Proxy]";
function xh(i) {
  if (!et(i))
    return false;
  var r = yt(i);
  return r == hh || r == gh || r == fh || r == yh;
}
var ho = xh;
var vh = Ge["__core-js_shared__"];
var Ii = vh;
var yc = function() {
  var i = /[^.]+$/.exec(Ii && Ii.keys && Ii.keys.IE_PROTO || "");
  return i ? "Symbol(src)_1." + i : "";
}();
function bh(i) {
  return !!yc && yc in i;
}
var xc = bh;
var Sh = Function.prototype;
var wh = Sh.toString;
function Th(i) {
  if (i != null) {
    try {
      return wh.call(i);
    } catch {
    }
    try {
      return i + "";
    } catch {
    }
  }
  return "";
}
var dr = Th;
var Nh = /[\\^$.*+?()[\]{}|]/g;
var Ch = /^\[object .+?Constructor\]$/;
var Lh = Function.prototype;
var Ih = Object.prototype;
var Ph = Lh.toString;
var Ah = Ih.hasOwnProperty;
var Mh = RegExp("^" + Ph.call(Ah).replace(Nh, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Oh(i) {
  if (!et(i) || xc(i))
    return false;
  var r = ho(i) ? Mh : Ch;
  return r.test(dr(i));
}
var vc = Oh;
function _h(i, r) {
  return i == null ? void 0 : i[r];
}
var bc = _h;
function Dh(i, r) {
  var e = bc(i, r);
  return vc(e) ? e : void 0;
}
var pt = Dh;
var Eh = pt(Ge, "WeakMap");
var Pi = Eh;
var Sc = Object.create;
var Bh = function() {
  function i() {
  }
  return function(r) {
    if (!et(r))
      return {};
    if (Sc)
      return Sc(r);
    i.prototype = r;
    var e = new i();
    return i.prototype = void 0, e;
  };
}();
var wc = Bh;
function Gh(i, r, e) {
  switch (e.length) {
    case 0:
      return i.call(r);
    case 1:
      return i.call(r, e[0]);
    case 2:
      return i.call(r, e[0], e[1]);
    case 3:
      return i.call(r, e[0], e[1], e[2]);
  }
  return i.apply(r, e);
}
var Tc = Gh;
function Rh(i, r) {
  var e = -1, t = i.length;
  for (r || (r = Array(t)); ++e < t; )
    r[e] = i[e];
  return r;
}
var Ai = Rh;
var zh = 800;
var Vh = 16;
var Fh = Date.now;
function Uh(i) {
  var r = 0, e = 0;
  return function() {
    var t = Fh(), o = Vh - (t - e);
    if (e = t, o > 0) {
      if (++r >= zh)
        return arguments[0];
    } else
      r = 0;
    return i.apply(void 0, arguments);
  };
}
var Nc = Uh;
function jh(i) {
  return function() {
    return i;
  };
}
var Cc = jh;
var kh = function() {
  try {
    var i = pt(Object, "defineProperty");
    return i({}, "", {}), i;
  } catch {
  }
}();
var go = kh;
var Hh = go ? function(i, r) {
  return go(i, "toString", { configurable: true, enumerable: false, value: Cc(r), writable: true });
} : Li;
var Lc = Hh;
var Wh = Nc(Lc);
var Mi = Wh;
function qh(i, r) {
  for (var e = -1, t = i == null ? 0 : i.length; ++e < t && r(i[e], e, i) !== false; )
    ;
  return i;
}
var Ic = qh;
var $h = 9007199254740991;
var Xh = /^(?:0|[1-9]\d*)$/;
function Yh(i, r) {
  var e = typeof i;
  return r = r != null ? r : $h, !!r && (e == "number" || e != "symbol" && Xh.test(i)) && i > -1 && i % 1 == 0 && i < r;
}
var Oi = Yh;
function Kh(i, r, e) {
  r == "__proto__" && go ? go(i, r, { configurable: true, enumerable: true, value: e, writable: true }) : i[r] = e;
}
var yo = Kh;
function Qh(i, r) {
  return i === r || i !== i && r !== r;
}
var Lr = Qh;
var Jh = Object.prototype;
var Zh = Jh.hasOwnProperty;
function eg(i, r, e) {
  var t = i[r];
  (!(Zh.call(i, r) && Lr(t, e)) || e === void 0 && !(r in i)) && yo(i, r, e);
}
var _i = eg;
function tg(i, r, e, t) {
  var o = !e;
  e || (e = {});
  for (var n = -1, s = r.length; ++n < s; ) {
    var a = r[n], l = t ? t(e[a], i[a], a, e, i) : void 0;
    l === void 0 && (l = i[a]), o ? yo(e, a, l) : _i(e, a, l);
  }
  return e;
}
var wt = tg;
var Pc = Math.max;
function rg(i, r, e) {
  return r = Pc(r === void 0 ? i.length - 1 : r, 0), function() {
    for (var t = arguments, o = -1, n = Pc(t.length - r, 0), s = Array(n); ++o < n; )
      s[o] = t[r + o];
    o = -1;
    for (var a = Array(r + 1); ++o < r; )
      a[o] = t[o];
    return a[r] = e(s), Tc(i, this, a);
  };
}
var Di = rg;
function og(i, r) {
  return Mi(Di(i, r, Li), i + "");
}
var Ac = og;
var ng = 9007199254740991;
function ig(i) {
  return typeof i == "number" && i > -1 && i % 1 == 0 && i <= ng;
}
var Ei = ig;
function sg(i) {
  return i != null && Ei(i.length) && !ho(i);
}
var Ir = sg;
function ag(i, r, e) {
  if (!et(e))
    return false;
  var t = typeof r;
  return (t == "number" ? Ir(e) && Oi(r, e.length) : t == "string" && r in e) ? Lr(e[r], i) : false;
}
var Mc = ag;
function lg(i) {
  return Ac(function(r, e) {
    var t = -1, o = e.length, n = o > 1 ? e[o - 1] : void 0, s = o > 2 ? e[2] : void 0;
    for (n = i.length > 3 && typeof n == "function" ? (o--, n) : void 0, s && Mc(e[0], e[1], s) && (n = o < 3 ? void 0 : n, o = 1), r = Object(r); ++t < o; ) {
      var a = e[t];
      a && i(r, a, t, n);
    }
    return r;
  });
}
var Oc = lg;
var cg = Object.prototype;
function ug(i) {
  var r = i && i.constructor, e = typeof r == "function" && r.prototype || cg;
  return i === e;
}
var xo = ug;
function pg(i, r) {
  for (var e = -1, t = Array(i); ++e < i; )
    t[e] = r(e);
  return t;
}
var _c = pg;
var mg = "[object Arguments]";
function dg(i) {
  return Ze(i) && yt(i) == mg;
}
var ga = dg;
var Dc = Object.prototype;
var fg = Dc.hasOwnProperty;
var hg = Dc.propertyIsEnumerable;
var gg = ga(function() {
  return arguments;
}()) ? ga : function(i) {
  return Ze(i) && fg.call(i, "callee") && !hg.call(i, "callee");
};
var qr = gg;
function yg() {
  return false;
}
var Ec = yg;
var Rc = typeof exports == "object" && exports && !exports.nodeType && exports;
var Bc = Rc && typeof module == "object" && module && !module.nodeType && module;
var xg = Bc && Bc.exports === Rc;
var Gc = xg ? Ge.Buffer : void 0;
var vg = Gc ? Gc.isBuffer : void 0;
var bg = vg || Ec;
var vo = bg;
var Sg = "[object Arguments]";
var wg = "[object Array]";
var Tg = "[object Boolean]";
var Ng = "[object Date]";
var Cg = "[object Error]";
var Lg = "[object Function]";
var Ig = "[object Map]";
var Pg = "[object Number]";
var Ag = "[object Object]";
var Mg = "[object RegExp]";
var Og = "[object Set]";
var _g = "[object String]";
var Dg = "[object WeakMap]";
var Eg = "[object ArrayBuffer]";
var Bg = "[object DataView]";
var Gg = "[object Float32Array]";
var Rg = "[object Float64Array]";
var zg = "[object Int8Array]";
var Vg = "[object Int16Array]";
var Fg = "[object Int32Array]";
var Ug = "[object Uint8Array]";
var jg = "[object Uint8ClampedArray]";
var kg = "[object Uint16Array]";
var Hg = "[object Uint32Array]";
var Ie = {};
Ie[Gg] = Ie[Rg] = Ie[zg] = Ie[Vg] = Ie[Fg] = Ie[Ug] = Ie[jg] = Ie[kg] = Ie[Hg] = true;
Ie[Sg] = Ie[wg] = Ie[Eg] = Ie[Tg] = Ie[Bg] = Ie[Ng] = Ie[Cg] = Ie[Lg] = Ie[Ig] = Ie[Pg] = Ie[Ag] = Ie[Mg] = Ie[Og] = Ie[_g] = Ie[Dg] = false;
function Wg(i) {
  return Ze(i) && Ei(i.length) && !!Ie[yt(i)];
}
var zc = Wg;
function qg(i) {
  return function(r) {
    return i(r);
  };
}
var bo = qg;
var Vc = typeof exports == "object" && exports && !exports.nodeType && exports;
var Tn = Vc && typeof module == "object" && module && !module.nodeType && module;
var $g = Tn && Tn.exports === Vc;
var ya = $g && Ni.process;
var Xg = function() {
  try {
    var i = Tn && Tn.require && Tn.require("util").types;
    return i || ya && ya.binding && ya.binding("util");
  } catch {
  }
}();
var fr = Xg;
var Fc = fr && fr.isTypedArray;
var Yg = Fc ? bo(Fc) : zc;
var Bi = Yg;
var Kg = Object.prototype;
var Qg = Kg.hasOwnProperty;
function Jg(i, r) {
  var e = Re(i), t = !e && qr(i), o = !e && !t && vo(i), n = !e && !t && !o && Bi(i), s = e || t || o || n, a = s ? _c(i.length, String) : [], l = a.length;
  for (var c in i)
    (r || Qg.call(i, c)) && !(s && (c == "length" || o && (c == "offset" || c == "parent") || n && (c == "buffer" || c == "byteLength" || c == "byteOffset") || Oi(c, l))) && a.push(c);
  return a;
}
var Gi = Jg;
function Zg(i, r) {
  return function(e) {
    return i(r(e));
  };
}
var Ri = Zg;
var ey = Ri(Object.keys, Object);
var Uc = ey;
var ty = Object.prototype;
var ry = ty.hasOwnProperty;
function oy(i) {
  if (!xo(i))
    return Uc(i);
  var r = [];
  for (var e in Object(i))
    ry.call(i, e) && e != "constructor" && r.push(e);
  return r;
}
var jc = oy;
function ny(i) {
  return Ir(i) ? Gi(i) : jc(i);
}
var So = ny;
function iy(i) {
  var r = [];
  if (i != null)
    for (var e in Object(i))
      r.push(e);
  return r;
}
var kc = iy;
var sy = Object.prototype;
var ay = sy.hasOwnProperty;
function ly(i) {
  if (!et(i))
    return kc(i);
  var r = xo(i), e = [];
  for (var t in i)
    t == "constructor" && (r || !ay.call(i, t)) || e.push(t);
  return e;
}
var Hc = ly;
function cy(i) {
  return Ir(i) ? Gi(i, true) : Hc(i);
}
var kt = cy;
var uy = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var py = /^\w*$/;
function my(i, r) {
  if (Re(i))
    return false;
  var e = typeof i;
  return e == "number" || e == "symbol" || e == "boolean" || i == null || fo(i) ? true : py.test(i) || !uy.test(i) || r != null && i in Object(r);
}
var Wc = my;
var dy = pt(Object, "create");
var hr = dy;
function fy() {
  this.__data__ = hr ? hr(null) : {}, this.size = 0;
}
var qc = fy;
function hy(i) {
  var r = this.has(i) && delete this.__data__[i];
  return this.size -= r ? 1 : 0, r;
}
var $c = hy;
var gy = "__lodash_hash_undefined__";
var yy = Object.prototype;
var xy = yy.hasOwnProperty;
function vy(i) {
  var r = this.__data__;
  if (hr) {
    var e = r[i];
    return e === gy ? void 0 : e;
  }
  return xy.call(r, i) ? r[i] : void 0;
}
var Xc = vy;
var by = Object.prototype;
var Sy = by.hasOwnProperty;
function wy(i) {
  var r = this.__data__;
  return hr ? r[i] !== void 0 : Sy.call(r, i);
}
var Yc = wy;
var Ty = "__lodash_hash_undefined__";
function Ny(i, r) {
  var e = this.__data__;
  return this.size += this.has(i) ? 0 : 1, e[i] = hr && r === void 0 ? Ty : r, this;
}
var Kc = Ny;
function wo(i) {
  var r = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++r < e; ) {
    var t = i[r];
    this.set(t[0], t[1]);
  }
}
wo.prototype.clear = qc;
wo.prototype.delete = $c;
wo.prototype.get = Xc;
wo.prototype.has = Yc;
wo.prototype.set = Kc;
var xa = wo;
function Cy() {
  this.__data__ = [], this.size = 0;
}
var Qc = Cy;
function Ly(i, r) {
  for (var e = i.length; e--; )
    if (Lr(i[e][0], r))
      return e;
  return -1;
}
var Pr = Ly;
var Iy = Array.prototype;
var Py = Iy.splice;
function Ay(i) {
  var r = this.__data__, e = Pr(r, i);
  if (e < 0)
    return false;
  var t = r.length - 1;
  return e == t ? r.pop() : Py.call(r, e, 1), --this.size, true;
}
var Jc = Ay;
function My(i) {
  var r = this.__data__, e = Pr(r, i);
  return e < 0 ? void 0 : r[e][1];
}
var Zc = My;
function Oy(i) {
  return Pr(this.__data__, i) > -1;
}
var eu = Oy;
function _y(i, r) {
  var e = this.__data__, t = Pr(e, i);
  return t < 0 ? (++this.size, e.push([i, r])) : e[t][1] = r, this;
}
var tu = _y;
function To(i) {
  var r = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++r < e; ) {
    var t = i[r];
    this.set(t[0], t[1]);
  }
}
To.prototype.clear = Qc;
To.prototype.delete = Jc;
To.prototype.get = Zc;
To.prototype.has = eu;
To.prototype.set = tu;
var Ar = To;
var Dy = pt(Ge, "Map");
var Mr = Dy;
function Ey() {
  this.size = 0, this.__data__ = { hash: new xa(), map: new (Mr || Ar)(), string: new xa() };
}
var ru = Ey;
function By(i) {
  var r = typeof i;
  return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? i !== "__proto__" : i === null;
}
var ou = By;
function Gy(i, r) {
  var e = i.__data__;
  return ou(r) ? e[typeof r == "string" ? "string" : "hash"] : e.map;
}
var Or = Gy;
function Ry(i) {
  var r = Or(this, i).delete(i);
  return this.size -= r ? 1 : 0, r;
}
var nu = Ry;
function zy(i) {
  return Or(this, i).get(i);
}
var iu = zy;
function Vy(i) {
  return Or(this, i).has(i);
}
var su = Vy;
function Fy(i, r) {
  var e = Or(this, i), t = e.size;
  return e.set(i, r), this.size += e.size == t ? 0 : 1, this;
}
var au = Fy;
function No(i) {
  var r = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++r < e; ) {
    var t = i[r];
    this.set(t[0], t[1]);
  }
}
No.prototype.clear = ru;
No.prototype.delete = nu;
No.prototype.get = iu;
No.prototype.has = su;
No.prototype.set = au;
var Nn = No;
var Uy = "Expected a function";
function va(i, r) {
  if (typeof i != "function" || r != null && typeof r != "function")
    throw new TypeError(Uy);
  var e = function() {
    var t = arguments, o = r ? r.apply(this, t) : t[0], n = e.cache;
    if (n.has(o))
      return n.get(o);
    var s = i.apply(this, t);
    return e.cache = n.set(o, s) || n, s;
  };
  return e.cache = new (va.Cache || Nn)(), e;
}
va.Cache = Nn;
var lu = va;
var jy = 500;
function ky(i) {
  var r = lu(i, function(t) {
    return e.size === jy && e.clear(), t;
  }), e = r.cache;
  return r;
}
var cu = ky;
var Hy = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var Wy = /\\(\\)?/g;
var qy = cu(function(i) {
  var r = [];
  return i.charCodeAt(0) === 46 && r.push(""), i.replace(Hy, function(e, t, o, n) {
    r.push(o ? n.replace(Wy, "$1") : t || e);
  }), r;
});
var uu = qy;
function $y(i) {
  return i == null ? "" : gc(i);
}
var pu = $y;
function Xy(i, r) {
  return Re(i) ? i : Wc(i, r) ? [i] : uu(pu(i));
}
var Co = Xy;
var Yy = 1 / 0;
function Ky(i) {
  if (typeof i == "string" || fo(i))
    return i;
  var r = i + "";
  return r == "0" && 1 / i == -Yy ? "-0" : r;
}
var zi = Ky;
function Qy(i, r) {
  r = Co(r, i);
  for (var e = 0, t = r.length; i != null && e < t; )
    i = i[zi(r[e++])];
  return e && e == t ? i : void 0;
}
var mu = Qy;
function Jy(i, r) {
  for (var e = -1, t = r.length, o = i.length; ++e < t; )
    i[o + e] = r[e];
  return i;
}
var Lo = Jy;
var du = nt ? nt.isConcatSpreadable : void 0;
function Zy(i) {
  return Re(i) || qr(i) || !!(du && i && i[du]);
}
var fu = Zy;
function hu(i, r, e, t, o) {
  var n = -1, s = i.length;
  for (e || (e = fu), o || (o = []); ++n < s; ) {
    var a = i[n];
    r > 0 && e(a) ? r > 1 ? hu(a, r - 1, e, t, o) : Lo(o, a) : t || (o[o.length] = a);
  }
  return o;
}
var gu = hu;
function ex(i) {
  var r = i == null ? 0 : i.length;
  return r ? gu(i, 1) : [];
}
var yu = ex;
function tx(i) {
  return Mi(Di(i, void 0, yu), i + "");
}
var xu = tx;
var rx = Ri(Object.getPrototypeOf, Object);
var Io = rx;
var ox = "[object Object]";
var nx = Function.prototype;
var ix = Object.prototype;
var vu = nx.toString;
var sx = ix.hasOwnProperty;
var ax = vu.call(Object);
function lx(i) {
  if (!Ze(i) || yt(i) != ox)
    return false;
  var r = Io(i);
  if (r === null)
    return true;
  var e = sx.call(r, "constructor") && r.constructor;
  return typeof e == "function" && e instanceof e && vu.call(e) == ax;
}
var Vi = lx;
function cx(i, r, e) {
  var t = -1, o = i.length;
  r < 0 && (r = -r > o ? 0 : o + r), e = e > o ? o : e, e < 0 && (e += o), o = r > e ? 0 : e - r >>> 0, r >>>= 0;
  for (var n = Array(o); ++t < o; )
    n[t] = i[t + r];
  return n;
}
var bu = cx;
function ux() {
  this.__data__ = new Ar(), this.size = 0;
}
var Su = ux;
function px(i) {
  var r = this.__data__, e = r.delete(i);
  return this.size = r.size, e;
}
var wu = px;
function mx(i) {
  return this.__data__.get(i);
}
var Tu = mx;
function dx(i) {
  return this.__data__.has(i);
}
var Nu = dx;
var fx = 200;
function hx(i, r) {
  var e = this.__data__;
  if (e instanceof Ar) {
    var t = e.__data__;
    if (!Mr || t.length < fx - 1)
      return t.push([i, r]), this.size = ++e.size, this;
    e = this.__data__ = new Nn(t);
  }
  return e.set(i, r), this.size = e.size, this;
}
var Cu = hx;
function Po(i) {
  var r = this.__data__ = new Ar(i);
  this.size = r.size;
}
Po.prototype.clear = Su;
Po.prototype.delete = wu;
Po.prototype.get = Tu;
Po.prototype.has = Nu;
Po.prototype.set = Cu;
var Fi = Po;
function gx(i, r) {
  return i && wt(r, So(r), i);
}
var Lu = gx;
function yx(i, r) {
  return i && wt(r, kt(r), i);
}
var Iu = yx;
var Ou = typeof exports == "object" && exports && !exports.nodeType && exports;
var Pu = Ou && typeof module == "object" && module && !module.nodeType && module;
var xx = Pu && Pu.exports === Ou;
var Au = xx ? Ge.Buffer : void 0;
var Mu = Au ? Au.allocUnsafe : void 0;
function vx(i, r) {
  if (r)
    return i.slice();
  var e = i.length, t = Mu ? Mu(e) : new i.constructor(e);
  return i.copy(t), t;
}
var Ui = vx;
function bx(i, r) {
  for (var e = -1, t = i == null ? 0 : i.length, o = 0, n = []; ++e < t; ) {
    var s = i[e];
    r(s, e, i) && (n[o++] = s);
  }
  return n;
}
var _u = bx;
function Sx() {
  return [];
}
var ji = Sx;
var wx = Object.prototype;
var Tx = wx.propertyIsEnumerable;
var Du = Object.getOwnPropertySymbols;
var Nx = Du ? function(i) {
  return i == null ? [] : (i = Object(i), _u(Du(i), function(r) {
    return Tx.call(i, r);
  }));
} : ji;
var Ao = Nx;
function Cx(i, r) {
  return wt(i, Ao(i), r);
}
var Eu = Cx;
var Lx = Object.getOwnPropertySymbols;
var Ix = Lx ? function(i) {
  for (var r = []; i; )
    Lo(r, Ao(i)), i = Io(i);
  return r;
} : ji;
var ki = Ix;
function Px(i, r) {
  return wt(i, ki(i), r);
}
var Bu = Px;
function Ax(i, r, e) {
  var t = r(i);
  return Re(i) ? t : Lo(t, e(i));
}
var Hi = Ax;
function Mx(i) {
  return Hi(i, So, Ao);
}
var Gu = Mx;
function Ox(i) {
  return Hi(i, kt, ki);
}
var Wi = Ox;
var _x = pt(Ge, "DataView");
var qi = _x;
var Dx = pt(Ge, "Promise");
var $i = Dx;
var Ex = pt(Ge, "Set");
var Xi = Ex;
var Ru = "[object Map]";
var Bx = "[object Object]";
var zu = "[object Promise]";
var Vu = "[object Set]";
var Fu = "[object WeakMap]";
var Uu = "[object DataView]";
var Gx = dr(qi);
var Rx = dr(Mr);
var zx = dr($i);
var Vx = dr(Xi);
var Fx = dr(Pi);
var $r = yt;
(qi && $r(new qi(new ArrayBuffer(1))) != Uu || Mr && $r(new Mr()) != Ru || $i && $r($i.resolve()) != zu || Xi && $r(new Xi()) != Vu || Pi && $r(new Pi()) != Fu) && ($r = function(i) {
  var r = yt(i), e = r == Bx ? i.constructor : void 0, t = e ? dr(e) : "";
  if (t)
    switch (t) {
      case Gx:
        return Uu;
      case Rx:
        return Ru;
      case zx:
        return zu;
      case Vx:
        return Vu;
      case Fx:
        return Fu;
    }
  return r;
});
var Mo = $r;
var Ux = Object.prototype;
var jx = Ux.hasOwnProperty;
function kx(i) {
  var r = i.length, e = new i.constructor(r);
  return r && typeof i[0] == "string" && jx.call(i, "index") && (e.index = i.index, e.input = i.input), e;
}
var ju = kx;
var Hx = Ge.Uint8Array;
var ba = Hx;
function Wx(i) {
  var r = new i.constructor(i.byteLength);
  return new ba(r).set(new ba(i)), r;
}
var Oo = Wx;
function qx(i, r) {
  var e = r ? Oo(i.buffer) : i.buffer;
  return new i.constructor(e, i.byteOffset, i.byteLength);
}
var ku = qx;
var $x = /\w*$/;
function Xx(i) {
  var r = new i.constructor(i.source, $x.exec(i));
  return r.lastIndex = i.lastIndex, r;
}
var Hu = Xx;
var Wu = nt ? nt.prototype : void 0;
var qu = Wu ? Wu.valueOf : void 0;
function Yx(i) {
  return qu ? Object(qu.call(i)) : {};
}
var $u = Yx;
function Kx(i, r) {
  var e = r ? Oo(i.buffer) : i.buffer;
  return new i.constructor(e, i.byteOffset, i.length);
}
var Yi = Kx;
var Qx = "[object Boolean]";
var Jx = "[object Date]";
var Zx = "[object Map]";
var e0 = "[object Number]";
var t0 = "[object RegExp]";
var r0 = "[object Set]";
var o0 = "[object String]";
var n0 = "[object Symbol]";
var i0 = "[object ArrayBuffer]";
var s0 = "[object DataView]";
var a0 = "[object Float32Array]";
var l0 = "[object Float64Array]";
var c0 = "[object Int8Array]";
var u0 = "[object Int16Array]";
var p0 = "[object Int32Array]";
var m0 = "[object Uint8Array]";
var d0 = "[object Uint8ClampedArray]";
var f0 = "[object Uint16Array]";
var h0 = "[object Uint32Array]";
function g0(i, r, e) {
  var t = i.constructor;
  switch (r) {
    case i0:
      return Oo(i);
    case Qx:
    case Jx:
      return new t(+i);
    case s0:
      return ku(i, e);
    case a0:
    case l0:
    case c0:
    case u0:
    case p0:
    case m0:
    case d0:
    case f0:
    case h0:
      return Yi(i, e);
    case Zx:
      return new t();
    case e0:
    case o0:
      return new t(i);
    case t0:
      return Hu(i);
    case r0:
      return new t();
    case n0:
      return $u(i);
  }
}
var Xu = g0;
function y0(i) {
  return typeof i.constructor == "function" && !xo(i) ? wc(Io(i)) : {};
}
var Ki = y0;
var x0 = "[object Map]";
function v0(i) {
  return Ze(i) && Mo(i) == x0;
}
var Yu = v0;
var Ku = fr && fr.isMap;
var b0 = Ku ? bo(Ku) : Yu;
var Qu = b0;
var S0 = "[object Set]";
function w0(i) {
  return Ze(i) && Mo(i) == S0;
}
var Ju = w0;
var Zu = fr && fr.isSet;
var T0 = Zu ? bo(Zu) : Ju;
var ep = T0;
var N0 = 1;
var C0 = 2;
var L0 = 4;
var tp = "[object Arguments]";
var I0 = "[object Array]";
var P0 = "[object Boolean]";
var A0 = "[object Date]";
var M0 = "[object Error]";
var rp = "[object Function]";
var O0 = "[object GeneratorFunction]";
var _0 = "[object Map]";
var D0 = "[object Number]";
var op = "[object Object]";
var E0 = "[object RegExp]";
var B0 = "[object Set]";
var G0 = "[object String]";
var R0 = "[object Symbol]";
var z0 = "[object WeakMap]";
var V0 = "[object ArrayBuffer]";
var F0 = "[object DataView]";
var U0 = "[object Float32Array]";
var j0 = "[object Float64Array]";
var k0 = "[object Int8Array]";
var H0 = "[object Int16Array]";
var W0 = "[object Int32Array]";
var q0 = "[object Uint8Array]";
var $0 = "[object Uint8ClampedArray]";
var X0 = "[object Uint16Array]";
var Y0 = "[object Uint32Array]";
var Le = {};
Le[tp] = Le[I0] = Le[V0] = Le[F0] = Le[P0] = Le[A0] = Le[U0] = Le[j0] = Le[k0] = Le[H0] = Le[W0] = Le[_0] = Le[D0] = Le[op] = Le[E0] = Le[B0] = Le[G0] = Le[R0] = Le[q0] = Le[$0] = Le[X0] = Le[Y0] = true;
Le[M0] = Le[rp] = Le[z0] = false;
function Qi(i, r, e, t, o, n) {
  var s, a = r & N0, l = r & C0, c = r & L0;
  if (e && (s = o ? e(i, t, o, n) : e(i)), s !== void 0)
    return s;
  if (!et(i))
    return i;
  var u = Re(i);
  if (u) {
    if (s = ju(i), !a)
      return Ai(i, s);
  } else {
    var m = Mo(i), p = m == rp || m == O0;
    if (vo(i))
      return Ui(i, a);
    if (m == op || m == tp || p && !o) {
      if (s = l || p ? {} : Ki(i), !a)
        return l ? Bu(i, Iu(s, i)) : Eu(i, Lu(s, i));
    } else {
      if (!Le[m])
        return o ? i : {};
      s = Xu(i, m, a);
    }
  }
  n || (n = new Fi());
  var d = n.get(i);
  if (d)
    return d;
  n.set(i, s), ep(i) ? i.forEach(function(x) {
    s.add(Qi(x, r, e, x, i, n));
  }) : Qu(i) && i.forEach(function(x, y) {
    s.set(y, Qi(x, r, e, y, i, n));
  });
  var f = c ? l ? Wi : Gu : l ? kt : So, g = u ? void 0 : f(i);
  return Ic(g || i, function(x, y) {
    g && (y = x, x = i[y]), _i(s, y, Qi(x, r, e, y, i, n));
  }), s;
}
var Ji = Qi;
var K0 = 1;
var Q0 = 4;
function J0(i) {
  return Ji(i, K0 | Q0);
}
var Cn = J0;
function Z0(i) {
  return function(r, e, t) {
    for (var o = -1, n = Object(r), s = t(r), a = s.length; a--; ) {
      var l = s[i ? a : ++o];
      if (e(n[l], l, n) === false)
        break;
    }
    return r;
  };
}
var np = Z0;
var ev = np();
var ip = ev;
function tv(i, r, e) {
  (e !== void 0 && !Lr(i[r], e) || e === void 0 && !(r in i)) && yo(i, r, e);
}
var Ln = tv;
function rv(i) {
  return Ze(i) && Ir(i);
}
var sp = rv;
function ov(i, r) {
  if (!(r === "constructor" && typeof i[r] == "function") && r != "__proto__")
    return i[r];
}
var In = ov;
function nv(i) {
  return wt(i, kt(i));
}
var ap = nv;
function iv(i, r, e, t, o, n, s) {
  var a = In(i, e), l = In(r, e), c = s.get(l);
  if (c) {
    Ln(i, e, c);
    return;
  }
  var u = n ? n(a, l, e + "", i, r, s) : void 0, m = u === void 0;
  if (m) {
    var p = Re(l), d = !p && vo(l), f = !p && !d && Bi(l);
    u = l, p || d || f ? Re(a) ? u = a : sp(a) ? u = Ai(a) : d ? (m = false, u = Ui(l, true)) : f ? (m = false, u = Yi(l, true)) : u = [] : Vi(l) || qr(l) ? (u = a, qr(a) ? u = ap(a) : (!et(a) || ho(a)) && (u = Ki(l))) : m = false;
  }
  m && (s.set(l, u), o(u, l, t, n, s), s.delete(l)), Ln(i, e, u);
}
var lp = iv;
function cp(i, r, e, t, o) {
  i !== r && ip(r, function(n, s) {
    if (o || (o = new Fi()), et(n))
      lp(i, r, s, e, cp, t, o);
    else {
      var a = t ? t(In(i, s), n, s + "", i, r, o) : void 0;
      a === void 0 && (a = n), Ln(i, s, a);
    }
  }, kt);
}
var up = cp;
function sv(i) {
  var r = i == null ? 0 : i.length;
  return r ? i[r - 1] : void 0;
}
var pp = sv;
function av(i, r) {
  return r.length < 2 ? i : mu(i, bu(r, 0, -1));
}
var mp = av;
var lv = Oc(function(i, r, e) {
  up(i, r, e);
});
var Xr = lv;
function cv(i, r) {
  return r = Co(r, i), i = mp(i, r), i == null || delete i[zi(pp(r))];
}
var dp = cv;
function uv(i) {
  return Vi(i) ? void 0 : i;
}
var fp = uv;
var pv = 1;
var mv = 2;
var dv = 4;
var fv = xu(function(i, r) {
  var e = {};
  if (i == null)
    return e;
  var t = false;
  r = Ci(r, function(n) {
    return n = Co(n, i), t || (t = n.length > 1), n;
  }), wt(i, Wi(i), e), t && (e = Ji(e, pv | mv | dv, fp));
  for (var o = r.length; o--; )
    dp(e, r[o]);
  return e;
});
var _o = fv;
var Do;
((e) => {
  e.all = ["PerspectiveCamera", "OrthographicCamera"];
  function r(t) {
    return e.all.includes(t);
  }
  e.is = r;
})(Do || (Do = {}));
var Yr;
((o) => {
  o.DefaultUp = [0, 1, 0], o.DefaultTargetOffset = 1e3, o.defaultData = { far: 1e5, type: "OrthographicCamera", perspective: { near: 5, fov: 45, zoom: 1 }, orthographic: { near: -1e5, zoom: 1 }, up: o.DefaultUp, isUpVectorFlipped: false, targetOffset: o.DefaultTargetOffset };
  function t(n) {
    return n.type === "PerspectiveCamera" ? n.perspective.zoom : n.orthographic.zoom;
  }
  o.getZoom = t;
})(Yr || (Yr = {}));
var hp;
((e) => {
  function i(t, o) {
    return t[0] === o[0] && t[1] === o[1];
  }
  e.isEqual = i;
  function r(t, o, n) {
    return [t[0] + (o[0] - t[0]) * n, t[1] + (o[1] - t[1]) * n];
  }
  e.lerp = r;
})(hp || (hp = {}));
var Eo;
((o) => {
  function i(n, s) {
    return n[0] === s[0] && n[1] === s[1] && n[2] === s[2];
  }
  o.isEqual = i;
  function r(n, s) {
    return [n[0] + s[0], n[1] + s[1], n[2] + s[2]];
  }
  o.add = r;
  function e(n, s) {
    return [n[0] - s[0], n[1] - s[1], n[2] - s[2]];
  }
  o.sub = e;
  function t(n, s, a) {
    return [n[0] + (s[0] - n[0]) * a, n[1] + (s[1] - n[1]) * a, n[2] + (s[2] - n[2]) * a];
  }
  o.lerp = t;
})(Eo || (Eo = {}));
var gp;
((e) => {
  function i(t, o) {
    return t[0] === o[0] && t[1] === o[1] && t[2] === o[2] && t[3] === o[3];
  }
  e.isEqual = i;
  function r(t, o, n) {
    return [t[0] + (o[0] - t[0]) * n, t[1] + (o[1] - t[1]) * n, t[2] + (o[2] - t[2]) * n, t[3] + (o[3] - t[3]) * n];
  }
  e.lerp = r;
})(gp || (gp = {}));
var _r;
((o) => {
  o.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  function r(n, s) {
    for (let a = 0; a < 16; a++)
      if (n[a] !== s[a])
        return false;
    return true;
  }
  o.isEqual = r;
  function e(n) {
    return n != null ? n : o.identity;
  }
  o.simplify = e;
  function t(n, s) {
    let a = s.slice(0);
    for (var l = 0, c = s.length; l < c; l += 3) {
      let u = n[3] * s[l] + n[7] * s[l + 1] + n[11] * s[l + 2] + n[15];
      a[l] = (n[0] * s[l] + n[4] * s[l + 1] + n[8] * s[l + 2] + n[12]) / u, a[l + 1] = (n[1] * s[l] + n[5] * s[l + 1] + n[9] * s[l + 2] + n[13]) / u, a[l + 2] = (n[2] * s[l] + n[6] * s[l + 1] + n[10] * s[l + 2] + n[14]) / u;
    }
    return a;
  }
  o.applyMatrix4 = t;
})(_r || (_r = {}));
var xt;
((l) => {
  l.white = { r: 1, g: 1, b: 1 }, l.red = { r: 1, g: 0, b: 0 }, l.black = { r: 0, g: 0, b: 0 };
  function t(c) {
    return { r: Math.round(c.r * 255), g: Math.round(c.g * 255), b: Math.round(c.b * 255), a: 1 };
  }
  l.toRgb255a1 = t;
  function o(c) {
    return { r: c.r, g: c.g, b: c.b };
  }
  l.clone = o;
  function n(c) {
    return c = Math.floor(c), { r: (c >> 16 & 255) / 255, g: (c >> 8 & 255) / 255, b: (c & 255) / 255 };
  }
  l.fromHex = n;
  function s(c, u) {
    return c.r === u.r && c.g === u.g && c.b === u.b;
  }
  l.equals = s;
  function a(c, u, m) {
    return { r: c.r + (u.r - c.r) * m, g: c.g + (u.g - c.g) * m, b: c.b + (u.b - c.b) * m };
  }
  l.lerp = a;
})(xt || (xt = {}));
var vt;
((s) => {
  s.white = __spreadProps(__spreadValues({}, xt.white), { a: 1 });
  function r(a) {
    return { r: a[0], g: a[1], b: a[2], a: a[3] };
  }
  s.from0to1 = r;
  function e(a, l) {
    return __spreadProps(__spreadValues({}, xt.fromHex(a)), { a: l });
  }
  s.fromHexAndA = e;
  function t(a) {
    return { r: Math.round(a.r * 255), g: Math.round(a.g * 255), b: Math.round(a.b * 255), a: a.a };
  }
  s.toRgb255a1 = t;
  function o(a, l) {
    return xt.equals(a, l) && a.a === l.a;
  }
  s.equals = o;
  function n(a, l, c) {
    return { r: a.r + (l.r - a.r) * c, g: a.g + (l.g - a.g) * c, b: a.b + (l.b - a.b) * c, a: a.a + (l.a - a.a) * c };
  }
  s.lerp = n;
})(vt || (vt = {}));
var Zi;
((r) => r.identity = { position: [0, 0, 0], rotation: [0, 0, 0], scale: [1, 1, 1] })(Zi || (Zi = {}));
var yp;
((r) => r.defaultData = { mass: 1, stiffness: 80, damping: 10, velocity: 0 })(yp || (yp = {}));
var xp;
((r) => r.defaultData = { control1: [0.5, 0.05], control2: [0.1, 0.3] })(xp || (xp = {}));
var es;
((r) => {
  function i(e, t = 0.1) {
    return { type: "radial", hideBase: false, count: 3, radial: { radius: Math.max(e[0], e[1]) * 2, start: 0, end: 360, alignment: false, axis: "y", scale: [1, 1, 1], rotation: [0, 0, 0], position: [0, 0, 0] }, linear: { scale: [1, 1, 1], rotation: [0, 0, 0], position: [e[0] + e[0] * t, 0, 0] }, grid: { count: [2, 2, 2], size: e.map((o) => o * (1 + t)), useCenter: true } };
  }
  r.defaultData = i;
})(es || (es = {}));
var Ve = class {
  modifyById(r, e) {
    let t = this;
    if (t[r] === void 0)
      throw new Error("not expected");
    {
      let n = __spreadProps(__spreadValues({}, t), { [r]: e });
      return Object.setPrototypeOf(n, Ve.prototype), n;
    }
  }
  add(r, e) {
    var _a2, _b2;
    return (_b2 = (_a2 = this.runOp({ type: 1, id: r, data: e })) == null ? void 0 : _a2.data) != null ? _b2 : this;
  }
  runOp(r) {
    let e = this;
    if (r.type === 1) {
      let t = e[r.id], o;
      t === void 0 ? o = { type: 2, id: r.id } : o = { type: 1, id: r.id, data: t };
      let { id: n, data: s } = r, a = __spreadProps(__spreadValues({}, e), { [n]: s });
      return Object.setPrototypeOf(a, Ve.prototype), { data: a, actual: r, reverse: o };
    } else if (r.type === 2) {
      let { id: t } = r, o = e[t];
      if (o === void 0)
        return null;
      {
        let n = __spreadValues({}, e);
        return Object.setPrototypeOf(n, Ve.prototype), delete n[t], { data: n, actual: r, reverse: { type: 1, id: t, data: o } };
      }
    }
    throw new Error("illegal arg");
  }
};
function Pn(i) {
  if (i.deepFreeze !== void 0) {
    i.deepFreeze(i);
    return;
  }
  let r = Object.getOwnPropertyNames(i);
  for (let e of r) {
    let t = i[e];
    t && typeof t == "object" && Pn(t);
  }
  return Object.freeze(i);
}
function vp(i, r) {
  let e = 0;
  for (; e < i.length && e < r.length; ) {
    if (i[e] < r[e])
      return -1;
    if (i[e] > r[e])
      return 1;
    e += 1;
  }
  return e !== r.length ? -1 : e !== i.length ? 1 : 0;
}
var ts = class extends Error {
};
function Ht(i, r, e) {
  if (i === void 0 ? r === void 0 ? (i = 0, r = 10) : i = r - 10 : r === void 0 && (r = i + 10), i > r) {
    let n = i;
    i = r, r = n;
  }
  let t = [], o = 1 / (e + 1);
  for (let n = 0; n < e; n++) {
    let s = i + (r - i) * (n + 0.75 + Math.random() * 0.5) * o;
    t.push(s);
  }
  return t;
}
function rs(i) {
  return i instanceof Uint8Array || i instanceof Uint16Array || i instanceof Uint32Array || i instanceof Int8Array || i instanceof Int16Array || i instanceof Int32Array || i instanceof Float32Array || i instanceof Float64Array;
}
function bp() {
  return typeof process < "u";
}
function Sp(i, r) {
  for (let e of i)
    r(e.id, e.data), Sp(e.children, r);
}
function wp(i, r) {
  r(i.id, i.data);
  for (let e of i.children)
    wp(e, r);
}
var Tt = class extends Array {
  constructor(...e) {
    super(...e);
    Object.setPrototypeOf(this, Tt.prototype);
  }
  deepFreeze() {
    let e = 0;
    for (; e < this.length; )
      Pn(this[e]), e++;
  }
  fillCaches0(e, t) {
    this.objCaches.set(e.id, e), this.parentCaches.set(e.id, t);
    for (let o of e.children)
      this.fillCaches0(o, e.id);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      this.objCaches = new Map(), this.parentCaches = new Map();
      for (let e of this)
        this.fillCaches0(e, null);
    }
  }
  randomId() {
    this.fillCaches();
    let e = Array.from(this.objCaches.keys());
    if (e.length !== 0)
      return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
  }
  isDescendantOf(e, t) {
    for (; e; ) {
      let o = this.parent(e);
      if (o === t)
        return true;
      e = o;
    }
    return false;
  }
  data(e) {
    var _a2;
    return (_a2 = this.get(e)) == null ? void 0 : _a2.data;
  }
  has(e) {
    return this.childrenOf(e) !== void 0;
  }
  get(e) {
    return this.fillCaches(), this.objCaches.get(e);
  }
  childrenOf(e) {
    var _a2;
    return e === null ? this : (_a2 = this.get(e)) == null ? void 0 : _a2.children;
  }
  traverseFrom(e, t) {
    if (e === null)
      this.traverse(t);
    else {
      let o = this.get(e);
      o && wp(o, t);
    }
  }
  traverse(e) {
    Sp(this, e);
  }
  totalSize() {
    return this.fillCaches(), this.objCaches.size;
  }
  parent(e) {
    return this.fillCaches(), this.parentCaches.get(e);
  }
  childrenArray(e) {
    return e === null ? this : this.get(e).children;
  }
  modifyById(e, t) {
    if (this.get(e) === void 0)
      throw new Error("not expected");
    {
      let n = this.parent(e), s = this.childrenArray(n), a = s.findIndex((u) => u.id === e);
      if (a < 0)
        throw new Error("not expected");
      let l = s[a];
      return s = [...s], s[a] = __spreadProps(__spreadValues({}, l), { data: t }), this.modifyArrayBy(n, s);
    }
  }
  modifyArrayBy(e, t) {
    let o = e, n = t;
    for (; o !== null; ) {
      let a = n, l = o;
      if (o = this.parent(o), o === void 0)
        throw new Error();
      n = this.childrenArray(o);
      let c = n.findIndex((u) => u.id === l);
      if (c < 0)
        throw new Error();
      n = [...n], n[c] = __spreadProps(__spreadValues({}, n[c]), { children: a });
    }
    Object.setPrototypeOf(n, Tt.prototype);
    let s = n;
    return s.fillCaches(), s;
  }
  runOp(e) {
    switch (e.type) {
      case 7:
        return this.addOp(e);
      case 8:
        return this.deleteOp(e);
      case 9:
        return this.moveOp(e);
    }
  }
  checkDuplicatedIdRec({ id: e, children: t }) {
    if (this.get(e) !== void 0)
      return true;
    for (let o of t)
      if (this.checkDuplicatedIdRec(o))
        return true;
    return false;
  }
  addOp(e) {
    let { parent: t, fi: o, id: n, data: s, children: a } = e;
    if (t !== null && this.get(t) === void 0)
      return null;
    if (this.checkDuplicatedIdRec(e))
      return null;
    {
      let l = t, c = this.childrenArray(l), u = { fi: o, id: n, data: s, children: a };
      return c = [...c, u], c.sort((p, d) => p.fi - d.fi), e.localIndex = c.indexOf(u), { data: this.modifyArrayBy(l, c), actual: e, reverse: { type: 8, id: n } };
    }
  }
  deleteOp(e) {
    let { id: t } = e;
    if (this.get(t) === null)
      return null;
    {
      let o = this.parent(t);
      if (o === void 0)
        return null;
      let n = this.childrenArray(o), s = n.findIndex((c) => c.id === t);
      e.localIndex = s, n = [...n];
      let a = n.splice(s, 1)[0];
      return { data: this.modifyArrayBy(o, n), actual: e, reverse: __spreadProps(__spreadValues({ type: 7 }, a), { parent: o }) };
    }
  }
  moveOp(e) {
    let { parent: t, fi: o, id: n } = e;
    if (t !== null && this.get(t) === void 0)
      return this.deleteOp({ type: 8, id: n });
    if (t !== null) {
      let d = t;
      for (; d !== null; ) {
        if (d === void 0)
          throw new Error();
        if (d === n)
          throw new ts("cyclic tree");
        d = this.parent(d);
      }
    }
    let s = this.parent(n);
    if (s === void 0)
      return null;
    let a = s, l = this.childrenArray(s), c = l.findIndex((d) => d.id === n);
    l = [...l];
    let u = l.splice(c, 1)[0], m = this.modifyArrayBy(s, l);
    s = t, l = m.childrenArray(s);
    let p = u.fi;
    return u = __spreadProps(__spreadValues({}, u), { fi: o }), l = [...l, u], l.sort((d, f) => d.fi - f.fi), e.localIndex = l.indexOf(u), m = m.modifyArrayBy(s, l), { data: m, actual: e, reverse: { type: 9, parent: a, fi: p, id: n } };
  }
  previous(e, t) {
    if (t === null) {
      let n = this.childrenArray(e);
      return n.length === 0 ? null : n[n.length - 1].id;
    }
    let o = null;
    for (let n of this.childrenArray(e)) {
      if (n.id === t)
        return o;
      o = n.id;
    }
    return null;
  }
  traverseSortNext(e) {
    let t = this.parent(e);
    if (t !== void 0) {
      let o = this.childrenArray(t), n = o.findIndex((s) => s.id === e) + 1;
      if (n < o.length)
        return o[n].id;
      if (t)
        return this.traverseSortNext(t);
    }
  }
  sortNext(e) {
    let t = this.childrenArray(e);
    return t.length > 0 ? t[0].id : this.traverseSortNext(e);
  }
  traverseSortPrevious(e) {
    let t = this.childrenArray(e);
    return t.length > 0 ? this.traverseSortPrevious(t[t.length - 1].id) : e;
  }
  sortPrevious(e) {
    let t = this.parent(e);
    if (t !== void 0) {
      let o = this.childrenArray(t), n = o.findIndex((s) => s.id === e) - 1;
      return n >= 0 ? this.traverseSortPrevious(o[n].id) : t;
    }
  }
  getAllSorted(e) {
    let t = [];
    for (let o of e) {
      let n = this.getWithSortKey(o.id);
      n !== void 0 && t.push(__spreadValues(__spreadValues({}, o), n));
    }
    t.sort((o, n) => vp(o.sortKey, n.sortKey));
    for (let o of t)
      delete o.sortKey;
    return t;
  }
  getWithSortKey(e) {
    var t = e;
    let o = [], n = this.get(t), s = n;
    if (n !== void 0) {
      for (; t; )
        o.splice(0, 0, n.fi), t = this.parent(t), t !== null && (n = this.get(t));
      return __spreadProps(__spreadValues({}, s), { sortKey: o });
    }
  }
  insertBeforeHelper(e, t, o) {
    return this.insertAfterHelper(e, this.previous(e, t), o);
  }
  insertAfterHelper(e, t, o) {
    let n = this.childrenArray(e);
    if (t === null) {
      if (n.length === 0)
        return Ht(0, o, o);
      {
        let s = n[0].fi;
        return Ht(s - o, s, o);
      }
    } else {
      let s = this.get(t);
      if (s === void 0 || this.parent(t) !== e)
        throw new Error("illegal args");
      let a = n.find((l) => l.fi > s.fi);
      if (a === void 0) {
        let l = n[n.length - 1].fi;
        return Ht(l, l + o, o);
      } else
        return Ht(s.fi, a.fi, o);
    }
  }
};
var os;
((r) => {
  function i(e, t) {
    if (Array.isArray(e)) {
      let o = t.props, n = {}, s = [...e], a = false;
      if (o)
        for (let l of Object.keys(o)) {
          let c = parseInt(l);
          if (isNaN(c))
            throw new Error("wrong index");
          n[l] = s[c], s[c] = o[l], a = true;
        }
      return a ? { data: s, actual: t, reverse: { type: 0, props: n } } : null;
    } else {
      let o = t.props, n = {}, s = __spreadValues({}, e), a = false;
      if (o)
        for (let l of Object.keys(o)) {
          n[l] = s[l];
          let c = o[l];
          c === void 0 ? delete s[l] : s[l] = c, a = true;
        }
      return a ? { data: s, actual: t, reverse: { type: 0, props: n } } : null;
    }
  }
  r.runOp = i;
})(os || (os = {}));
var Ae = class extends Array {
  constructor(...e) {
    super(...e);
    Object.setPrototypeOf(this, Ae.prototype);
  }
  deepFreeze() {
    let e = 0;
    for (; e < this.length; )
      Pn(this[e]), e++;
  }
  fillCaches0(e) {
    this.objCaches.set(e.id, e);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      this.objCaches = new Map(), Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = false;
      for (let e of this)
        this.fillCaches0(e);
    }
  }
  randomId() {
    this.fillCaches();
    let e = Array.from(this.objCaches.keys());
    if (e.length !== 0)
      return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
  }
  data(e) {
    var _a2;
    return (_a2 = this.get(e)) == null ? void 0 : _a2.data;
  }
  get(e) {
    return this.fillCaches(), this.objCaches.get(e);
  }
  modifyById(e, t) {
    if (this.get(e) === void 0)
      throw new Error("not expected");
    {
      let n = this, s = n.findIndex((c) => c.id === e);
      if (s < 0)
        throw new Error("not expected");
      let a = n[s];
      return n = [...n], n[s] = __spreadProps(__spreadValues({}, a), { data: t }), this.modifyArrayBy(n);
    }
  }
  modifyArrayBy(e) {
    Object.setPrototypeOf(e, Ae.prototype);
    let t = e;
    return bp() || t.fillCaches(), t;
  }
  runOp(e) {
    switch (e.type) {
      case 4:
        return this.addOp(e);
      case 5:
        return this.deleteOp(e);
      case 6:
        return this.moveOp(e);
    }
  }
  addOp(e) {
    let { fi: t, id: o, data: n } = e, s = this, a = { fi: t, id: o, data: n };
    return s = [...s, a], s.sort((c, u) => c.fi - u.fi), e.localIndex = s.indexOf(a), { data: this.modifyArrayBy(s), actual: e, reverse: { type: 5, id: o } };
  }
  deleteOp(e) {
    let { id: t } = e, o = this, n = o.findIndex((l) => l.id === t);
    if (n === -1)
      return null;
    e.localIndex = n, o = [...o];
    let s = o.splice(n, 1)[0];
    return { data: this.modifyArrayBy(o), actual: e, reverse: __spreadValues({ type: 4 }, s) };
  }
  moveOp(e) {
    let { fi: t, id: o } = e, n = this;
    n = [...n];
    let s = n.findIndex((u) => u.id === o);
    if (s === -1)
      return null;
    let a = n[s].fi, l = __spreadProps(__spreadValues({}, n[s]), { fi: t });
    return n[s] = l, n.sort((u, m) => u.fi - m.fi), e.localIndex = n.indexOf(l), { data: this.modifyArrayBy(n), actual: e, reverse: { type: 6, fi: a, id: o } };
  }
  previous(e) {
    if (e === null)
      return this.length === 0 ? null : this[this.length - 1].id;
    let t = null;
    for (let o of this) {
      if (o.id === e)
        return t;
      t = o.id;
    }
    return null;
  }
  insertBeforeHelper(e, t) {
    return this.insertAfterHelper(this.previous(e), t);
  }
  insertAfterHelper(e, t) {
    let o = this;
    if (e === null) {
      if (o.length === 0)
        return Ht(0, t, t);
      {
        let n = o[0].fi;
        return Ht(n - t, n, t);
      }
    } else {
      let n = this.get(e);
      if (n === void 0)
        throw new Error("illegal args");
      let s = o.find((a) => a.fi > n.fi);
      if (s === void 0) {
        let a = o[o.length - 1].fi;
        return Ht(a, a + t, t);
      } else
        return Ht(n.fi, s.fi, t);
    }
  }
};
var Tp = Symbol();
var is = Symbol();
var Bo = class {
  reportOp(r, e) {
    let t = this;
    if (e === null)
      return;
    t._current = e.data;
    let o = [];
    for (; !(t instanceof ns); ) {
      let n = t._path, s = t._current;
      if (n !== "" && o.splice(0, 0, n), t = t._parent, t === null)
        return;
      t.update(n, s);
    }
    t.push(o, r, e.actual, e.reverse);
  }
  deleteChildren(r) {
    if (this._children) {
      let e = this._children[r];
      if (e) {
        let t = e[is];
        t && t(), delete this._children[r];
      }
    }
  }
};
var wa = class extends Bo {
  constructor(r, e, t) {
    super(), this._parent = r, this._path = e, this._current = t;
  }
  update(r, e) {
    if (Array.isArray(this._current)) {
      if (typeof r == "string" && (r = parseInt(r), isNaN(r)))
        throw new Error("Invalid path");
      this._current = [...this._current], this._current[r] = e;
    } else
      this._current = __spreadProps(__spreadValues({}, this._current), { [r]: e });
  }
  runOp(r) {
    this.reportOp(r, os.runOp(this._current, r));
  }
};
var Ta = class extends Bo {
  constructor(r, e, t) {
    super(), this._parent = r, this._path = e, this._current = t;
  }
  update(r, e) {
    this._current = __spreadProps(__spreadValues({}, this._current), { [r]: e }), Object.setPrototypeOf(this._current, Ve.prototype);
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
};
var Np = { get(i, r) {
  if (r === is)
    return () => {
      i._parent = null;
    };
  if (r === Tp)
    return i._current;
  let { _current: e, _children: t } = i;
  if (r === "push" && Array.isArray(e))
    throw new Error("not supported to expand array");
  let o = t === void 0 ? void 0 : t[r];
  if (o !== void 0)
    return o;
  let n = e[r], s = ss(i, r, n);
  return s !== n ? (t === void 0 && (t = {}, i._children = t), t[r] = s, s) : n;
}, has(i, r) {
  return r in i._current;
}, ownKeys(i) {
  return Reflect.ownKeys(i._current);
}, defineProperty() {
  throw Error("not supported");
}, getPrototypeOf(i) {
  return Object.getPrototypeOf(i._current);
}, setPrototypeOf() {
  throw Error("not supported");
}, getOwnPropertyDescriptor(i, r) {
  let e = i._current, t = Reflect.getOwnPropertyDescriptor(e, r);
  return t && { writable: true, configurable: true, enumerable: t.enumerable, value: e[r] };
} };
var hv = __spreadProps(__spreadValues({}, Np), { set(i, r, e) {
  var _a2;
  let t = { type: 0, props: { [r]: (_a2 = La(e)) != null ? _a2 : e } };
  return i.deleteChildren(r), i.runOp(t), true;
}, deleteProperty(i, r) {
  let e = { type: 0, props: { [r]: void 0 } };
  return i.deleteChildren(r), i.runOp(e), true;
} });
var gv = __spreadProps(__spreadValues({}, Np), { set(i, r, e) {
  return e === void 0 ? this.deleteProperty(i, r) : (i.deleteChildren(r), i.runOp({ type: 1, id: r, data: e })), true;
}, deleteProperty(i, r) {
  return i.runOp({ type: 2, id: r }), true;
} });
var Go = class extends Bo {
  constructor(r, e, t) {
    super(), this._children = {}, this._parent = r, this._path = e, this._current = t, this[is] = () => {
      this._parent = null;
    };
  }
  unproxy() {
    return this._current;
  }
  update(r, e) {
    this._current = this._current.modifyById(r, e);
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
  randomId() {
    return this._current.randomId();
  }
  isDescendantOf(r, e) {
    return this._current.isDescendantOf(r, e);
  }
  childrenOf(r) {
    return this._current.childrenOf(r);
  }
  traverse(r) {
    return this._current.traverse(r);
  }
  get(r) {
    return this._current.get(r);
  }
  parent(r) {
    return this._current.parent(r);
  }
  traverse(r) {
    this._current.traverse((e, t) => {
      r(e, this.data(e));
    });
  }
  data(r) {
    var _a2;
    let { _current: e, _children: t } = this, o = t === void 0 ? void 0 : t[r];
    if (o !== void 0)
      return o;
    let n = (_a2 = e.get(r)) == null ? void 0 : _a2.data, s = ss(this, r, n);
    return s !== n ? (t === void 0 && (t = {}, this._children = t), t[r] = s, s) : n;
  }
  add(r, e, t, o, n) {
    this.runOp({ type: 7, parent: r, fi: e, id: t, data: o, children: n });
  }
  move(r, e, t) {
    this.runOp({ type: 9, parent: r, fi: e, id: t });
  }
  insertAfter(r, e, t) {
    let o = this._current.insertAfterHelper(r, e, t.length);
    for (let n = 0; n < t.length; n++) {
      let s = t[n];
      this.add(r, o[n], s.id, s.data, s.children);
    }
  }
  insertBefore(r, e, t) {
    let o = this._current.insertBeforeHelper(r, e, t.length);
    for (let n = 0; n < t.length; n++) {
      let s = t[n];
      this.add(r, o[n], s.id, s.data, s.children);
    }
  }
  moveAfter(r, e, t) {
    let o = this._current.insertAfterHelper(r, e, t.length);
    for (let n = 0; n < t.length; n++) {
      let s = t[n];
      this.move(r, o[n], s);
    }
  }
  moveBefore(r, e, t) {
    let o = this._current.insertBeforeHelper(r, e, t.length);
    for (let n = 0; n < t.length; n++) {
      let s = t[n];
      this.move(r, o[n], s);
    }
  }
  delete(r) {
    this.deleteChildren(r), this.runOp({ type: 8, id: r });
  }
  sortNext(r) {
    return this._current.sortNext(r);
  }
  sortPrevious(r) {
    return this._current.sortPrevious(r);
  }
  getAllSorted(r) {
    return this._current.getAllSorted(r);
  }
};
var Ro = class extends Bo {
  constructor(r, e, t) {
    super(), this._children = {}, this._parent = r, this._path = e, this._current = t, this[is] = () => {
      this._parent = null;
    };
  }
  unproxy() {
    return this._current;
  }
  get length() {
    return this._current.length;
  }
  forEach(r) {
    let e = this.length;
    for (let t = 0; t < e; t++) {
      let o = this._current[t].id;
      r(this.data(this._current[t].id), o);
    }
  }
  update(r, e) {
    this._current = this._current.modifyById(r, e);
  }
  randomId() {
    return this._current.randomId();
  }
  get(r) {
    return __spreadProps(__spreadValues({}, this._current.get(r)), { data: this.data(r) });
  }
  data(r) {
    var _a2;
    let { _current: e, _children: t } = this, o = t === void 0 ? void 0 : t[r];
    if (o !== void 0)
      return o;
    let n = (_a2 = e.get(r)) == null ? void 0 : _a2.data, s = ss(this, r, n);
    return s !== n ? (t === void 0 && (t = {}, this._children = t), t[r] = s, s) : n;
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
  add(r, e, t) {
    this.runOp({ type: 4, fi: r, id: e, data: t });
  }
  move(r, e) {
    this.runOp({ type: 6, fi: r, id: e });
  }
  insertAfter(r, e) {
    let t = this._current.insertAfterHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let n = e[o];
      this.add(t[o], n.id, n.data);
    }
  }
  insertBefore(r, e) {
    let t = this._current.insertBeforeHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let n = e[o];
      this.add(t[o], n.id, n.data);
    }
  }
  moveAfter(r, e) {
    let t = this._current.insertAfterHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let n = e[o];
      this.move(t[o], n);
    }
  }
  moveBefore(r, e) {
    let t = this._current.insertBeforeHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let n = e[o];
      this.move(t[o], n);
    }
  }
  delete(r) {
    this.deleteChildren(r), this.runOp({ type: 5, id: r });
  }
};
function Sa(i, r, e) {
  if (i.length > 0) {
    let t = i[i.length - 1];
    if (t.type === 0 && r.type === 0 && as.equal(t.path, e)) {
      Object.assign(t.props, r.props);
      return;
    }
  }
  i.push(__spreadProps(__spreadValues({}, r), { path: e }));
}
var ns = class {
  constructor(r) {
    this.ts = [], this.actual = [], this.reverse = [], this._current = r;
  }
  update(r, e) {
    if (r !== "")
      throw new Error("");
    this._current = e;
  }
  push(r, e, t, o) {
    Sa(this.ts, e, r), Sa(this.actual, t, r), Sa(this.reverse, o, r);
  }
  result() {
    return { data: this._current, ts: this.ts, actual: this.actual, reverse: this.reverse.reverse() };
  }
};
function ss(i, r, e) {
  return e instanceof Tt ? new Go(i, r, e) : e instanceof Ae ? new Ro(i, r, e) : e instanceof Ve ? new Proxy(new Ta(i, r, e), gv) : e !== null && typeof e == "object" ? rs(e) ? e : new Proxy(new wa(i, r, e), hv) : e;
}
function Na(i) {
  let r = new ns(i);
  return [ss(r, "", i), r];
}
function Ca(i, r) {
  let [e, t] = Na(i);
  return r(e), t.result();
}
function La(i) {
  return i instanceof Go || i instanceof Ro ? i._current : i !== null && typeof i == "object" ? i[Tp] : i;
}
var as;
((t) => {
  function i(o, n) {
    if (n.length === o.length)
      for (var s = 0; s < o.length; ) {
        if (o[s] !== n[s])
          return false;
        s += 1;
      }
    else
      return false;
    return true;
  }
  t.equal = i;
  function r(o, n, s) {
    let a = e(s, o);
    if (a !== void 0 && typeof a == "object" && a !== null) {
      let l = __spreadValues({}, n);
      return Object.keys(a).forEach((c) => {
        delete l[c];
      }), l;
    } else
      return n;
  }
  t.removeOverridden = r;
  function e(o, n, s = 0) {
    if (n.length <= s)
      return o;
    if ((o instanceof Tt || o instanceof Go) && typeof n[s] == "string")
      return e(o.data(n[s]), n, s + 1);
    if ((o instanceof Ae || o instanceof Ro) && typeof n[s] == "string")
      return e(o.data(n[s]), n, s + 1);
    if (typeof n[s] == "number" && Array.isArray(o))
      return e(o[n[s]], n, s + 1);
    if (typeof n[s] == "string" && typeof o == "object")
      return e(o[n[s]], n, s + 1);
  }
  t.zoom = e;
})(as || (as = {}));
var ls = class {
};
var An = class extends ls {
  constructor(e) {
    super();
    this.id = e;
  }
};
var Mn = class extends ls {
  constructor(e) {
    super();
    this.data = e;
  }
};
var Pa;
try {
  Pa = new TextDecoder();
} catch {
}
var te;
var Er;
var T = 0;
var _p = [];
var Aa = _p;
var Ma = 0;
var mt = {};
var xe;
var Dr;
var Nt = 0;
var Wt = 0;
var bt;
var gr;
var it = [];
var Te;
var Cp = { useRecords: false, mapsAsObjects: true };
var On = class {
};
var _a = new On();
_a.name = "MessagePack 0xC1";
var zo = false;
var qt = class {
  constructor(r) {
    r && (r.useRecords === false && r.mapsAsObjects === void 0 && (r.mapsAsObjects = true), r.structures ? r.structures.sharedLength = r.structures.length : r.getStructures && ((r.structures = []).uninitialized = true, r.structures.sharedLength = 0)), Object.assign(this, r);
  }
  unpack(r, e) {
    if (te)
      return Rp(() => (us(), this ? this.unpack(r, e) : qt.prototype.unpack.call(Cp, r, e)));
    Er = e > -1 ? e : r.length, T = 0, Ma = 0, Wt = 0, Dr = null, Aa = _p, bt = null, te = r;
    try {
      Te = r.dataView || (r.dataView = new DataView(r.buffer, r.byteOffset, r.byteLength));
    } catch (t) {
      throw te = null, r instanceof Uint8Array ? t : new Error("Source must be a Uint8Array or Buffer but was a " + (r && typeof r == "object" ? r.constructor.name : typeof r));
    }
    if (this instanceof qt) {
      if (mt = this, this.structures)
        return xe = this.structures, cs();
      (!xe || xe.length > 0) && (xe = []);
    } else
      mt = Cp, (!xe || xe.length > 0) && (xe = []);
    return cs();
  }
  unpackMultiple(r, e) {
    let t, o = 0;
    try {
      zo = true;
      let n = r.length, s = this ? this.unpack(r, n) : ds.unpack(r, n);
      if (e) {
        for (e(s); T < n; )
          if (o = T, e(cs()) === false)
            return;
      } else {
        for (t = [s]; T < n; )
          o = T, t.push(cs());
        return t;
      }
    } catch (n) {
      throw n.lastPosition = o, n.values = t, n;
    } finally {
      zo = false, us();
    }
  }
  _mergeStructures(r, e) {
    r = r || [];
    for (let t = 0, o = r.length; t < o; t++) {
      let n = r[t];
      n && (n.isShared = true, t >= 32 && (n.highByte = t - 32 >> 5));
    }
    r.sharedLength = r.length;
    for (let t in e || [])
      if (t >= 0) {
        let o = r[t], n = e[t];
        n && (o && ((r.restoreStructures || (r.restoreStructures = []))[t] = o), r[t] = n);
      }
    return this.structures = r;
  }
  decode(r, e) {
    return this.unpack(r, e);
  }
};
function cs() {
  try {
    if (!mt.trusted && !zo) {
      let r = xe.sharedLength || 0;
      r < xe.length && (xe.length = r);
    }
    let i = Oe();
    if (T == Er)
      xe.restoreStructures && Lp(), xe = null, te = null, gr && (gr = null);
    else if (T > Er) {
      let r = new Error("Unexpected end of MessagePack data");
      throw r.incomplete = true, r;
    } else if (!zo)
      throw new Error("Data read, but end of buffer not reached");
    return i;
  } catch (i) {
    throw xe.restoreStructures && Lp(), us(), (i instanceof RangeError || i.message.startsWith("Unexpected end of buffer")) && (i.incomplete = true), i;
  }
}
function Lp() {
  for (let i in xe.restoreStructures)
    xe[i] = xe.restoreStructures[i];
  xe.restoreStructures = null;
}
function Oe() {
  let i = te[T++];
  if (i < 160)
    if (i < 128) {
      if (i < 64)
        return i;
      {
        let r = xe[i & 63] || mt.getStructures && Dp()[i & 63];
        return r ? (r.read || (r.read = Da(r, i & 63)), r.read()) : i;
      }
    } else if (i < 144)
      if (i -= 128, mt.mapsAsObjects) {
        let r = {};
        for (let e = 0; e < i; e++)
          r[Bp()] = Oe();
        return r;
      } else {
        let r = new Map();
        for (let e = 0; e < i; e++)
          r.set(Oe(), Oe());
        return r;
      }
    else {
      i -= 144;
      let r = new Array(i);
      for (let e = 0; e < i; e++)
        r[e] = Oe();
      return r;
    }
  else if (i < 192) {
    let r = i - 160;
    if (Wt >= T)
      return Dr.slice(T - Nt, (T += r) - Nt);
    if (Wt == 0 && Er < 140) {
      let e = r < 16 ? Ea(r) : Ep(r);
      if (e != null)
        return e;
    }
    return Oa(r);
  } else {
    let r;
    switch (i) {
      case 192:
        return null;
      case 193:
        return bt ? (r = Oe(), r > 0 ? bt[1].slice(bt.position1, bt.position1 += r) : bt[0].slice(bt.position0, bt.position0 -= r)) : _a;
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        return Ia(te[T++]);
      case 197:
        return r = Te.getUint16(T), T += 2, Ia(r);
      case 198:
        return r = Te.getUint32(T), T += 4, Ia(r);
      case 199:
        return Kr(te[T++]);
      case 200:
        return r = Te.getUint16(T), T += 2, Kr(r);
      case 201:
        return r = Te.getUint32(T), T += 4, Kr(r);
      case 202:
        if (r = Te.getFloat32(T), mt.useFloat32 > 2) {
          let e = ms[(te[T] & 127) << 1 | te[T + 1] >> 7];
          return T += 4, (e * r + (r > 0 ? 0.5 : -0.5) >> 0) / e;
        }
        return T += 4, r;
      case 203:
        return r = Te.getFloat64(T), T += 8, r;
      case 204:
        return te[T++];
      case 205:
        return r = Te.getUint16(T), T += 2, r;
      case 206:
        return r = Te.getUint32(T), T += 4, r;
      case 207:
        return mt.int64AsNumber ? (r = Te.getUint32(T) * 4294967296, r += Te.getUint32(T + 4)) : r = Te.getBigUint64(T), T += 8, r;
      case 208:
        return Te.getInt8(T++);
      case 209:
        return r = Te.getInt16(T), T += 2, r;
      case 210:
        return r = Te.getInt32(T), T += 4, r;
      case 211:
        return mt.int64AsNumber ? (r = Te.getInt32(T) * 4294967296, r += Te.getUint32(T + 4)) : r = Te.getBigInt64(T), T += 8, r;
      case 212:
        if (r = te[T++], r == 114)
          return Op(te[T++] & 63);
        {
          let e = it[r];
          if (e)
            return e.read ? (T++, e.read(Oe())) : e.noBuffer ? (T++, e()) : e(te.subarray(T, ++T));
          throw new Error("Unknown extension " + r);
        }
      case 213:
        return r = te[T], r == 114 ? (T++, Op(te[T++] & 63, te[T++])) : Kr(2);
      case 214:
        return Kr(4);
      case 215:
        return Kr(8);
      case 216:
        return Kr(16);
      case 217:
        return r = te[T++], Wt >= T ? Dr.slice(T - Nt, (T += r) - Nt) : xv(r);
      case 218:
        return r = Te.getUint16(T), T += 2, Wt >= T ? Dr.slice(T - Nt, (T += r) - Nt) : vv(r);
      case 219:
        return r = Te.getUint32(T), T += 4, Wt >= T ? Dr.slice(T - Nt, (T += r) - Nt) : bv(r);
      case 220:
        return r = Te.getUint16(T), T += 2, Pp(r);
      case 221:
        return r = Te.getUint32(T), T += 4, Pp(r);
      case 222:
        return r = Te.getUint16(T), T += 2, Ap(r);
      case 223:
        return r = Te.getUint32(T), T += 4, Ap(r);
      default:
        if (i >= 224)
          return i - 256;
        if (i === void 0) {
          let e = new Error("Unexpected end of MessagePack data");
          throw e.incomplete = true, e;
        }
        throw new Error("Unknown MessagePack token " + i);
    }
  }
}
var yv = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function Da(i, r) {
  function e() {
    if (e.count++ > 2) {
      let o = i.read = new Function("r", "return function(){return {" + i.map((n) => yv.test(n) ? n + ":r()" : "[" + JSON.stringify(n) + "]:r()").join(",") + "}}")(Oe);
      return i.highByte === 0 && (i.read = Ip(r, i.read)), o();
    }
    let t = {};
    for (let o = 0, n = i.length; o < n; o++) {
      let s = i[o];
      t[s] = Oe();
    }
    return t;
  }
  return e.count = 0, i.highByte === 0 ? Ip(r, e) : e;
}
var Ip = (i, r) => function() {
  let e = te[T++];
  if (e === 0)
    return r();
  let t = i < 32 ? -(i + (e << 5)) : i + (e << 5), o = xe[t] || Dp()[t];
  if (!o)
    throw new Error("Record id is not defined for " + t);
  return o.read || (o.read = Da(o, i)), o.read();
};
function Dp() {
  let i = Rp(() => (te = null, mt.getStructures()));
  return xe = mt._mergeStructures(i, xe);
}
var Oa = ps;
var xv = ps;
var vv = ps;
var bv = ps;
function ps(i) {
  let r;
  if (i < 16 && (r = Ea(i)))
    return r;
  if (i > 64 && Pa)
    return Pa.decode(te.subarray(T, T += i));
  let e = T + i, t = [];
  for (r = ""; T < e; ) {
    let o = te[T++];
    if ((o & 128) === 0)
      t.push(o);
    else if ((o & 224) === 192) {
      let n = te[T++] & 63;
      t.push((o & 31) << 6 | n);
    } else if ((o & 240) === 224) {
      let n = te[T++] & 63, s = te[T++] & 63;
      t.push((o & 31) << 12 | n << 6 | s);
    } else if ((o & 248) === 240) {
      let n = te[T++] & 63, s = te[T++] & 63, a = te[T++] & 63, l = (o & 7) << 18 | n << 12 | s << 6 | a;
      l > 65535 && (l -= 65536, t.push(l >>> 10 & 1023 | 55296), l = 56320 | l & 1023), t.push(l);
    } else
      t.push(o);
    t.length >= 4096 && (r += qe.apply(String, t), t.length = 0);
  }
  return t.length > 0 && (r += qe.apply(String, t)), r;
}
function Pp(i) {
  let r = new Array(i);
  for (let e = 0; e < i; e++)
    r[e] = Oe();
  return r;
}
function Ap(i) {
  if (mt.mapsAsObjects) {
    let r = {};
    for (let e = 0; e < i; e++)
      r[Bp()] = Oe();
    return r;
  } else {
    let r = new Map();
    for (let e = 0; e < i; e++)
      r.set(Oe(), Oe());
    return r;
  }
}
var qe = String.fromCharCode;
function Ep(i) {
  let r = T, e = new Array(i);
  for (let t = 0; t < i; t++) {
    let o = te[T++];
    if ((o & 128) > 0) {
      T = r;
      return;
    }
    e[t] = o;
  }
  return qe.apply(String, e);
}
function Ea(i) {
  if (i < 4)
    if (i < 2) {
      if (i === 0)
        return "";
      {
        let r = te[T++];
        if ((r & 128) > 1) {
          T -= 1;
          return;
        }
        return qe(r);
      }
    } else {
      let r = te[T++], e = te[T++];
      if ((r & 128) > 0 || (e & 128) > 0) {
        T -= 2;
        return;
      }
      if (i < 3)
        return qe(r, e);
      let t = te[T++];
      if ((t & 128) > 0) {
        T -= 3;
        return;
      }
      return qe(r, e, t);
    }
  else {
    let r = te[T++], e = te[T++], t = te[T++], o = te[T++];
    if ((r & 128) > 0 || (e & 128) > 0 || (t & 128) > 0 || (o & 128) > 0) {
      T -= 4;
      return;
    }
    if (i < 6) {
      if (i === 4)
        return qe(r, e, t, o);
      {
        let n = te[T++];
        if ((n & 128) > 0) {
          T -= 5;
          return;
        }
        return qe(r, e, t, o, n);
      }
    } else if (i < 8) {
      let n = te[T++], s = te[T++];
      if ((n & 128) > 0 || (s & 128) > 0) {
        T -= 6;
        return;
      }
      if (i < 7)
        return qe(r, e, t, o, n, s);
      let a = te[T++];
      if ((a & 128) > 0) {
        T -= 7;
        return;
      }
      return qe(r, e, t, o, n, s, a);
    } else {
      let n = te[T++], s = te[T++], a = te[T++], l = te[T++];
      if ((n & 128) > 0 || (s & 128) > 0 || (a & 128) > 0 || (l & 128) > 0) {
        T -= 8;
        return;
      }
      if (i < 10) {
        if (i === 8)
          return qe(r, e, t, o, n, s, a, l);
        {
          let c = te[T++];
          if ((c & 128) > 0) {
            T -= 9;
            return;
          }
          return qe(r, e, t, o, n, s, a, l, c);
        }
      } else if (i < 12) {
        let c = te[T++], u = te[T++];
        if ((c & 128) > 0 || (u & 128) > 0) {
          T -= 10;
          return;
        }
        if (i < 11)
          return qe(r, e, t, o, n, s, a, l, c, u);
        let m = te[T++];
        if ((m & 128) > 0) {
          T -= 11;
          return;
        }
        return qe(r, e, t, o, n, s, a, l, c, u, m);
      } else {
        let c = te[T++], u = te[T++], m = te[T++], p = te[T++];
        if ((c & 128) > 0 || (u & 128) > 0 || (m & 128) > 0 || (p & 128) > 0) {
          T -= 12;
          return;
        }
        if (i < 14) {
          if (i === 12)
            return qe(r, e, t, o, n, s, a, l, c, u, m, p);
          {
            let d = te[T++];
            if ((d & 128) > 0) {
              T -= 13;
              return;
            }
            return qe(r, e, t, o, n, s, a, l, c, u, m, p, d);
          }
        } else {
          let d = te[T++], f = te[T++];
          if ((d & 128) > 0 || (f & 128) > 0) {
            T -= 14;
            return;
          }
          if (i < 15)
            return qe(r, e, t, o, n, s, a, l, c, u, m, p, d, f);
          let g = te[T++];
          if ((g & 128) > 0) {
            T -= 15;
            return;
          }
          return qe(r, e, t, o, n, s, a, l, c, u, m, p, d, f, g);
        }
      }
    }
  }
}
function Ia(i) {
  return mt.copyBuffers ? Uint8Array.prototype.slice.call(te, T, T += i) : te.subarray(T, T += i);
}
function Kr(i) {
  let r = te[T++];
  if (it[r])
    return it[r](te.subarray(T, T += i));
  throw new Error("Unknown extension type " + r);
}
var Mp = new Array(4096);
function Bp() {
  let i = te[T++];
  if (i >= 160 && i < 192) {
    if (i = i - 160, Wt >= T)
      return Dr.slice(T - Nt, (T += i) - Nt);
    if (!(Wt == 0 && Er < 180))
      return Oa(i);
  } else
    return T--, Oe();
  let r = (i << 5 ^ (i > 1 ? Te.getUint16(T) : i > 0 ? te[T] : 0)) & 4095, e = Mp[r], t = T, o = T + i - 3, n, s = 0;
  if (e && e.bytes == i) {
    for (; t < o; ) {
      if (n = Te.getUint32(t), n != e[s++]) {
        t = 1879048192;
        break;
      }
      t += 4;
    }
    for (o += 3; t < o; )
      if (n = te[t++], n != e[s++]) {
        t = 1879048192;
        break;
      }
    if (t === o)
      return T = t, e.string;
    o -= 3, t = T;
  }
  for (e = [], Mp[r] = e, e.bytes = i; t < o; )
    n = Te.getUint32(t), e.push(n), t += 4;
  for (o += 3; t < o; )
    n = te[t++], e.push(n);
  let a = i < 16 ? Ea(i) : Ep(i);
  return a != null ? e.string = a : e.string = Oa(i);
}
var Op = (i, r) => {
  var e = Oe();
  let t = i;
  r !== void 0 && (i = i < 32 ? -((r << 5) + i) : (r << 5) + i, e.highByte = r);
  let o = xe[i];
  return o && o.isShared && ((xe.restoreStructures || (xe.restoreStructures = []))[i] = o), xe[i] = e, e.read = Da(e, t), e.read();
};
var Gp = typeof self == "object" ? self : global;
it[0] = () => {
};
it[0].noBuffer = true;
it[101] = () => {
  let i = Oe();
  return (Gp[i[0]] || Error)(i[1]);
};
it[105] = (i) => {
  let r = Te.getUint32(T - 4);
  gr || (gr = new Map());
  let e = te[T], t;
  e >= 144 && e < 160 || e == 220 || e == 221 ? t = [] : t = {};
  let o = { target: t };
  gr.set(r, o);
  let n = Oe();
  return o.used ? Object.assign(t, n) : (o.target = n, n);
};
it[112] = (i) => {
  let r = Te.getUint32(T - 4), e = gr.get(r);
  return e.used = true, e.target;
};
it[115] = () => new Set(Oe());
var Ba = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((i) => i + "Array");
it[116] = (i) => {
  let r = i[0], e = Ba[r];
  if (!e)
    throw new Error("Could not find typed array for code " + r);
  return new Gp[e](Uint8Array.prototype.slice.call(i, 1).buffer);
};
it[120] = () => {
  let i = Oe();
  return new RegExp(i[0], i[1]);
};
it[98] = (i) => {
  let r = (i[0] << 24) + (i[1] << 16) + (i[2] << 8) + i[3], e = T;
  T += r - 4, bt = [Oe(), Oe()], bt.position0 = 0, bt.position1 = 0;
  let t = T;
  T = e;
  try {
    return Oe();
  } finally {
    T = t;
  }
};
it[255] = (i) => i.length == 4 ? new Date((i[0] * 16777216 + (i[1] << 16) + (i[2] << 8) + i[3]) * 1e3) : i.length == 8 ? new Date(((i[0] << 22) + (i[1] << 14) + (i[2] << 6) + (i[3] >> 2)) / 1e6 + ((i[3] & 3) * 4294967296 + i[4] * 16777216 + (i[5] << 16) + (i[6] << 8) + i[7]) * 1e3) : i.length == 12 ? new Date(((i[0] << 24) + (i[1] << 16) + (i[2] << 8) + i[3]) / 1e6 + ((i[4] & 128 ? -281474976710656 : 0) + i[6] * 1099511627776 + i[7] * 4294967296 + i[8] * 16777216 + (i[9] << 16) + (i[10] << 8) + i[11]) * 1e3) : new Date("invalid");
function Rp(i) {
  let r = Er, e = T, t = Ma, o = Nt, n = Wt, s = Dr, a = Aa, l = gr, c = bt, u = new Uint8Array(te.slice(0, Er)), m = xe, p = xe.slice(0, xe.length), d = mt, f = zo, g = i();
  return Er = r, T = e, Ma = t, Nt = o, Wt = n, Dr = s, Aa = a, gr = l, bt = c, te = u, zo = f, xe = m, xe.splice(0, xe.length, ...p), mt = d, Te = new DataView(te.buffer, te.byteOffset, te.byteLength), g;
}
function us() {
  te = null, gr = null, xe = null;
}
function zp(i) {
  i.unpack ? it[i.type] = i.unpack : it[i.type] = i;
}
var ms = new Array(147);
for (let i = 0; i < 256; i++)
  ms[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
var ds = new qt({ useRecords: false });
var Sv = ds.unpack;
var wv = ds.unpackMultiple;
var Tv = ds.unpack;
var Nv = new Float32Array(1);
var cO = new Uint8Array(Nv.buffer, 0, 4);
var hs;
try {
  hs = new TextEncoder();
} catch {
}
var gs;
var Ra;
var ys = typeof Buffer < "u";
var Ga = ys ? Buffer.allocUnsafeSlow : Uint8Array;
var jp = ys ? Buffer : Uint8Array;
var Vp = ys ? 4294967296 : 2144337920;
var R;
var De;
var C = 0;
var $t;
var Xt = null;
var Cv = /[\u0080-\uFFFF]/;
var _n = Symbol("record-id");
var Qr = class extends qt {
  constructor(r) {
    super(r), this.offset = 0;
    let e, t, o, n, s, a, l = 0, c = jp.prototype.utf8Write ? function(h, _, N) {
      return R.utf8Write(h, _, N);
    } : hs && hs.encodeInto ? function(h, _) {
      return hs.encodeInto(h, R.subarray(_)).written;
    } : false, u = this;
    r || (r = {});
    let m = r && r.sequential, p = r.structures || r.saveStructures, d = r.maxSharedStructures;
    if (d == null && (d = p ? 32 : 0), d > 8160)
      throw new Error("Maximum maxSharedStructure is 8160");
    let f = r.maxOwnStructures;
    f == null && (f = p ? 32 : 64), m && !r.saveStructures && (this.structures = []);
    let g = d > 32 || f + d > 64, x = d + 64, y = d + f + 64;
    if (y > 8256)
      throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
    let v = [], P = 0, S = 0;
    this.pack = this.encode = function(h, _) {
      if (R || (R = new Ga(8192), De = new DataView(R.buffer, 0, 8192), C = 0), $t = R.length - 10, $t - C < 2048 ? (R = new Ga(R.length), De = new DataView(R.buffer, 0, R.length), $t = R.length - 10, C = 0) : C = C + 7 & 2147483640, t = C, a = u.structuredClone ? new Map() : null, u.bundleStrings ? (Xt = ["", ""], R[C++] = 214, R[C++] = 98, Xt.position = C - t, C += 4) : Xt = null, o = u.structures, o) {
        o.uninitialized && (o = u._mergeStructures(u.getStructures()));
        let N = o.sharedLength || 0;
        if (N > d)
          throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + o.sharedLength);
        if (!o.transitions) {
          o.transitions = Object.create(null);
          for (let I = 0; I < N; I++) {
            let L = o[I];
            if (!L)
              continue;
            let A, k = o.transitions;
            for (let q = 0, oe = L.length; q < oe; q++) {
              let ce = L[q];
              A = k[ce], A || (A = k[ce] = Object.create(null)), k = A;
            }
            k[_n] = I + 64;
          }
          l = N;
        }
        m || (o.nextId = N + 64);
      }
      n && (n = false), s = o || [];
      try {
        if (b(h), Xt) {
          De.setUint32(Xt.position + t, C - Xt.position - t);
          let N = Xt;
          Xt = null, b(N[0]), b(N[1]);
        }
        if (u.offset = C, a && a.idsToInsert) {
          C += a.idsToInsert.length * 6, C > $t && w(C), u.offset = C;
          let N = Iv(R.subarray(t, C), a.idsToInsert);
          return a = null, N;
        }
        return _ & Hp ? (R.start = t, R.end = C, R) : R.subarray(t, C);
      } finally {
        if (o) {
          if (S < 10 && S++, P > 1e4)
            o.transitions = null, S = 0, P = 0, v.length > 0 && (v = []);
          else if (v.length > 0 && !m) {
            for (let N = 0, I = v.length; N < I; N++)
              v[N][_n] = 0;
            v = [];
          }
          if (n && u.saveStructures) {
            let N = o.sharedLength || d;
            o.length > N && (o = o.slice(0, N));
            let I = R.subarray(t, C);
            return u.saveStructures(o, l) === false ? (u._mergeStructures(u.getStructures()), u.pack(h)) : (l = N, I);
          }
        }
        _ & Ev && (C = t);
      }
    };
    let b = (h) => {
      C > $t && (R = w(C));
      var _ = typeof h, N;
      if (_ === "string") {
        let I = h.length;
        if (Xt && I >= 8 && I < 4096) {
          let k = Cv.test(h);
          Xt[k ? 0 : 1] += h, R[C++] = 193, b(k ? -I : I);
          return;
        }
        let L;
        I < 32 ? L = 1 : I < 256 ? L = 2 : I < 65536 ? L = 3 : L = 5;
        let A = I * 3;
        if (C + A > $t && (R = w(C + A)), I < 64 || !c) {
          let k, q, oe, ce = C + L;
          for (k = 0; k < I; k++)
            q = h.charCodeAt(k), q < 128 ? R[ce++] = q : q < 2048 ? (R[ce++] = q >> 6 | 192, R[ce++] = q & 63 | 128) : (q & 64512) === 55296 && ((oe = h.charCodeAt(k + 1)) & 64512) === 56320 ? (q = 65536 + ((q & 1023) << 10) + (oe & 1023), k++, R[ce++] = q >> 18 | 240, R[ce++] = q >> 12 & 63 | 128, R[ce++] = q >> 6 & 63 | 128, R[ce++] = q & 63 | 128) : (R[ce++] = q >> 12 | 224, R[ce++] = q >> 6 & 63 | 128, R[ce++] = q & 63 | 128);
          N = ce - C - L;
        } else
          N = c(h, C + L, A);
        N < 32 ? R[C++] = 160 | N : N < 256 ? (L < 2 && R.copyWithin(C + 2, C + 1, C + 1 + N), R[C++] = 217, R[C++] = N) : N < 65536 ? (L < 3 && R.copyWithin(C + 3, C + 2, C + 2 + N), R[C++] = 218, R[C++] = N >> 8, R[C++] = N & 255) : (L < 5 && R.copyWithin(C + 5, C + 3, C + 3 + N), R[C++] = 219, De.setUint32(C, N), C += 4), C += N;
      } else if (_ === "number")
        if (h >>> 0 === h)
          h < 64 ? R[C++] = h : h < 256 ? (R[C++] = 204, R[C++] = h) : h < 65536 ? (R[C++] = 205, R[C++] = h >> 8, R[C++] = h & 255) : (R[C++] = 206, De.setUint32(C, h), C += 4);
        else if (h >> 0 === h)
          h >= -32 ? R[C++] = 256 + h : h >= -128 ? (R[C++] = 208, R[C++] = h + 256) : h >= -32768 ? (R[C++] = 209, De.setInt16(C, h), C += 2) : (R[C++] = 210, De.setInt32(C, h), C += 4);
        else {
          let I;
          if ((I = this.useFloat32) > 0 && h < 4294967296 && h >= -2147483648) {
            R[C++] = 202, De.setFloat32(C, h);
            let L;
            if (I < 4 || (L = h * ms[(R[C] & 127) << 1 | R[C + 1] >> 7]) >> 0 === L) {
              C += 4;
              return;
            } else
              C--;
          }
          R[C++] = 203, De.setFloat64(C, h), C += 8;
        }
      else if (_ === "object")
        if (!h)
          R[C++] = 192;
        else {
          if (a) {
            let L = a.get(h);
            if (L) {
              if (!L.id) {
                let A = a.idsToInsert || (a.idsToInsert = []);
                L.id = A.push(L);
              }
              R[C++] = 214, R[C++] = 112, De.setUint32(C, L.id), C += 4;
              return;
            } else
              a.set(h, { offset: C - t });
          }
          let I = h.constructor;
          if (I === Object)
            E(h, true);
          else if (I === Array) {
            N = h.length, N < 16 ? R[C++] = 144 | N : N < 65536 ? (R[C++] = 220, R[C++] = N >> 8, R[C++] = N & 255) : (R[C++] = 221, De.setUint32(C, N), C += 4);
            for (let L = 0; L < N; L++)
              b(h[L]);
          } else if (I === Map) {
            N = h.size, N < 16 ? R[C++] = 128 | N : N < 65536 ? (R[C++] = 222, R[C++] = N >> 8, R[C++] = N & 255) : (R[C++] = 223, De.setUint32(C, N), C += 4);
            for (let [L, A] of h)
              b(L), b(A);
          } else {
            for (let L = 0, A = gs.length; L < A; L++) {
              let k = Ra[L];
              if (h instanceof k) {
                let q = gs[L];
                if (q.write) {
                  q.type && (R[C++] = 212, R[C++] = q.type, R[C++] = 0), b(q.write.call(this, h));
                  return;
                }
                let oe = R, ce = De, ie = C;
                R = null;
                let K;
                try {
                  K = q.pack.call(this, h, (U) => (R = oe, oe = null, C += U, C > $t && w(C), { target: R, targetView: De, position: C - U }), b);
                } finally {
                  oe && (R = oe, De = ce, C = ie, $t = R.length - 10);
                }
                K && (K.length + C > $t && w(K.length + C), C = Lv(K, R, C, q.type));
                return;
              }
            }
            E(h, !h.hasOwnProperty);
          }
        }
      else if (_ === "boolean")
        R[C++] = h ? 195 : 194;
      else if (_ === "bigint") {
        if (h < BigInt(1) << BigInt(63) && h >= -(BigInt(1) << BigInt(63)))
          R[C++] = 211, De.setBigInt64(C, h);
        else if (h < BigInt(1) << BigInt(64) && h > 0)
          R[C++] = 207, De.setBigUint64(C, h);
        else if (this.largeBigIntToFloat)
          R[C++] = 203, De.setFloat64(C, Number(h));
        else
          throw new RangeError(h + " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");
        C += 8;
      } else if (_ === "undefined")
        this.encodeUndefinedAsNil ? R[C++] = 192 : (R[C++] = 212, R[C++] = 0, R[C++] = 0);
      else if (_ === "function")
        b(this.writeFunction && this.writeFunction());
      else
        throw new Error("Unknown type: " + _);
    }, E = this.useRecords === false ? this.variableMapSize ? (h) => {
      let _ = Object.keys(h), N = _.length;
      N < 16 ? R[C++] = 128 | N : N < 65536 ? (R[C++] = 222, R[C++] = N >> 8, R[C++] = N & 255) : (R[C++] = 223, De.setUint32(C, N), C += 4);
      let I;
      for (let L = 0; L < N; L++)
        b(I = _[L]), b(h[I]);
    } : (h, _) => {
      R[C++] = 222;
      let N = C - t;
      C += 2;
      let I = 0;
      for (let L in h)
        (_ || h.hasOwnProperty(L)) && (b(L), b(h[L]), I++);
      R[N++ + t] = I >> 8, R[N + t] = I & 255;
    } : (h) => {
      let _ = Object.keys(h), N, I = s.transitions || (s.transitions = Object.create(null)), L = 0;
      for (let k = 0, q = _.length; k < q; k++) {
        let oe = _[k];
        N = I[oe], N || (N = I[oe] = Object.create(null), L++), I = N;
      }
      let A = I[_n];
      if (A)
        A >= 96 && g ? (R[C++] = ((A -= 96) & 31) + 96, R[C++] = A >> 5) : R[C++] = A;
      else {
        A = s.nextId, A || (A = 64), A < x && this.shouldShareStructure && !this.shouldShareStructure(_) ? (A = s.nextOwnId, A < y || (A = x), s.nextOwnId = A + 1) : (A >= y && (A = x), s.nextId = A + 1);
        let k = _.highByte = A >= 96 && g ? A - 96 >> 5 : -1;
        I[_n] = A, s[A - 64] = _, A < x ? (_.isShared = true, s.sharedLength = A - 63, n = true, k >= 0 ? (R[C++] = (A & 31) + 96, R[C++] = k) : R[C++] = A) : (k >= 0 ? (R[C++] = 213, R[C++] = 114, R[C++] = (A & 31) + 96, R[C++] = k) : (R[C++] = 212, R[C++] = 114, R[C++] = A), L && (P += S * L), v.length >= f && (v.shift()[_n] = 0), v.push(I), b(_));
      }
      for (let k = 0, q = _.length; k < q; k++)
        b(h[_[k]]);
    }, w = (h) => {
      let _;
      if (h > 16777216) {
        if (h - t > Vp)
          throw new Error("Packed buffer would be larger than maximum buffer size");
        _ = Math.min(Vp, Math.round(Math.max((h - t) * (h > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
      } else
        _ = (Math.max(h - t << 2, R.length - 1) >> 12) + 1 << 12;
      let N = new Ga(_);
      return De = new DataView(N.buffer, 0, _), R.copy ? R.copy(N, 0, t, h) : N.set(R.slice(t, h)), C -= t, t = 0, $t = N.length - 10, R = N;
    };
  }
  useBuffer(r) {
    R = r, De = new DataView(R.buffer, R.byteOffset, R.byteLength), C = 0;
  }
};
Ra = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, On];
gs = [{ pack(i, r, e) {
  let t = i.getTime() / 1e3;
  if ((this.useTimestamp32 || i.getMilliseconds() === 0) && t >= 0 && t < 4294967296) {
    let { target: o, targetView: n, position: s } = r(6);
    o[s++] = 214, o[s++] = 255, n.setUint32(s, t);
  } else if (t > 0 && t < 17179869184) {
    let { target: o, targetView: n, position: s } = r(10);
    o[s++] = 215, o[s++] = 255, n.setUint32(s, i.getMilliseconds() * 4e6 + (t / 1e3 / 4294967296 >> 0)), n.setUint32(s + 4, t);
  } else if (isNaN(t)) {
    if (this.onInvalidDate)
      return r(0), e(this.onInvalidDate());
    let { target: o, targetView: n, position: s } = r(3);
    o[s++] = 212, o[s++] = 255, o[s++] = 255;
  } else {
    let { target: o, targetView: n, position: s } = r(15);
    o[s++] = 199, o[s++] = 12, o[s++] = 255, n.setUint32(s, i.getMilliseconds() * 1e6), n.setBigInt64(s + 4, BigInt(Math.floor(t)));
  }
} }, { pack(i, r, e) {
  let t = Array.from(i), { target: o, position: n } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (o[n++] = 212, o[n++] = 115, o[n++] = 0), e(t);
} }, { pack(i, r, e) {
  let { target: t, position: o } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (t[o++] = 212, t[o++] = 101, t[o++] = 0), e([i.name, i.message]);
} }, { pack(i, r, e) {
  let { target: t, position: o } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (t[o++] = 212, t[o++] = 120, t[o++] = 0), e([i.source, i.flags]);
} }, { pack(i, r) {
  this.structuredClone ? Fp(i, 16, r) : Up(ys ? Buffer.from(i) : new Uint8Array(i), r);
} }, { pack(i, r) {
  let e = i.constructor;
  e !== jp && this.structuredClone ? Fp(i, Ba.indexOf(e.name), r) : Up(i, r);
} }, { pack(i, r) {
  let { target: e, position: t } = r(1);
  e[t] = 193;
} }];
function Fp(i, r, e, t) {
  let o = i.byteLength;
  if (o + 1 < 256) {
    var { target: n, position: s } = e(4 + o);
    n[s++] = 199, n[s++] = o + 1;
  } else if (o + 1 < 65536) {
    var { target: n, position: s } = e(5 + o);
    n[s++] = 200, n[s++] = o + 1 >> 8, n[s++] = o + 1 & 255;
  } else {
    var { target: n, position: s, targetView: a } = e(7 + o);
    n[s++] = 201, a.setUint32(s, o + 1), s += 4;
  }
  n[s++] = 116, n[s++] = r, n.set(new Uint8Array(i.buffer, i.byteOffset, i.byteLength), s);
}
function Up(i, r) {
  let e = i.byteLength;
  var t, o;
  if (e < 256) {
    var { target: t, position: o } = r(e + 2);
    t[o++] = 196, t[o++] = e;
  } else if (e < 65536) {
    var { target: t, position: o } = r(e + 3);
    t[o++] = 197, t[o++] = e >> 8, t[o++] = e & 255;
  } else {
    var { target: t, position: o, targetView: n } = r(e + 5);
    t[o++] = 198, n.setUint32(o, e), o += 4;
  }
  t.set(i, o);
}
function Lv(i, r, e, t) {
  let o = i.length;
  switch (o) {
    case 1:
      r[e++] = 212;
      break;
    case 2:
      r[e++] = 213;
      break;
    case 4:
      r[e++] = 214;
      break;
    case 8:
      r[e++] = 215;
      break;
    case 16:
      r[e++] = 216;
      break;
    default:
      o < 256 ? (r[e++] = 199, r[e++] = o) : o < 65536 ? (r[e++] = 200, r[e++] = o >> 8, r[e++] = o & 255) : (r[e++] = 201, r[e++] = o >> 24, r[e++] = o >> 16 & 255, r[e++] = o >> 8 & 255, r[e++] = o & 255);
  }
  return r[e++] = t, r.set(i, e), e += o, e;
}
function Iv(i, r) {
  let e, t = r.length * 6, o = i.length - t;
  for (r.sort((n, s) => n.offset > s.offset ? 1 : -1); e = r.pop(); ) {
    let n = e.offset, s = e.id;
    i.copyWithin(n + t, n, o), t -= 6;
    let a = n + t;
    i[a++] = 214, i[a++] = 105, i[a++] = s >> 24, i[a++] = s >> 16 & 255, i[a++] = s >> 8 & 255, i[a++] = s & 255, o = n;
  }
  return i;
}
function Jr(i) {
  if (i.Class) {
    if (!i.pack && !i.write)
      throw new Error("Extension has no pack or write function");
    if (i.pack && !i.type)
      throw new Error("Extension has no type (numeric code to identify the extension)");
    Ra.unshift(i.Class), gs.unshift(i);
  }
  zp(i);
}
var kp = new Qr({ useRecords: false });
var Pv = kp.pack;
var Av = kp.pack;
var Hp = 512;
var Ev = 1024;
var Wp = new Qr({ structuredClone: true });
Jr({ Class: Ve.prototype.constructor, type: 1, write(i) {
  return __spreadValues({}, i);
}, read(i) {
  return Object.setPrototypeOf(i, Ve.prototype), i;
} });
Jr({ Class: Ae.prototype.constructor, type: 2, write(i) {
  return [...i];
}, read(i) {
  return Object.setPrototypeOf(i, Ae.prototype), i;
} });
Jr({ Class: Tt.prototype.constructor, type: 3, write(i) {
  return [...i];
}, read(i) {
  return Object.setPrototypeOf(i, Tt.prototype), i;
} });
Jr({ Class: An.prototype.constructor, type: 4, write(i) {
  return i.id;
}, read(i) {
  return new An(i);
} });
Jr({ Class: Mn.prototype.constructor, type: 5, write(i) {
  return i.data;
}, read(i) {
  return new Mn(i);
} });
function Bv(i) {
  var r = 0;
  if (i.length === 0)
    return r;
  for (let e = 0; e < i.length; e++) {
    let t = i[e];
    r = (r << 5) - r + t, r = r & r;
  }
  return r;
}
function za(i) {
  if (rs(i))
    return i;
  if (Array.isArray(i))
    return i.map(za);
  if (typeof i == "object" && i !== null) {
    let r = {};
    for (let e of Object.keys(i).sort())
      r[e] = za(i[e]);
    return Object.setPrototypeOf(r, Object.getPrototypeOf(i)), r;
  } else
    return i;
}
var xs;
((t) => {
  function i(o) {
    return Wp.pack(o);
  }
  t.serialize = i;
  function r(o) {
    return Wp.unpack(o);
  }
  t.deserialize = r;
  function e(o) {
    return Bv(i(za(o))).toString();
  }
  t.checksum = e;
})(xs || (xs = {}));
var vs;
((e) => {
  e.all = ["PointLight", "SpotLight", "DirectionalLight", "HemisphereLight"];
  function r(t) {
    return e.all.includes(t);
  }
  e.is = r;
})(vs || (vs = {}));
var bs;
((e) => {
  function i(t) {
    return r(t);
  }
  e.defaultData = i;
  function r(t) {
    if (t === "PointLight")
      return { type: t, color: vt.white, intensity: 1, distance: 2e3, decay: 1, shadows: true, shadowResolution: 1024, shadowRadius: 1, depth: 1e5, helper: true };
    if (t === "SpotLight")
      return { type: t, color: vt.white, intensity: 1, distance: 2e3, decay: 1, shadows: true, penumbra: 0, angle: 30 / 180 * Math.PI, depth: 1e5, helper: true, shadowResolution: 1024, shadowRadius: 1 };
    if (t === "DirectionalLight")
      return { type: t, color: vt.white, intensity: 1, shadows: true, size: 1e3, depth: 1e5, shadowResolution: 1024, helper: true, shadowRadius: 1 };
    throw new Error("not implemented");
  }
})(bs || (bs = {}));
var Va;
((e) => {
  e.defaultData = { castShadow: true, receiveShadow: true };
  function r(t, o) {
    return t.castShadow === o.castShadow && t.receiveShadow === o.receiveShadow;
  }
  e.equals = r;
})(Va || (Va = {}));
var Fa;
((e) => {
  e.defaultData = { flatShading: false, wireframe: false, side: 0 };
  function r(t, o) {
    return t.flatShading === o.flatShading && t.side === o.side && t.wireframe === o.wireframe;
  }
  e.equals = r;
})(Fa || (Fa = {}));
var Ss;
((r) => r.defaultData = __spreadProps(__spreadValues(__spreadValues({}, Fa.defaultData), Va.defaultData), { cloner: null, booleanExclude: null }))(Ss || (Ss = {}));
var Ua = ((o) => (o[o.Left = 1] = "Left", o[o.Right = 2] = "Right", o[o.Center = 3] = "Center", o[o.Justify = 4] = "Justify", o))(Ua || {});
var ja = ((t) => (t[t.Top = 1] = "Top", t[t.Center = 2] = "Center", t[t.Bottom = 3] = "Bottom", t))(ja || {});
var ka = ((t) => (t[t.None = 1] = "None", t[t.Upper = 2] = "Upper", t[t.Lower = 3] = "Lower", t))(ka || {});
var ws;
((r) => r.defaultData = { width: 100, height: 100, horizontalAlign: 1, verticalAlign: 1, fontSize: 16, lineHeight: 1.5, letterSpacing: 1, text: "", textTransform: 1, color: vt.fromHexAndA(6974058, 1), alpha: 1, font: "roboto_regular" })(ws || (ws = {}));
var Br;
((t) => {
  function i(o, n) {
    return o === "light" && n ? r(n) : e(o);
  }
  t.defaultData = i;
  function r(o) {
    switch (o) {
      case "basic":
        return { type: "light", category: "basic", alpha: 1, visible: true, mode: 0 };
      case "phong":
        return { category: "phong", specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 10, type: "light", alpha: 1, visible: true, mode: 0 };
      case "toon":
        return { category: "toon", specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 10, type: "light", alpha: 1, visible: true, mode: 0 };
      case "lambert":
        return { category: "lambert", emissive: { r: 0, g: 0, b: 0, a: 1 }, type: "light", alpha: 1, visible: true, mode: 0 };
      case "physical":
        return { category: "physical", roughness: 0.2, metalness: 0.2, reflectivity: 0.2, type: "light", alpha: 1, visible: true, mode: 0 };
    }
  }
  function e(o) {
    switch (o) {
      case "texture":
        return { alpha: 1, visible: true, size: [128, 128], mode: 0, axis: "x", side: 2, type: "texture", projection: 0, texture: { image: "image_0", wrapping: 1001, repeat: [1, 1], offset: [0, 0] }, crop: true };
      case "color":
        return { type: "color", alpha: 1, visible: true, mode: 0, color: xt.fromHex(4737101) };
      case "depth":
        return { type: "depth", alpha: 1, visible: true, mode: 0, gradientType: 1, smooth: false, isVector: true, isWorldSpace: false, origin: [0, 0, 0], direction: [1, 0, 0], colors: [[1, 1, 1, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]], steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], num: 2, near: 50, far: 200 };
      case "normal":
        return { type: "normal", alpha: 1, visible: true, mode: 0, cnormal: [1, 1, 1] };
      case "gradient":
        return { type: "gradient", alpha: 1, visible: true, mode: 0, gradientType: 0, smooth: false, colors: [[0, 0, 0, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1], num: 2, angle: 0, offset: [0, 0], morph: [0, 0] };
      case "noise":
        return { type: "noise", alpha: 1, visible: true, mode: 0, size: [100, 100, 100], noiseType: 0, scale: 1, move: 1, colorA: __spreadProps(__spreadValues({}, xt.fromHex(6710886)), { a: 1 }), colorB: __spreadProps(__spreadValues({}, xt.fromHex(6710886)), { a: 1 }), colorC: __spreadProps(__spreadValues({}, xt.fromHex(16777215)), { a: 1 }), colorD: __spreadProps(__spreadValues({}, xt.fromHex(16777215)), { a: 1 }), distortion: [1, 1], fA: [1.7, 9.2], fB: [8.3, 2.8] };
      case "fresnel":
        return { type: "fresnel", alpha: 1, visible: true, mode: 0, color: vt.fromHexAndA(16777215, 1), bias: 0.1, scale: 1, intensity: 2, factor: 1 };
      case "rainbow":
        return { type: "rainbow", alpha: 1, visible: true, mode: 0, filmThickness: 30, movement: 0, wavelengths: [0, 0, 0], noiseStrength: 0, noiseScale: 1, offset: [0, 0, 0] };
      case "toon":
        return { type: "toon", alpha: 1, visible: true, mode: 0, positioning: 2, colors: [[0, 0, 0, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, 0.475, 0.525, 1, 1, 1, 1, 1, 1, 1], num: 4, source: [0, 1e3, 0], isWorldSpace: true, noiseStrength: 0, noiseScale: 1, shadowColor: vt.fromHexAndA(0, 0), offset: [0, 0, 0] };
      case "outline":
        return { type: "outline", alpha: 1, visible: true, mode: 0, outlineColor: vt.fromHexAndA(0, 1), contourColor: vt.fromHexAndA(0, 1), outlineWidth: 2, contourWidth: 5, outlineThreshold: 0.4, contourThreshold: 0, outlineSmoothing: 0, contourFrequency: 10, contourDirection: [0, 1, 0], positionalLines: false, compensation: true };
      case "matcap":
        return { type: "matcap", alpha: 1, visible: true, mode: 0, texture: { image: "matcap_0", wrapping: 1001, repeat: [1, 1], offset: [0, 0] } };
      case "transmission":
        return { type: "transmission", alpha: 1, visible: true, mode: 0, thickness: 10, ior: 1.5, roughness: 1 };
      case "displace":
        return { type: "displace", displacementType: "noise", noiseType: 0, scale: 10, movement: 1, offset: [0, 0, 0], intensity: 8, visible: true };
    }
  }
})(Br || (Br = {}));
var yr;
((a) => {
  function i(l) {
    return !l.layers.some((u) => {
      if (u.data.type === "texture" && u.data.projection !== 0 || u.data.type === "depth" && !u.data.isWorldSpace || u.data.type === "noise" || u.data.type === "displace")
        return true;
    }) && !e(l);
  }
  a.isMergable = i;
  function r(l) {
    let c = "";
    return l.layers.forEach((u) => {
      Object.entries(u.data).forEach(([m, p]) => {
        c += `${m}${p}`, Array.isArray(p) ? p.forEach((d) => c += `${d}`) : typeof p == "object" ? Object.values(p).forEach((d) => {
          typeof d == "number" ? c += `${d.toFixed(4)}` : c += `${d}`;
        }) : c += `${p}`;
      });
    }), c;
  }
  a.getHash = r;
  function e(l) {
    let c = 0;
    for (let u of l.layers)
      "alpha" in u.data && u.data.type !== "light" && u.data.type !== "fresnel" && (c += (1 - c) * u.data.alpha);
    return c < 1;
  }
  a.isTransparent = e;
  function t() {
    return { layers: new Ae() };
  }
  a.defaultEmptyData = t;
  function o(l = "layer1", c = "layer2") {
    return n("phong", l, c);
  }
  a.defaultData = o;
  function n(l, c = "layer1", u = "layer2") {
    let m = new Ae();
    return m.push({ fi: 0, data: Br.defaultData("light", l), id: c }), m.push({ fi: 1, data: Br.defaultData("color"), id: u }), { layers: m };
  }
  a.defaultTwoLayerData = n;
  function s(l, c = "basic", u = "layer1", m = "layer2") {
    let p = Br.defaultData("texture");
    Object.assign(p.texture, { image: l });
    let d = new Ae();
    return d.push({ fi: 0, data: p, id: u }), d.push({ fi: 1, data: Br.defaultData("light", c), id: m }), { layers: d };
  }
  a.defaultTwoLayerTextureData = s;
})(yr || (yr = {}));
var Vo;
((r) => {
  function i() {
    return { points: new Ae(), roundness: 0, shapeHoles: [], isClosed: false };
  }
  r.defaultData = i;
})(Vo || (Vo = {}));
var Ts;
((r) => {
  function i(e) {
    return e === "PolygonGeometry" || e === "RectangleGeometry" || e === "StarGeometry" || e === "TriangleGeometry" || e === "EllipseGeometry";
  }
  r.is2DParametricMesh = i;
})(Ts || (Ts = {}));
var Dn;
((r) => {
  function i(e) {
    if (e === "RectangleGeometry")
      return { width: 320, height: 320, type: e, cornerRadius: [0, 0, 0, 0], cornerType: 0, depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    if (e === "VectorGeometry")
      return { width: 1, height: 1, type: e, subdivisions: 12, shape: Vo.defaultData(), depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    if (e === "BooleanGeometry")
      return { type: e, operation: 2, width: 0, height: 0, depth: 0, phongAngle: 35 };
    throw new Error("not implemented");
  }
  r.defaultData = i;
})(Dn || (Dn = {}));
var En;
((o) => {
  o.identity = __spreadProps(__spreadValues({}, Zi.identity), { hiddenMatrix: _r.identity });
  function r(n) {
    return { position: n.position, rotation: n.rotation, scale: n.scale, hiddenMatrix: n.hiddenMatrix };
  }
  o.fromObject = r;
  function e(n, s) {
    return { position: (s == null ? void 0 : s.position) || n.position, rotation: (s == null ? void 0 : s.rotation) || n.rotation, scale: (s == null ? void 0 : s.scale) || n.scale, hiddenMatrix: (s == null ? void 0 : s.hiddenMatrix) || n.hiddenMatrix };
  }
  o.merge = e;
  function t(n, s) {
    return { position: Eo.isEqual(n.position, s.position) ? null : s.position, rotation: Eo.isEqual(n.rotation, s.rotation) ? null : s.rotation, scale: Eo.isEqual(n.scale, s.scale) ? null : s.scale, hiddenMatrix: _r.isEqual(n.hiddenMatrix, s.hiddenMatrix) ? null : s.hiddenMatrix };
  }
  o.diff = t;
})(En || (En = {}));
var xr;
((r) => r.defaultData = __spreadValues({ states: new Ae(), events: new Ae(), visible: true, raycastLock: false }, En.identity))(xr || (xr = {}));
var qp;
((r) => r.defaultData = __spreadValues({ type: "Empty" }, xr.defaultData))(qp || (qp = {}));
var Ns;
((r) => r.defaultData = __spreadValues(__spreadValues({ type: "Mesh" }, xr.defaultData), Ss.defaultData))(Ns || (Ns = {}));
var $p;
((r) => r.defaultData = __spreadValues(__spreadValues({ type: "TextFrame" }, xr.defaultData), ws.defaultData))($p || ($p = {}));
var Cs;
((r) => r.defaultData = __spreadValues(__spreadValues(__spreadValues({}, xr.defaultData), En.identity), Yr.defaultData))(Cs || (Cs = {}));
var Xp;
((r) => {
  function i(e) {
    return __spreadValues(__spreadValues({}, xr.defaultData), bs.defaultData(e));
  }
  r.defaultData = i;
})(Xp || (Xp = {}));
var Yp;
((t) => (t.defaultCamera = __spreadValues({ position: [0, 0, 1e3], scale: [1, 1, 1], rotation: [0, 0, 0], hiddenMatrix: _r.identity, name: "Play Camera", visible: true, raycastLock: false, states: new Ae(), events: new Ae() }, Yr.defaultData), t.defaultMeshObject = __spreadProps(__spreadValues(__spreadValues({ name: "Rectangle" }, xr.defaultData), Ns.defaultData), { geometry: Dn.defaultData("RectangleGeometry"), material: yr.defaultTwoLayerData("basic", "layer1", "layer2") }), t.defaultBooleanObject = __spreadProps(__spreadValues(__spreadValues({ name: "Boolean" }, xr.defaultData), Ns.defaultData), { geometry: Dn.defaultData("BooleanGeometry"), material: yr.defaultTwoLayerData("phong", "layer1", "layer2") })))(Yp || (Yp = {}));
var Kp;
((e) => {
  function i(t, o) {
    if (o === void 0)
      return t;
    let n = __spreadValues({}, t);
    return "material" in n && "material" in o && o.material && (n.material = Ca(n.material, (s) => {
      if (typeof s != "string")
        for (let [a, l] of Object.entries(o.material.layers)) {
          let c = s.layers.data(a);
          c && Xr(c, l);
        }
    }).data), n.materials && o.materials && (n.materials = Ca(n.materials, (s) => {
      var _a2, _b2;
      for (let a = 0; a < n.materials.length; a++) {
        let l = o.materials[a];
        if (typeof l != "string")
          for (let [c, u] of Object.entries(l.layers)) {
            let m = (_b2 = (_a2 = s[a]) == null ? void 0 : _a2.layers) == null ? void 0 : _b2.data(c);
            m && Xr(m, u);
          }
      }
    }).data), n;
  }
  e.patchMaterialState = i;
  function r(t, o) {
    var _a2, _b2;
    if (o === void 0)
      return t;
    let n = __spreadValues({}, t);
    if (Object.assign(n, En.merge(n, o)), Do.is(t.type)) {
      n.orthographic = __spreadValues({}, n.orthographic), n.perspective = __spreadValues({}, n.perspective);
      let s = o;
      ((_a2 = s.orthographic) == null ? void 0 : _a2.zoom) !== void 0 && (n.orthographic.zoom = s.orthographic.zoom), ((_b2 = s.perspective) == null ? void 0 : _b2.zoom) !== void 0 && (n.perspective.zoom = s.perspective.zoom), s.isUpVectorFlipped !== void 0 && (n.isUpVectorFlipped = s.isUpVectorFlipped), s.targetOffset !== void 0 && (n.targetOffset = s.targetOffset);
    } else if (t.type === "Mesh")
      n.geometry = __spreadValues({}, n.geometry), Object.assign(n.geometry, o.geometry), n = i(n, o);
    else if (vs.is(t.type)) {
      let s = o;
      s.intensity !== void 0 && (n.intensity = s.intensity), s.color !== void 0 && (typeof s.color == "string" ? n.color = s.color : n.color = xt.clone(s.color));
    }
    return n;
  }
  e.patch = r;
})(Kp || (Kp = {}));
var Ls;
((s) => {
  let i = ["/_assets/_textures/texture_checkboard_default.png", "/_assets/_textures/texture_dots_01.png", "/_assets/_textures/texture_wood_01.jpg", "/_assets/_textures/texture_wood_02.jpg", "/_assets/_textures/texture_rock_01.jpg", "/_assets/_textures/texture_rock_02.jpg", "/_assets/_textures/texture_grass_01.jpg", "/_assets/_textures/texture_grass_02.jpg", "/_assets/_textures/texture_concrete_01.jpg", "/_assets/_textures/texture_concrete_02.jpg", "/_assets/_textures/texture_paper_01.jpg", "/_assets/_textures/texture_roof_01.jpg", "/_assets/_textures/texture_wall_02.jpg", "/_assets/_textures/texture_planet_earth_color.jpg", "/_assets/_textures/texture_planet_earth_clouds.jpg", "/_assets/_textures/texture_planet_mars.jpg", "/_assets/_textures/texture_space.jpg"], r = ["/_assets/_textures/matcap_5_18.png", "/_assets/_textures/matcap_5_1.png", "/_assets/_textures/matcap_4_3.png", "/_assets/_textures/matcap_2_7.png", "/_assets/_textures/matcap_2_4.png", "/_assets/_textures/matcap_1_11.png"];
  function e() {
    let a = {}, l = 0;
    for (let c of i)
      a[`image_${l}`] = { data: c, name: `Image ${l}`, asset: false }, l++;
    l = 0;
    for (let c of r)
      a[`matcap_${l}`] = { data: c, name: `Matcap ${l}`, asset: false }, l++;
    return a;
  }
  s.defaultImages = e;
  function t() {
    let a = {};
    return a["89b10010-844c-11ec-a8a3-0242ac120002"] = { r: 0.5, g: 0.5, b: 0.5, a: 1, name: "Default Color" }, a;
  }
  s.defaultColors = t;
  function o() {
    return { materials: new Ve(), images: new Ve(), colors: new Ve(), penumbraSize: [0.5, 0.5, 0.5] };
  }
  s.emptyData = o;
  function n() {
    return { materials: new Ve(), images: ha(e(), Ve.prototype), colors: ha(t(), Ve.prototype), penumbraSize: new Array(5).fill(0.5) };
  }
  s.defaultData = n;
})(Ls || (Ls = {}));
var Is;
((r) => r.emptyImage = { data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=", asset: false })(Is || (Is = {}));
var Qe = class extends Color {
  constructor(e, t, o, n) {
    super(e, t, o);
    this.isColorA = true;
    this.a = n;
  }
  setRGBA(e, t, o, n) {
    super.setRGB(e, t, o), this.a = n;
  }
  copy(e) {
    return super.copy(e), this.a = "a" in e ? e.a : 1, this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
  get x() {
    return this.r;
  }
  get y() {
    return this.g;
  }
  get z() {
    return this.b;
  }
  get w() {
    return this.a;
  }
  set x(e) {
    this.r = e;
  }
  set y(e) {
    this.g = e;
  }
  set z(e) {
    this.b = e;
  }
  set w(e) {
    this.a = e;
  }
};
var Jp = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2, _d2, _e;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, radialSegments: 64, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: 360, cornerRadius: 0, cornerSegments: 8, hollow: 0 }, i.parameters), t = e.width / 2, o = (_b2 = e.radiusTop) != null ? _b2 : t, n = (_c2 = e.radiusBottom) != null ? _c2 : t;
    return o === n ? (o = t, n = t) : o > n ? (o = t, n = n * t / o) : (o = o * t / n, n = t), { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_d2 = e.height) != null ? _d2 : e.width), depth: Math.abs((_e = e.depth) != null ? _e : e.width), radiusTop: o, radiusBottom: n }) };
  }
  static build(i) {
    let { width: r, depth: e, height: t, radialSegments: o, heightSegments: n, openEnded: s, thetaStart: a, thetaLength: l, radiusTop: c, radiusBottom: u, cornerRadius: m, cornerSegments: p, hollow: d } = i.parameters, f;
    return m || d ? f = new Bn(c, u, t, o, n, s, a, l * Math.PI / 180, m, m, p, d) : f = new CylinderGeometry(c, u, t, o, n, s, a, l * Math.PI / 180), f.scale(1, 1, e / r), Object.assign(f, { userData: __spreadProps(__spreadValues({}, i), { type: "CylinderGeometry" }) });
  }
};
function Gr(i, r, e) {
  e.x = i.x * r.x, e.y = i.y, e.z = i.x * r.y;
}
function Qp(i) {
  return new Vector2(i.y, -i.x);
}
var Bn = class extends BufferGeometry {
  constructor(r, e, t, o, n, s, a, l, c, u, m, p, d = false) {
    super(), this.type = "RoundedCylinderBufferGeometry", r = r !== void 0 ? r : 1, e = e !== void 0 ? e : 1, t = t || 1, o = Math.floor(o) || 8, n = Math.floor(n) || 1, s = s !== void 0 ? s : false, a = a !== void 0 ? a : 0, l = l !== void 0 ? l : Math.PI * 2, s && (c = 0, u = 0);
    let f = [], g = [], x = [], y = [], v = 0, P = t / 2, S = new Vector3(), b = new Vector3();
    d && r == 0 && (r = c), d && e == 0 && (e = u);
    let E = new Vector2(r, P), w = new Vector2(e, -P), h = null, _ = null, N = null, I = null, L = E.clone().sub(w), A = 0, k = 0, q = 0;
    p > 0 && (A = Math.min(r, e) * (1 - p), k = r - A, q = e - A);
    let oe = E.clone();
    oe.x -= A;
    let ce = Math.PI - L.angle(), ie = L.angle(), K = Math.tan(ie / 2), U = Math.tan(ce / 2), z = K + U, B = p ? z : U, D = p ? z : K;
    if (c = Math.min(c, (r - k) / B, L.length() / z), u = Math.min(u, (e - q) / D, L.length() / z), c > 0) {
      let F = c / K;
      h = E.clone().sub(new Vector2(F, c)), p && (N = h.clone(), N.x -= A - z * c), E.sub(L.clone().setLength(F));
    }
    if (u > 0) {
      let F = u / U;
      _ = w.clone().sub(new Vector2(F, -u)), w.add(L.clone().setLength(F)), p && (I = _.clone(), I.x -= A - z * u, oe.sub(L.clone().setLength(F)));
    }
    L = E.clone().sub(w);
    let M = L.length() < 0.5, G = [];
    for (let F = 0; F <= o; F++) {
      let O = [], $ = F / o, Z = $ * l + a, ee = new Vector2(Math.sin(Z), Math.cos(Z));
      I && _ ? (Q(O, $, ee, ce, u, I, -1, true), Q(O, $, ee, ie, u, _, -1, false)) : _ ? (j(O, ee, _.x, 0, -1), Q(O, $, ee, ie, u, _, -1, false)) : s || j(O, ee, e, q, -1);
      let H = Qp(L).normalize();
      if (Gr(H, ee, S), !M)
        for (let J = 0; J <= n; J++) {
          let X = J / n, re = L.clone().multiplyScalar(X).add(w);
          Gr(re, ee, b), g.push(b.x, b.y, b.z), x.push(S.x, S.y, S.z), y.push($, 0.5 + b.y / t), O.push(v++);
        }
      if (N && h ? (Q(O, $, ee, ce, c, h, 1, false), Q(O, $, ee, ie, c, N, 1, true)) : h ? (Q(O, $, ee, ce, c, h, 1, false), j(O, ee, h.x, 0, 1)) : s || j(O, ee, r, k, 1), p && !M) {
        let J = Qp(L).multiplyScalar(-1).normalize();
        Gr(J, ee, S);
        for (let X = 0; X <= n; X++) {
          let re = X / n, le = L.clone().multiplyScalar(-re).add(oe);
          Gr(le, ee, b), g.push(b.x, b.y, b.z), x.push(S.x, S.y, S.z), y.push($, 0.5 + b.y / t), O.push(v++);
        }
      }
      p && !s && O.push(O[0]), G.push(O);
    }
    for (let F = 0; F < G.length - 1; F++)
      for (let O = 0; O < G[0].length - 1; O++) {
        if (s && p && O == n)
          continue;
        let $ = G[F][O], Z = G[F + 1][O], ee = G[F + 1][O + 1], H = G[F][O + 1], J = g[ee * 3 + 0], X = g[ee * 3 + 2];
        f.push($, Z, H), (J != 0 || X != 0) && f.push(Z, ee, H);
      }
    l < Math.PI * 2 && (V(-1, G[0], a), V(1, G[G.length - 1], a + l)), this.setIndex(f), this.setAttribute("position", new Float32BufferAttribute(g, 3)), this.setAttribute("normal", new Float32BufferAttribute(x, 3)), this.setAttribute("uv", new Float32BufferAttribute(y, 2));
    function Q(F, O, $, Z, ee, H, J, X) {
      for (let re = 0; re < m + 1; re++) {
        let le = re / m, ne = J < 0 ? le : 1 - le;
        X && (ne -= 1), ne *= Z;
        let de = new Vector2(Math.sin(ne), Math.cos(ne) * J), Me = de.clone().multiplyScalar(ee).add(H);
        Gr(Me, $, b), g.push(b.x, b.y, b.z), Gr(de, $, S), x.push(S.x, S.y, S.z), y.push(O, 0.5 + b.y / t), F.push(v++);
      }
    }
    function j(F, O, $, Z, ee) {
      let H = new Vector3(), J = new Vector2(), X = [$, Z];
      ee < 0 && X.reverse();
      for (let re of X)
        J.set(re, P * ee), Gr(J, O, H), g.push(H.x, H.y, H.z), x.push(0, ee, 0), y.push(0.5, 0.5), F.push(v++);
    }
    function V(F, O, $) {
      let Z = new Vector2(Math.sin($), Math.cos($)), ee = new Vector2(-Math.cos($), Math.sin($)), H = new Vector3(), J = F < 0 ? (le, ne, de) => f.push(le, ne, de) : (le, ne, de) => f.push(le, de, ne), X = new Vector2((r + e + k + q) / 4, 0);
      Gr(X, Z, H), g.push(H.x, H.y, H.z), x.push(ee.x, 0, ee.y), y.push(0.5, 0.5);
      let re = v++;
      for (let le of O) {
        let ne = g.slice(le * 3, le * 3 + 3);
        g.push(...ne), x.push(ee.x, 0, ee.y);
        let de = y.slice(le * 2, le * 2 + 2);
        y.push(...de), v++;
      }
      for (let le = re + 1; le < v - 1; le++)
        J(re, le, le + 1);
      J(re, v - 1, re + 1);
    }
  }
};
var Zp = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, radialSegments: 32, heightSegments: 8, openEnded: false, thetaStart: 0, thetaLength: 360, cornerRadiusTop: 0, cornerRadiusBottom: 0, cornerSegments: 8 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width) }) };
  }
  static build(i) {
    let { width: r, depth: e, height: t, radialSegments: o, heightSegments: n, openEnded: s, thetaStart: a, thetaLength: l, cornerRadiusTop: c, cornerRadiusBottom: u, cornerSegments: m } = i.parameters, p;
    return c > 0 || u > 0 || l < 360 ? p = new Bn(0, r / 2, t, o, n, s, a, l * Math.PI / 180, c, u, m, 0, true) : p = new ConeGeometry(r / 2, t, o, n, s), p.scale(1, 1, e / r), Object.assign(p, { userData: __spreadProps(__spreadValues({}, i), { type: "ConeGeometry" }) });
  }
};
var em = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, widthSegments: 1, heightSegments: 1, depthSegments: 1, cornerRadius: 0, cornerSegments: 8 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width) }) };
  }
  static build(i) {
    let { width: r, height: e, depth: t, widthSegments: o, heightSegments: n, depthSegments: s, cornerRadius: a, cornerSegments: l } = i.parameters, c;
    return a == 0 ? c = new BoxGeometry(r, e, t, o, n, s) : c = new $a(r, e, t, o, n, s, a, l), Object.assign(c, { userData: __spreadProps(__spreadValues({}, i), { type: "CubeGeometry" }) });
  }
};
var qa = Math.PI / 2;
var $a = class extends BufferGeometry {
  constructor(r = 1, e = 1, t = 1, o = 1, n = 1, s = 1, a = 0, l = 4) {
    super(), this.type = "BoxBufferGeometry";
    let c = this;
    o = Math.floor(o), n = Math.floor(n), s = Math.floor(s), l = Math.floor(l), a = Math.min(a, r / 2, e / 2, t / 2);
    let u = [], m = [], p = [], d = [], f = 0, g = 0;
    x("z", "y", "x", -1, -1, t, e, r, s, n, 0), x("z", "y", "x", 1, -1, t, e, -r, s, n, 1), x("x", "z", "y", 1, 1, r, t, e, o, s, 2), x("x", "z", "y", 1, -1, r, t, -e, o, s, 3), x("x", "y", "z", 1, -1, r, e, t, o, n, 4), x("x", "y", "z", -1, -1, r, e, -t, o, n, 5), a > 0 && (y("z", "y", "x", -1, -1, 1, t, e, r, s, 0), y("z", "y", "x", 1, -1, -1, t, e, r, s, 1), y("z", "y", "x", -1, 1, -1, t, e, r, s, 1), y("z", "y", "x", 1, 1, 1, t, e, r, s, 0), y("x", "y", "z", -1, -1, -1, r, e, t, o, 0), y("x", "y", "z", 1, -1, 1, r, e, t, o, 1), y("x", "y", "z", -1, 1, 1, r, e, t, o, 0), y("x", "y", "z", 1, 1, -1, r, e, t, o, 1), y("y", "x", "z", -1, -1, 1, e, r, t, n, 0), y("y", "x", "z", 1, -1, -1, e, r, t, n, 1), y("y", "x", "z", 1, 1, 1, e, r, t, n, 1), y("y", "x", "z", -1, 1, -1, e, r, t, n, 0), v(1, 1, 1), v(-1, 1, 1), v(1, -1, 1), v(-1, -1, 1), v(1, 1, -1), v(-1, 1, -1), v(1, -1, -1), v(-1, -1, -1)), this.setIndex(u), this.setAttribute("position", new Float32BufferAttribute(m, 3)), this.setAttribute("normal", new Float32BufferAttribute(p, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2));
    function x(P, S, b, E, w, h, _, N, I, L, A) {
      let k = (h - 2 * a) / I, q = (_ - 2 * a) / L, oe = h / 2 - a, ce = _ / 2 - a, ie = N / 2, K = I + 1, U = L + 1, z = 0, B = 0, D = new Vector3();
      for (let M = 0; M < U; M++) {
        let G = M * q - ce;
        for (let Q = 0; Q < K; Q++) {
          let j = Q * k - oe;
          D[P] = j * E, D[S] = G * w, D[b] = ie, m.push(D.x, D.y, D.z), D[P] = 0, D[S] = 0, D[b] = N > 0 ? 1 : -1, p.push(D.x, D.y, D.z), d.push(Q / I), d.push(1 - M / L), z += 1;
        }
      }
      for (let M = 0; M < L; M++)
        for (let G = 0; G < I; G++) {
          let Q = f + G + K * M, j = f + G + K * (M + 1), V = f + (G + 1) + K * (M + 1), F = f + (G + 1) + K * M;
          u.push(Q, j, F), u.push(j, V, F), B += 6;
        }
      c.addGroup(g, B, A), g += B, f += z;
    }
    function y(P, S, b, E, w, h, _, N, I, L, A) {
      let k = (_ - 2 * a) / L, q = _ / 2 - a, oe = N / 2 - a, ce = I / 2, ie = L + 1, K = 0, U = 0, z = new Vector3(), B = new Vector3();
      for (let D = 0; D < l + 1; D++) {
        let M = D / l * qa, G = Math.sin(M) * a, Q = (1 - Math.cos(M)) * a, j = Math.sin(M), V = Math.cos(M);
        z[S] = (oe + G) * w, z[b] = (ce - Q) * h, B[P] = 0, B[S] = j * Math.sign(z[S]), B[b] = V * Math.sign(z[b]);
        for (let F = 0; F < ie; F++) {
          let O = F * k - q;
          z[P] = O * E, m.push(z.x, z.y, z.z), p.push(B.x, B.y, B.z), d.push(F / L), d.push(0), K += 1;
        }
      }
      for (let D = 0; D < l; D++)
        for (let M = 0; M < L; M++) {
          let G = f + M + ie * D, Q = f + M + ie * (D + 1), j = f + (M + 1) + ie * (D + 1), V = f + (M + 1) + ie * D;
          u.push(G, Q, V), u.push(Q, j, V), U += 6;
        }
      c.addGroup(g, U, A), g += U, f += K;
    }
    function v(P, S, b) {
      let E = new Vector3(), w = new Vector3(r / 2, e / 2, t / 2);
      w.subScalar(a);
      let h = [], _ = P * S * b > 0 ? (I, L, A) => u.push(I, L, A) : (I, L, A) => u.push(I, A, L);
      for (let I = 0; I <= l; I++) {
        let L = [], A = qa * (1 - I / l), k = Math.cos(A), q = Math.sin(A), oe = 0;
        for (let ce = 0; ce <= I; ce++) {
          let ie = Math.cos(oe), K = Math.sin(oe);
          E.x = k * ie, E.y = q, E.z = k * K;
          let U = w.clone().addScaledVector(E, a);
          m.push(P * U.x, S * U.y, b * U.z), p.push(P * E.x, S * E.y, b * E.z), d.push(0, 0), L.push(f++), oe += qa / I;
        }
        h.push(L);
      }
      let N = h.length - 1;
      for (let I = 0; I < N; I++) {
        let L = h[I], A = h[I + 1], k = L.length - 1;
        _(L[0], A[1], A[0]);
        for (let q = 1; q <= k; q++)
          _(L[q - 1], L[q], A[q]), _(L[q], A[q + 1], A[q]);
      }
    }
  }
};
var Rr = class extends BufferGeometry {
  constructor(r = [], e = [], t = "", o = 1, n = 0.2, s = 4) {
    super(), this.type = "PolyhedronGeometryRound";
    let a = [], l = [], c = [];
    u(), m(), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(l, 2));
    return;
    function u() {
      var _a2;
      n = Math.min(1 - 1e-5, n), n == 0 && (s = 0);
      let d = { IcosahedronGeometry: 5, DodecahedronGeometry: 3, HexahedronGeometry: 3, OctahedronGeometry: 4, TetrahedronGeometry: 3 }[t], f = new Vector3(), g = f.clone(), x = new Triangle(), y = n * o, v = o - y, P = s + 1, S = new Vector3(), b = (K, U) => S.subVectors(K, U).normalize(), E = (K, U) => Array(K).fill(void 0).map(U), w = E(r.length / 3, (K, U) => new Vector3().fromArray(r, U * 3).setLength(o)), h = [], _ = 1e6;
      for (let K = 0; K < w.length; K++) {
        let U = w[K], z = [], B, D, M, G = 1e10, Q = -1;
        for (; (Q = e.indexOf(K, Q + 1)) != -1; ) {
          let O = Q - Q % 3;
          B = e[O + (Q + 1) % 3], D = e[O + (Q + 2) % 3], M = U.distanceToSquared(w[B]), G = Math.min(G, M), z.push([B, D, M]);
        }
        G += 1e-6;
        let j = [], V = 0, F = z.length;
        for (let O = 0; O < F; O++) {
          [B, D, M] = z[V];
          let $ = ((_a2 = h[B]) == null ? void 0 : _a2.includes(K)) == true;
          M <= G && j.push(B + +$ * _), V = z.findIndex((Z) => Z[0] == D);
        }
        h.push(j);
      }
      let N = [];
      {
        let K = 0, U = 0, z, B, D = d == 3;
        for (let M = 0; M <= s; M++) {
          z = M * (M + 1) / 2, B = (M + 1) * (M + 2) / 2;
          for (let G = 0; G < s - M; G++)
            [K, U] = [z + G + M + 2, B + G + M + 3], N.push(z, B, ...D ? [U, z] : [K, B], U, K), [z, B] = [K, U];
          N.push(z, B, z + s + 2);
        }
      }
      let I = f.clone(), L = f.clone(), A = f.clone(), k = f.clone(), q = f.clone(), oe = [], ce = E(w.length, () => E(d, () => f.clone()));
      for (let K = 0; K < w.length; K++) {
        f.copy(w[K]).normalize(), I.copy(f).multiplyScalar(v);
        let U = h[K];
        for (let j = 0; j < U.length; j++) {
          let V = U[j], F = U[(j + 1) % d];
          x.setFromPointsAndIndices(w, K, V % _, F % _), x.b.sub(x.a).setLength(1e10).add(x.a), x.c.sub(x.a).setLength(1e10).add(x.a), x.closestPointToPoint(I, ce[K][j]);
        }
        let z = [], B = [], D = [], M = new Vector3();
        s == 0 && [...ce[K]].reduce((j, V) => j.add(V), M).multiplyScalar(1 / d);
        for (let j = 0; j < d; j++) {
          let V = [], F = (j - 1 + d) % d, O = ce[K][F], $ = ce[K][j];
          f.copy(O).sub(I), g.copy($).sub(I);
          let Z = I.angleTo(f), ee = f.angleTo(g), H = Math.cos(Z) * y;
          s == 0 ? L.copy(M) : L.copy(I).setLength(v + H), B.push(H);
          let J = [L, O, $];
          for (let X = 0; X < 2; X++) {
            let re = J[X], le = J[X + 1];
            k.subVectors(re, I), q.subVectors(le, I), A.crossVectors(k, q).normalize();
            for (let ne = 0; ne < P; ne++) {
              let de = [Z, ee][X] * ne / P;
              f.copy(k).applyAxisAngle(A, de).add(I), z.push(f.clone()), X && (b(f, I), V.push([ne == 0 ? re : f.clone(), S.clone()]));
            }
            X && (b(le, I), V.push([le, S.clone()]));
          }
          D.push(V);
        }
        oe.push(D);
        let G = 2 * P, Q = 2;
        for (let j = 0; j < d; j++) {
          let V = G * j, F = G * ((j + 1) % d), O = [z[V]];
          for (let Z = 1; Z < P; Z++) {
            k = z[V + Z], q = z[F + Z], O.push(k);
            for (let ee = 1, H = Z - Q + 1; ee <= H; ee++)
              f.lerpVectors(k, q, ee / (H + 1)), f.sub(I).setLength(B[j]).add(I), O.push(f.clone());
            O.push(q);
          }
          for (let Z = 0; Z < P; Z++)
            O.push(z[Z + P + V]);
          O.push(z[F + P]);
          let $ = N.map((Z) => O[Z]);
          a.push(...$.map((Z) => [Z.x, Z.y, Z.z]).flat()), c.push(...$.map((Z) => (b(Z, I), [S.x, S.y, S.z])).flat());
        }
      }
      let ie = [];
      for (let K = 0; K < h.length; K++)
        for (let U = 0; U < d; U++) {
          let z = h[K][U];
          if (z < _) {
            let B = h[z].findIndex((G) => G % _ == K), D = oe[K][U], M = oe[z][B];
            for (let G = 0; G < P; G++) {
              let Q = D[G], j = M[P - G], V = D[G + 1], F = M[P - (G + 1)];
              [Q, j, V, V, j, F].forEach((O) => {
                a.push(O[0].x, O[0].y, O[0].z), c.push(O[1].x, O[1].y, O[1].z);
              });
            }
            ie.push(D[0][0], M[P][0], D[P][0], M[0][0]);
          }
        }
      for (; ie.length; ) {
        let K, U, z, B;
        [K, U] = ie.splice(0, 2);
        let D = [K];
        for (; K != U; )
          D.push(U), z = ie.indexOf(U), B = z % 2, U = ie.splice(z - B, 2)[1 - B];
        S.subVectors(D[0], D[1]).cross(f.subVectors(D[0], D[2])).normalize();
        let M = S.dot(D[0]) < 0;
        M && S.negate();
        for (let G = 1; G <= D.length - 2; G++)
          [D[G + +M], D[G + 1 - +M], D[0]].forEach((Q) => {
            a.push(Q.x, Q.y, Q.z), c.push(S.x, S.y, S.z);
          });
      }
    }
    function m() {
      let p = new Vector3();
      for (let w = 0; w < a.length; w += 3) {
        p.x = a[w + 0], p.y = a[w + 1], p.z = a[w + 2];
        let h = b(p) / 2 / Math.PI + 0.5, _ = E(p) / Math.PI + 0.5;
        l.push(h, 1 - _);
      }
      let d = new Vector3(), f = new Vector3(), g = new Vector3(), x = new Vector3(), y = new Vector2(), v = new Vector2(), P = new Vector2(), S = (w, h, _, N) => {
        N < 0 && w.x === 1 && (l[h] = w.x - 1), _.x === 0 && _.z === 0 && (l[h] = N / 2 / Math.PI + 0.5);
      };
      for (let w = 0, h = 0; w < a.length; w += 9, h += 6) {
        d.set(a[w + 0], a[w + 1], a[w + 2]), f.set(a[w + 3], a[w + 4], a[w + 5]), g.set(a[w + 6], a[w + 7], a[w + 8]), y.set(l[h + 0], l[h + 1]), v.set(l[h + 2], l[h + 3]), P.set(l[h + 4], l[h + 5]), x.copy(d).add(f).add(g).divideScalar(3);
        let _ = b(x);
        S(y, h + 0, d, _), S(v, h + 2, f, _), S(P, h + 4, g, _);
      }
      for (let w = 0; w < l.length; w += 6) {
        let h = l[w + 0], _ = l[w + 2], N = l[w + 4], I = Math.max(h, _, N), L = Math.min(h, _, N);
        I > 0.9 && L < 0.1 && (h < 0.2 && (l[w + 0] += 1), _ < 0.2 && (l[w + 2] += 1), N < 0.2 && (l[w + 4] += 1));
      }
      function b(w) {
        return Math.atan2(w.z, -w.x);
      }
      function E(w) {
        return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
      }
    }
  }
  static fromJSON(r) {
    return new Rr(r.vertices, r.indices, r.radius, r.corner, r.cornerSides);
  }
};
var tm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, detail: 0, corner: 0, cornerSides: 4 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width) }) };
  }
  static build(i) {
    let { width: r, height: e, depth: t, detail: o, corner: n, cornerSides: s } = i.parameters, a = o === 0 && n !== 0 ? new Rn(r * 0.5, n, s) : new DodecahedronGeometry(r * 0.5, o);
    return a.scale(1, e / r, t / r), Object.assign(a, { userData: __spreadProps(__spreadValues({}, i), { type: "DodecahedronGeometry" }) });
  }
};
var Rn = class extends Rr {
  constructor(r = 1, e = 0.2, t = 4) {
    let o = (1 + Math.sqrt(5)) / 2, n = 1 / o, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -o, 0, -n, o, 0, n, -o, 0, n, o, -n, -o, 0, -n, o, 0, n, -o, 0, n, o, 0, -o, 0, -n, o, 0, -n, -o, 0, n, o, 0, n], a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], l = "DodecahedronGeometry";
    super(s, a, l, r, e, t), this.type = l;
  }
  static fromJSON(r) {
    return new Rn(r.radius, r.corner, r.cornerSides);
  }
};
var zn = 1e-12;
var Fo = class {
  constructor(r) {
    this.position = new Vector2();
    this.startPosition = new Vector2();
    this.uuid = MathUtils.generateUUID();
    this.position = r.clone();
  }
  start() {
    this.reset();
  }
  reset() {
    this.startPosition.copy(this.position);
  }
  applyOffset(r) {
    this.position.copy(this.startPosition).add(r);
  }
  copy(r) {
    return this.position.copy(r.position), this.startPosition.copy(r.startPosition), this;
  }
  clone() {
    return new Fo(this.position).copy(this);
  }
  toJSON() {
    return [this.position.x, this.position.y];
  }
};
var Uo = class extends Fo {
  constructor(e) {
    super(e.position);
    this.parent = e;
  }
  copy(e) {
    return super.copy(e), this;
  }
  clone() {
    return new Uo(this.parent).copy(this);
  }
};
var _t = class extends Fo {
  constructor(e, t) {
    super(t);
    this.controls = [];
    this.roundness = 0;
    this.areControlsDirectionsMirrored = true;
    this.uuid = e, this.controls.push(new Uo(this), new Uo(this));
  }
  static create(e, t) {
    let o = new _t(e, new Vector2(...t.position));
    return o.controls[0].position.set(...t.controlPrevious.position), o.controls[1].position.set(...t.controlNext.position), o.roundness = t.roundness, o.areControlsDirectionsMirrored = t.areControlsDirectionsMirrored, o;
  }
  getOppositeControl(e) {
    let t = this.controls.indexOf(e);
    return t === 0 ? this.controls[1] : t === 1 ? this.controls[0] : null;
  }
  applyOffsetToControls(e, t = 1) {
    for (let o = 0, n = this.controls.length; o < n; o++) {
      let s = this.controls[o];
      this.position.distanceTo(s.position) <= t ? s.position.copy(this.position) : s.applyOffset(e);
    }
  }
  controlsMoved() {
    return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position));
  }
  copy(e) {
    return super.copy(e), this.controls[0].copy(e.controls[0]), this.controls[1].copy(e.controls[1]), this.roundness = e.roundness, this.uuid = e.uuid, this;
  }
  clone() {
    return new _t(this.uuid, this.position).copy(this);
  }
  toJSON() {
    return super.toJSON().concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [this.roundness]);
  }
  computeTangents() {
    var _a2, _b2;
    let e = (_a2 = this.curveBefore) == null ? void 0 : _a2.getTangentAt(1), t = (_b2 = this.curveAfter) == null ? void 0 : _b2.getTangentAt(0);
    return [e, t];
  }
  computeNormals(e = new Vector2(), t = new Vector2()) {
    let [o, n] = this.computeTangents();
    return o && n && (rm(o, e), rm(n, t)), [e, t];
  }
  computeTangent(e = new Vector2()) {
    let [t, o] = this.computeTangents();
    return t && o && e.copy(t).add(o).normalize(), e;
  }
  computeNormal(e = new Vector2()) {
    let [t, o] = this.computeNormals();
    return e.copy(t).add(o).normalize(), e;
  }
};
function rm(i, r = new Vector2()) {
  let e = i.length();
  return r.set(-i.y / e, i.x / e);
}
var Ja = (i) => i;
var jo = new Vector2();
var Os = new Vector2();
var Yv = new Vector2();
var Kv = new Vector2();
var Qv = new Vector2();
var Jv = new Vector2();
var im = new Vector3();
var sm = new Vector3();
function am(i) {
  let r = new Vector2();
  r.addVectors(i.v0, jo.subVectors(i.v1, i.v0).multiplyScalar(2 / 3));
  let e = new Vector2();
  return e.addVectors(i.v2, Os.subVectors(i.v1, i.v2).multiplyScalar(2 / 3)), new CubicBezierCurve(i.v0, r, e, i.v2);
}
function Vn(i, r, e = Number.EPSILON) {
  return Math.abs(i - r) < e;
}
function Zv(i, r, e = Number.EPSILON) {
  return i.distanceTo(r) < e;
}
function eb(i, r, e = Number.EPSILON) {
  return i.distanceTo(r) < e;
}
function Za(i, r, e) {
  let t = Math.sqrt(Math.pow(r.x - i.x, 2) + Math.pow(r.y - i.y, 2)), o = Math.sqrt(Math.pow(r.x - e.x, 2) + Math.pow(r.y - e.y, 2)), n = Math.sqrt(Math.pow(e.x - i.x, 2) + Math.pow(e.y - i.y, 2));
  return Math.acos((o * o + t * t - n * n) / (2 * o * t));
}
function lm(i, r, e) {
  return om(i, r) && om(r, e) && Ka(i.position, r.position, e.position);
}
function Ka(i, r, e) {
  return jo.copy(r).sub(i).cross(Os.copy(e).sub(i)) === 0;
}
function cm(i, r, e, t, o) {
  let n = Math.sqrt(Math.pow(r.x - i.x, 2) + Math.pow(r.y - i.y, 2)), s = (i.y + r.y) / 2, a = (i.x + r.x) / 2, l = Math.sqrt(Math.pow(e, 2) - Math.pow(n / 2, 2)) * (i.y - r.y) / n, c = Math.sqrt(Math.pow(e, 2) - Math.pow(n / 2, 2)) * (r.x - i.x) / n;
  return t.set(a + l, s + c), o.set(a - l, s - c), [t, o];
}
function um(i, r, e) {
  let t = i.distanceTo(e), o = r.distanceTo(e);
  return t < o ? r : i;
}
function pm(i, r, e, t, o, n) {
  let s = r.x - i.x, a = r.y - i.y, l = e.x - i.x, c = e.y - i.y, u = Math.sqrt((s + l) * (s + l) + (a + c) * (a + c)), m;
  return Za(r, i, e) > Math.PI && (u *= -1), Vn(c, a) ? m = (a + c) * (t / u - 0.5) * 8 / 3 / (s - l) : m = (s + l) * (t / u - 0.5) * 8 / 3 / (c - a), o.set(r.x - m * a, r.y + m * s), n.set(e.x + m * c, e.y - m * l), [o, n];
}
function el(i, r) {
  return i.position.equals(i.controls[1].position) && r.position.equals(r.controls[0].position);
}
function om(i, r) {
  return Ka(i.position, i.controls[1].position, r.position) && Ka(i.position, r.controls[0].position, r.position);
}
function mm(i, r, e, t, o = 0.5) {
  let n = jo.subVectors(r, i).multiplyScalar(o).add(i), s = Os.subVectors(e, r).multiplyScalar(o).add(r), a = Yv.subVectors(t, e).multiplyScalar(o).add(e), l = n, c = Kv.subVectors(s, n).multiplyScalar(o).add(n), u = Qv.subVectors(a, s).multiplyScalar(o).add(s), m = a, p = Jv.subVectors(u, c).multiplyScalar(o).add(c);
  return [i.x, i.y, l.x, l.y, c.x, c.y, p.x, p.y, u.x, u.y, m.x, m.y, t.x, t.y];
}
function dm(i, r, e = 12, t = true) {
  let o = sm.set(0, 0, 0), n, s = 0, a = [];
  for (let l = 0; l < r.length; l++) {
    let c = Ja(r[l]), u = jo, m = zr(c, e);
    a.push(m);
    for (let p = 0; p <= m; p++)
      if (c instanceof CubicBezierCurve || c instanceof QuadraticBezierCurve || c instanceof LineCurve) {
        if (c.getPoint(p / m, u), o.set(u.x, u.y, 0), n !== void 0 && eb(n, o))
          continue;
        n === void 0 && (n = im), n.copy(o), i.setXYZ(s, o.x, o.y, o.z), s++;
      }
  }
  return t && s > 1 && !(i.getX(s - 1) === i.getX(0) && i.getY(s - 1) === i.getY(0) && i.getZ(s - 1) === i.getZ(0)) && (i.setXYZ(s, i.getX(0), i.getY(0), i.getZ(0)), s++), i;
}
function fm(i, r, e, t = 12, o = true) {
  let n = sm.set(0, 0, 0), s = 0, a = [];
  for (let l = 0; l < r.length; l++) {
    if (e[l] === false)
      continue;
    let c, u = Ja(r[l]), m = jo, p = zr(u, t);
    a.push(p);
    for (let d = 0; d <= p; d++)
      if (u instanceof CubicBezierCurve || u instanceof QuadraticBezierCurve || u instanceof LineCurve) {
        if (u.getPoint(d / p, m), n.set(m.x, m.y, 0), c == null ? void 0 : c.equals(n))
          continue;
        c === void 0 ? c = im : (i.setXYZ(s, c.x, c.y, c.z), s++, i.setXYZ(s, n.x, n.y, n.z), s++), c.copy(n);
      }
  }
  return o && s > 1 && !(i.getX(s - 1) === i.getX(0) && i.getY(s - 1) === i.getY(0) && i.getZ(s - 1) === i.getZ(0)) && (i.setXYZ(s, i.getX(0), i.getY(0), i.getZ(0)), s++), a;
}
function tl(i, r = 12, e = false) {
  let t = [];
  for (let o = 0, n = i.length; o < n; o++) {
    let s = i[o], a = 0;
    if (e && s.roundedCurveCorner !== void 0) {
      let l = zr(s.roundedCurveCorner, r) * 0.5;
      o > 0 && (t[o - 1] += l), a += l;
    }
    s.curveAfter !== void 0 && (a += zr(s.curveAfter, r)), t.push(a);
  }
  return i.length > 0 && e && i[0].roundedCurveCorner !== void 0 && (t[i.length - 1] += zr(i[0].roundedCurveCorner, r) * 0.5), t;
}
function zr(i, r = 12) {
  return i && i instanceof EllipseCurve ? r * 2 : i && (i instanceof LineCurve || i instanceof LineCurve3) ? 1 : i && i instanceof SplineCurve ? r * i.points.length : r;
}
function hm(i, r, e = 12, t = true) {
  let o, n = 0;
  for (let s = 0; s < r.length; s++) {
    let a = Ja(r[s]), l = zr(a, e), c = jo;
    for (let u = 0; u <= l; u++)
      if (a instanceof CubicBezierCurve || a instanceof QuadraticBezierCurve || a instanceof LineCurve) {
        if (a.getPoint(u / l, c), o !== void 0 && Zv(o, c, zn))
          continue;
        o === void 0 && (o = Os), o.copy(c), i.push(c.x, c.y), n++;
      }
  }
  return Vn(i[0], i[i.length - 2], zn) && Vn(i[1], i[i.length - 1], zn) && (i.pop(), i.pop()), t && n > 1 && !(Vn(i[n - 1], i[1], zn) && Vn(i[n - 2], i[0], zn)) && (i.push(i[0], i[1]), n++), i;
}
var nl = new Vector2();
var nb = new Vector2();
var ib = new Vector2();
var sb = new Vector2();
var ab = new Vector2();
var lb = new Vector2();
var Se = class extends Shape {
  constructor(e = 100, t = 100) {
    super();
    this.points = [];
    this.shapeHoles = [];
    this.eventDispatcher = new EventDispatcher();
    this.plane = new Plane(new Vector3(0, 0, -1));
    this.subdivision = 0;
    this.controlSnapDistance = 4;
    this.pointIDs = 0;
    this.isMesh2D = false;
    this._roundness = 0;
    this.isClosed = false;
    this.useCubicForRoundedCorners = true;
    this.uuid = MathUtils.generateUUID();
    this.needsUpdate = false;
    this.roundedCurves = [];
    this._width = e, this._height = t;
  }
  static createFromState(e, t, o) {
    let n = new Se();
    return n.isClosed = e.isClosed, n.points = e.points.map((s) => _t.create(s.id, s.data)), typeof e.roundness == "number" && (n.roundness = e.roundness), n.shapeHoles = e.shapeHoles.map((s) => Se.createFromState(s)), t !== void 0 && o !== void 0 && n.applySize(t, o), n.update(), n;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get roundness() {
    return this._roundness;
  }
  set roundness(e) {
    if (this._roundness !== e) {
      this._roundness = e;
      for (let t = 0, o = this.points.length; t < o; t++)
        this.points[t].roundness = e;
      this.needsUpdate = true;
    }
  }
  getPointsIndexesByIds(e) {
    return e.map((t) => this.getPointIndexById(t)).filter((t) => t >= 0);
  }
  getPointIndexById(e) {
    let t = this.points.length, o = this.points.findIndex((n) => n.uuid === e);
    if (o < 0) {
      let n = t;
      for (let s = 0, a = this.shapeHoles.length; s < a; s++) {
        let l = this.shapeHoles[s], c = l.points.length - 1, u = l.getPointIndexById(e);
        if (u < 0)
          n += c;
        else
          return u + n;
      }
    }
    return o;
  }
  getLineIndexById(e) {
    return this.getPointIndexById(e);
  }
  getBezierPoint(e) {
    if (e <= this.points.length - 1)
      return this.points[e];
    if (this.shapeHoles.length > 0)
      for (let t = 0, o = this.shapeHoles.length; t < o; t++) {
        let n = this.shapeHoles[t], s = e - this.points.length;
        if (s <= n.points.length - 1)
          return n.points[s];
      }
    throw new Error("This shape does not have a point for this index: " + e);
  }
  getBezierPointIndex(e) {
    let t = this.points.indexOf(e);
    if (t >= 0)
      return t;
    if (t = this.points.length, this.shapeHoles.length > 0)
      for (let o = 0, n = this.shapeHoles.length; o < n; o++) {
        let s = this.shapeHoles[o], a = s.points.indexOf(e);
        if (a >= 0)
          return t + a;
        t += s.points.length;
      }
    return -1;
  }
  getAllPoints() {
    let e = [].concat(...this.shapeHoles.map((t) => t.points));
    return [...this.points, ...e];
  }
  applySize(e, t) {
    e === 0 && (e = 1e-3), t === 0 && (t = 1e-3), this._width = e, this._height = t;
  }
  applyScale(e, t) {
    let o = nl.set(e, t);
    for (let n = 0, s = this.points.length; n < s; n++) {
      let a = this.points[n];
      a.position.multiply(o), a.controls[0].position.multiply(o), a.controls[1].position.multiply(o);
    }
    for (let n = 0, s = this.shapeHoles.length; n < s; n++)
      this.shapeHoles[n].applyScale(e, t);
    this._update(false);
  }
  createPoint(e, t = 0, o = MathUtils.generateUUID()) {
    let n;
    e instanceof Vector2 ? n = e : n = new Vector2(e, t);
    let s = new _t(o, n);
    return s.roundness = this.roundness, s;
  }
  addPoint(e) {
    this.points.push(e), this.needsUpdate = true;
  }
  addPointAt(e, t) {
    this.points.splice(t, 0, e), this.needsUpdate = true;
  }
  getPointByUuid(e) {
    for (let t = 0, o = this.points.length; t < o; t++) {
      let n = this.points[t];
      if (n.uuid === e)
        return n;
    }
    for (let t = 0, o = this.shapeHoles.length; t < o; t++) {
      let s = this.shapeHoles[t].getPointByUuid(e);
      if (s)
        return s;
    }
  }
  getFirstPoint() {
    return this.points[0];
  }
  getLastPoint() {
    return this.points[this.points.length - 1];
  }
  removePoint(e) {
    let t = this.points.indexOf(e);
    t >= 0 && this.points.splice(t, 1), this.needsUpdate = true;
  }
  removePointById(e) {
    let t = this.points.find((o) => o.uuid === e);
    t && this.removePoint(t);
  }
  update(e = true) {
    for (let t = 0, o = this.shapeHoles.length; t < o; t++)
      this.shapeHoles[t].update(false);
    this._update(e);
  }
  extractShapePointsToBuffer(e, t = 12, o = false) {
    this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t);
    let n = o ? this.roundedCurveDivisions : this.curveDivisions;
    return dm(e, o ? this.roundedCurves : this.curves, t, this.autoClose), n.reduce((s, a) => s + a, 0) + 1;
  }
  computeCurveDivisions(e = 12) {
    return this.curveDivisions = tl(this.points, e, false), this.roundedCurveDivisions = tl(this.points, e, true), this.curveDivisions;
  }
  extractFilteredShapePointsToBuffer(e, t, o = 12) {
    return fm(e, this.curves, t, o, this.autoClose).reduce((s, a) => s + a, 0) * 2;
  }
  extractShapePointsToFlatArray(e, t = 12) {
    return this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t), hm(e, this.roundedCurves, t, this.autoClose);
  }
  getCurveIndexFromVertexId(e, t = false) {
    let o = 0;
    this.curveDivisions === void 0 && this.computeCurveDivisions(this.subdivision);
    let n = t ? this.roundedCurveDivisions : this.curveDivisions, s = 0;
    t && this.points[0].roundedCurveCorner !== void 0 && (s = zr(this.points[0].roundedCurveCorner, this.subdivision) * 0.5);
    let a = e - s;
    a < 0 && (a += n.reduce((l, c) => l + c, 0));
    for (let l = 0, c = n.length; l < c; l++) {
      let u = n[l];
      if (a < o + u)
        return [l, (a - o + 1) / u];
      o += u;
    }
    return [0, 1];
  }
  getCurveT(e, t, o) {
    let n = this.points[e], s = this.points[e >= this.points.length - 1 ? 0 : e + 1], a = this.curveDivisions, l = a[e];
    if (el(n, s)) {
      let m = n.position.distanceTo(s.position);
      return n.position.distanceTo(nl.set(o.x, o.y)) / m;
    }
    let c = 0;
    for (let m = 0; m < e; m++)
      c += a[m];
    return (t - c) / l;
  }
  dispose() {
    this.eventDispatcher = null;
  }
  _applyCurveForPoint(e, t) {
    el(t, e) ? this.lineTo(e.position.x, e.position.y) : this.bezierCurveTo(t.controls[1].position.x, t.controls[1].position.y, e.controls[0].position.x, e.controls[0].position.y, e.position.x, e.position.y);
    let o = this.curves[this.curves.length - 1];
    e.curveBefore = o, t.curveAfter = o;
    let n = o.clone();
    e.roundedCurveBefore = n, t.roundedCurveAfter = n, e.roundedCurveCorner = void 0, this.roundedCurves.push(n);
  }
  _update(e = true) {
    var _a2, _b2, _c2;
    if (this.curves = [], this.roundedCurves = [], !this.points.length)
      return;
    for (let o = 0, n = this.points.length; o < n; o++) {
      let s = this.points[o];
      if (o === 0)
        this.moveTo(s.position.x, s.position.y);
      else {
        let a = this.points[o - 1];
        this._applyCurveForPoint(s, a);
      }
    }
    let t = this.getLastPoint();
    if ((t == null ? void 0 : t.curveAfter) && (t.curveAfter = void 0), this.isClosed) {
      let o = this.points[0], n = this.points[this.points.length - 1];
      this._applyCurveForPoint(o, n);
    }
    if (this.points.length > 2) {
      let o = 0;
      for (let n = 0, s = this.points.length; n < s; n++) {
        let a = this.points[n], l = (_a2 = this.points[n - 1]) != null ? _a2 : this.points[this.points.length - 1], c = (_b2 = this.points[n + 1]) != null ? _b2 : this.points[0], u = a.roundness, m = l && c && lm(l, a, c);
        if (!a.controlsMoved() && u > 0 && !m) {
          let p = a.curveBefore, d = a.curveAfter;
          if (p === void 0 || d === void 0)
            continue;
          let f = a.roundedCurveBefore, g = a.roundedCurveAfter, x = p.getLength(), y = d.getLength(), v = Math.min(u, x * 0.499), P = Math.min(u, y * 0.499), S = Math.min(v, P), b = 1 - S / x, E = S / y, w = p.getPointAt(b, nl), h = d.getPointAt(E, nb);
          this._subSplitCurve(p, f, b, w, void 0), this._subSplitCurve(d, g, E, void 0, h);
          let _;
          if (this.useCubicForRoundedCorners) {
            let N = Za(w, a.position, h) / 2, I = Math.tan(N) * w.distanceTo(a.position), [L, A] = cm(w, h, I, ib, sb), k = um(L, A, a.position), [q, oe] = pm(k, w, h, I, ab, lb);
            _ = new CubicBezierCurve(w.clone(), q.clone(), oe.clone(), h.clone());
          } else
            _ = new QuadraticBezierCurve(w.clone(), a.position.clone(), h.clone());
          a.roundedCurveCorner = _, this.roundedCurves.splice(n + o, 0, _), o++;
        }
      }
    }
    e && ((_c2 = this.eventDispatcher) == null ? void 0 : _c2.dispatchEvent({ type: "update" }));
  }
  _subSplitCurve(e, t, o, n, s) {
    if (e instanceof LineCurve)
      n !== void 0 && t.v2.copy(n), s !== void 0 && t.v1.copy(s);
    else {
      let a = e, l = t, c = a.getUtoTmapping(o, 0), u = mm(a.v0, a.v1, a.v2, a.v3, c);
      return n !== void 0 && (l.v0.set(u[0], u[1]), l.v1.set(u[2], u[3]), l.v2.set(u[4], u[5]), l.v3.set(u[6], u[7])), s !== void 0 && (l.v0.set(u[6], u[7]), l.v1.set(u[8], u[9]), l.v2.set(u[10], u[11]), l.v3.set(u[12], u[13])), l;
    }
    return t;
  }
  clone() {
    let e = new Se(this._width, this._height);
    return e.points = this.points.map((t) => t.clone()), e.isClosed = this.isClosed, e.roundness = this.roundness, e.isMesh2D = this.isMesh2D, e.shapeHoles = this.shapeHoles.map((t) => t.clone()), e;
  }
  toJSON() {
    return { points: this.points.reduce((e, t) => e.concat(t.toJSON()), []), shapeHoles: this.shapeHoles.map((e) => e.toJSON()), isClosed: this.isClosed, roundness: this.roundness };
  }
  fromJSON(e) {
    var _a2;
    this.points = [], this.pointIDs = 0;
    let t = e.points.length / 7;
    for (let o = 0; o < t; o++) {
      let n = o * 7, s = e.points[n + 0], a = e.points[n + 1], l = e.points[n + 2], c = e.points[n + 3], u = e.points[n + 4], m = e.points[n + 5], p = e.points[n + 6], d = new _t(MathUtils.generateUUID(), new Vector2(s, a));
      d.controls[0].position.set(l, c), d.controls[1].position.set(u, m), d.roundness = p, this.points.push(d);
    }
    return this.shapeHoles = ((_a2 = e.shapeHoles) == null ? void 0 : _a2.length) ? e.shapeHoles.map((o) => {
      let n = new Se();
      return n.fromJSON(o), n;
    }) : [], this.isClosed = e.isClosed, this._roundness = e.roundness, this._update(), this;
  }
  fromShape(e) {
    let t = (n, s) => {
      s instanceof CubicBezierCurve && s.v3.equals(n.position) && n.controls[0].position.copy(s.v2);
    }, o = (n) => {
      let s = [], a, l;
      for (a = 0, l = n.length; a < l; a++)
        n[a] instanceof QuadraticBezierCurve && (n[a] = am(n[a]));
      for (a = 0, l = n.length; a < l; a++) {
        let m = n[a], p = a > 0 ? n[a - 1] : null, d;
        m instanceof CubicBezierCurve ? (d = this.createPoint(m.v0), d.controls[1].position.copy(m.v1)) : m instanceof LineCurve && (d = this.createPoint(m.v1)), d !== void 0 && (p !== null && t(d, p), s.push(d));
      }
      let c = n[n.length - 1], u = false;
      return c instanceof CubicBezierCurve ? c.v3.equals(s[0].position) && (s[0].controls[0].position.copy(c.v2), u = true) : c instanceof LineCurve && c.v2.equals(s[0].position) && (u = true), this.isClosed = u, s;
    };
    return this.points = o(e.curves), e instanceof Shape && (this.shapeHoles = e.holes.map((n) => {
      let s = new Se();
      return s.fromShape(n), s;
    })), this.update(), this;
  }
};
var sl = Math.PI * 2;
function il({ x: i, y: r }, e, t, o, n) {
  return { x: i * e + o, y: r * t + n };
}
function cb(i, r) {
  let e = r === 1.5707963267948966 ? 0.551915024494 : r === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(r / 4), t = Math.cos(i), o = Math.sin(i), n = Math.cos(i + r), s = Math.sin(i + r);
  return [{ x: t - o * e, y: o + t * e }, { x: n + s * e, y: s - n * e }, { x: n, y: s }];
}
function xm(i, r, e, t) {
  let o = i * t - r * e < 0 ? -1 : 1, n = Math.min(1, Math.max(-1, i * e + r * t));
  return o * Math.acos(n);
}
function ub(i, r, e, t, o, n, s, a, l, c) {
  let u = Math.pow(o, 2), m = Math.pow(n, 2), p = Math.pow(s, 2), d = Math.pow(a, 2), f = u * m - u * d - m * p;
  f < 0 && (f = 0), f /= u * d + m * p, f = Math.sqrt(f) * (l === c ? -1 : 1);
  let g = f * o / n * a, x = f * -n / o * s, y = g + (i + e) / 2, v = x + (r + t) / 2, P = (s - g) / o, S = (a - x) / n, b = (-s - g) / o, E = (-a - x) / n, w = xm(1, 0, P, S), h = xm(P, S, b, E);
  return !c && h > 0 && (h -= sl), c && h < 0 && (h += sl), { centerx: y, centery: v, ang1: w, ang2: h };
}
function vm({ px: i, py: r, cx: e, cy: t, rx: o, ry: n, largeArcFlag: s, sweepFlag: a }) {
  let l = [];
  if (o === 0 || n === 0)
    return [];
  let c = (i - e) / 2, u = (r - t) / 2;
  if (c === 0 && u === 0)
    return [];
  o = Math.abs(o), n = Math.abs(n);
  let m = Math.pow(c, 2) / Math.pow(o, 2) + Math.pow(u, 2) / Math.pow(n, 2);
  m > 1 && (o *= Math.sqrt(m), n *= Math.sqrt(m));
  let p = ub(i, r, e, t, o, n, c, u, s, a), { ang1: d, ang2: f } = p, { centerx: g, centery: x } = p, y = Math.abs(f) / (sl / 4);
  Math.abs(1 - y) < 1e-7 && (y = 1);
  let v = Math.max(Math.ceil(y), 1);
  f /= v;
  for (let P = 0; P < v; P++)
    l.push(cb(d, f)), d += f;
  return l.map((P) => {
    let { x: S, y: b } = il(P[0], o, n, g, x), { x: E, y: w } = il(P[1], o, n, g, x), { x: h, y: _ } = il(P[2], o, n, g, x);
    return { x1: S, y1: b, x2: E, y2: w, x: h, y: _ };
  });
}
var Pe;
(function(i) {
  i[i.ODD = 0] = "ODD", i[i.NONZERO = 1] = "NONZERO", i[i.POSITIVE = 2] = "POSITIVE", i[i.NEGATIVE = 3] = "NEGATIVE", i[i.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO";
})(Pe || (Pe = {}));
var Fe;
(function(i) {
  i[i.POLYGONS = 0] = "POLYGONS", i[i.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", i[i.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS";
})(Fe || (Fe = {}));
function ue(i, r) {
  if (!i)
    throw r || "Assertion Failed!";
}
var se = function() {
  function i() {
  }
  return i.vertEq = function(r, e) {
    return r.s === e.s && r.t === e.t;
  }, i.vertLeq = function(r, e) {
    return r.s < e.s || r.s === e.s && r.t <= e.t;
  }, i.transLeq = function(r, e) {
    return r.t < e.t || r.t === e.t && r.s <= e.s;
  }, i.edgeGoesLeft = function(r) {
    return i.vertLeq(r.Dst, r.Org);
  }, i.edgeGoesRight = function(r) {
    return i.vertLeq(r.Org, r.Dst);
  }, i.vertL1dist = function(r, e) {
    return Math.abs(r.s - e.s) + Math.abs(r.t - e.t);
  }, i.edgeEval = function(r, e, t) {
    ue(i.vertLeq(r, e) && i.vertLeq(e, t));
    var o = e.s - r.s, n = t.s - e.s;
    return o + n > 0 ? o < n ? e.t - r.t + (r.t - t.t) * (o / (o + n)) : e.t - t.t + (t.t - r.t) * (n / (o + n)) : 0;
  }, i.edgeSign = function(r, e, t) {
    ue(i.vertLeq(r, e) && i.vertLeq(e, t));
    var o = e.s - r.s, n = t.s - e.s;
    return o + n > 0 ? (e.t - t.t) * o + (e.t - r.t) * n : 0;
  }, i.transEval = function(r, e, t) {
    ue(i.transLeq(r, e) && i.transLeq(e, t));
    var o = e.t - r.t, n = t.t - e.t;
    return o + n > 0 ? o < n ? e.s - r.s + (r.s - t.s) * (o / (o + n)) : e.s - t.s + (t.s - r.s) * (n / (o + n)) : 0;
  }, i.transSign = function(r, e, t) {
    ue(i.transLeq(r, e) && i.transLeq(e, t));
    var o = e.t - r.t, n = t.t - e.t;
    return o + n > 0 ? (e.s - t.s) * o + (e.s - r.s) * n : 0;
  }, i.vertCCW = function(r, e, t) {
    return r.s * (e.t - t.t) + e.s * (t.t - r.t) + t.s * (r.t - e.t) >= 0;
  }, i.interpolate = function(r, e, t, o) {
    return r = r < 0 ? 0 : r, t = t < 0 ? 0 : t, r <= t ? t === 0 ? (e + o) / 2 : e + (o - e) * (r / (r + t)) : o + (e - o) * (t / (r + t));
  }, i.intersect = function(r, e, t, o, n) {
    var s, a, l;
    i.vertLeq(r, e) || (l = r, r = e, e = l), i.vertLeq(t, o) || (l = t, t = o, o = l), i.vertLeq(r, t) || (l = r, r = t, t = l, l = e, e = o, o = l), i.vertLeq(t, e) ? i.vertLeq(e, o) ? (s = i.edgeEval(r, t, e), a = i.edgeEval(t, e, o), s + a < 0 && (s = -s, a = -a), n.s = i.interpolate(s, t.s, a, e.s)) : (s = i.edgeSign(r, t, e), a = -i.edgeSign(r, o, e), s + a < 0 && (s = -s, a = -a), n.s = i.interpolate(s, t.s, a, o.s)) : n.s = (t.s + e.s) / 2, i.transLeq(r, e) || (l = r, r = e, e = l), i.transLeq(t, o) || (l = t, t = o, o = l), i.transLeq(r, t) || (l = r, r = t, t = l, l = e, e = o, o = l), i.transLeq(t, e) ? i.transLeq(e, o) ? (s = i.transEval(r, t, e), a = i.transEval(t, e, o), s + a < 0 && (s = -s, a = -a), n.t = i.interpolate(s, t.t, a, e.t)) : (s = i.transSign(r, t, e), a = -i.transSign(r, o, e), s + a < 0 && (s = -s, a = -a), n.t = i.interpolate(s, t.t, a, o.t)) : n.t = (t.t + e.t) / 2;
  }, i;
}();
var Fn = function() {
  function i() {
    this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = false, this.inside = false;
  }
  return i;
}();
var Ds = function() {
  function i(r) {
    this.side = r, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0;
  }
  return Object.defineProperty(i.prototype, "Rface", { get: function() {
    return this.Sym.Lface;
  }, set: function(r) {
    this.Sym.Lface = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(i.prototype, "Dst", { get: function() {
    return this.Sym.Org;
  }, set: function(r) {
    this.Sym.Org = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(i.prototype, "Oprev", { get: function() {
    return this.Sym.Lnext;
  }, set: function(r) {
    this.Sym.Lnext = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(i.prototype, "Lprev", { get: function() {
    return this.Onext.Sym;
  }, set: function(r) {
    this.Onext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(i.prototype, "Dprev", { get: function() {
    return this.Lnext.Sym;
  }, set: function(r) {
    this.Lnext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(i.prototype, "Rprev", { get: function() {
    return this.Sym.Onext;
  }, set: function(r) {
    this.Sym.Onext = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(i.prototype, "Dnext", { get: function() {
    return this.Sym.Onext.Sym;
  }, set: function(r) {
    this.Sym.Onext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(i.prototype, "Rnext", { get: function() {
    return this.Sym.Lnext.Sym;
  }, set: function(r) {
    this.Sym.Lnext.Sym = r;
  }, enumerable: true, configurable: true }), i;
}();
var ko = function() {
  function i() {
    this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
  }
  return i;
}();
var bm = function() {
  function i() {
    var r = new ko(), e = new Fn(), t = new Ds(0), o = new Ds(1);
    r.next = r.prev = r, r.anEdge = null, e.next = e.prev = e, t.next = t, t.Sym = o, o.next = o, o.Sym = t, this.vHead = r, this.fHead = e, this.eHead = t, this.eHeadSym = o;
  }
  return i.prototype.makeEdge_ = function(r) {
    var e = new Ds(0), t = new Ds(1);
    r.Sym.side < r.side && (r = r.Sym);
    var o = r.Sym.next;
    return t.next = o, o.Sym.next = e, e.next = r, r.Sym.next = t, e.Sym = t, e.Onext = e, e.Lnext = t, e.Org = null, e.Lface = null, e.winding = 0, e.activeRegion = null, t.Sym = e, t.Onext = t, t.Lnext = e, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, e;
  }, i.prototype.splice_ = function(r, e) {
    var t = r.Onext, o = e.Onext;
    t.Sym.Lnext = e, o.Sym.Lnext = r, r.Onext = o, e.Onext = t;
  }, i.prototype.makeVertex_ = function(r, e, t) {
    var o = r;
    ue(o, "Vertex can't be null!");
    var n = t.prev;
    o.prev = n, n.next = o, o.next = t, t.prev = o, o.anEdge = e;
    var s = e;
    do
      s.Org = o, s = s.Onext;
    while (s !== e);
  }, i.prototype.makeFace_ = function(r, e, t) {
    var o = r;
    ue(o, "Face can't be null");
    var n = t.prev;
    o.prev = n, n.next = o, o.next = t, t.prev = o, o.anEdge = e, o.trail = null, o.marked = false, o.inside = t.inside;
    var s = e;
    do
      s.Lface = o, s = s.Lnext;
    while (s !== e);
  }, i.prototype.killEdge_ = function(r) {
    r.Sym.side < r.side && (r = r.Sym);
    var e = r.next, t = r.Sym.next;
    e.Sym.next = t, t.Sym.next = e;
  }, i.prototype.killVertex_ = function(r, e) {
    var t = r.anEdge, o = t;
    do
      o.Org = e, o = o.Onext;
    while (o !== t);
    var n = r.prev, s = r.next;
    s.prev = n, n.next = s;
  }, i.prototype.killFace_ = function(r, e) {
    var t = r.anEdge, o = t;
    do
      o.Lface = e, o = o.Lnext;
    while (o !== t);
    var n = r.prev, s = r.next;
    s.prev = n, n.next = s;
  }, i.prototype.makeEdge = function() {
    var r = new ko(), e = new ko(), t = new Fn(), o = this.makeEdge_(this.eHead);
    return this.makeVertex_(r, o, this.vHead), this.makeVertex_(e, o.Sym, this.vHead), this.makeFace_(t, o, this.fHead), o;
  }, i.prototype.splice = function(r, e) {
    var t = false, o = false;
    if (r !== e) {
      if (e.Org !== r.Org && (o = true, this.killVertex_(e.Org, r.Org)), e.Lface !== r.Lface && (t = true, this.killFace_(e.Lface, r.Lface)), this.splice_(e, r), !o) {
        var n = new ko();
        this.makeVertex_(n, e, r.Org), r.Org.anEdge = r;
      }
      if (!t) {
        var s = new Fn();
        this.makeFace_(s, e, r.Lface), r.Lface.anEdge = r;
      }
    }
  }, i.prototype.delete = function(r) {
    var e = r.Sym, t = false;
    if (r.Lface !== r.Rface && (t = true, this.killFace_(r.Lface, r.Rface)), r.Onext === r)
      this.killVertex_(r.Org, null);
    else if (r.Rface.anEdge = r.Oprev, r.Org.anEdge = r.Onext, this.splice_(r, r.Oprev), !t) {
      var o = new Fn();
      this.makeFace_(o, r, r.Lface);
    }
    e.Onext === e ? (this.killVertex_(e.Org, null), this.killFace_(e.Lface, null)) : (r.Lface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev)), this.killEdge_(r);
  }, i.prototype.addEdgeVertex = function(r) {
    var e = this.makeEdge_(r), t = e.Sym;
    this.splice_(e, r.Lnext), e.Org = r.Dst;
    var o = new ko();
    return this.makeVertex_(o, t, e.Org), e.Lface = t.Lface = r.Lface, e;
  }, i.prototype.splitEdge = function(r) {
    var e = this.addEdgeVertex(r), t = e.Sym;
    return this.splice_(r.Sym, r.Sym.Oprev), this.splice_(r.Sym, t), r.Dst = t.Org, t.Dst.anEdge = t.Sym, t.Rface = r.Rface, t.winding = r.winding, t.Sym.winding = r.Sym.winding, t.idx = r.idx, t.Sym.idx = r.Sym.idx, t;
  }, i.prototype.connect = function(r, e) {
    var t = false, o = this.makeEdge_(r), n = o.Sym;
    if (e.Lface !== r.Lface && (t = true, this.killFace_(e.Lface, r.Lface)), this.splice_(o, r.Lnext), this.splice_(n, e), o.Org = r.Dst, n.Org = e.Org, o.Lface = n.Lface = r.Lface, r.Lface.anEdge = n, !t) {
      var s = new Fn();
      this.makeFace_(s, o, r.Lface);
    }
    return o;
  }, i.prototype.zapFace = function(r) {
    var e = r.anEdge, t, o, n, s, a;
    o = e.Lnext;
    do
      t = o, o = t.Lnext, t.Lface = null, t.Rface === null && (t.Onext === t ? this.killVertex_(t.Org, null) : (t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), n = t.Sym, n.Onext === n ? this.killVertex_(n.Org, null) : (n.Org.anEdge = n.Onext, this.splice_(n, n.Oprev)), this.killEdge_(t));
    while (t != e);
    s = r.prev, a = r.next, a.prev = s, s.next = a;
  }, i.prototype.countFaceVerts_ = function(r) {
    var e = r.anEdge, t = 0;
    do
      t++, e = e.Lnext;
    while (e !== r.anEdge);
    return t;
  }, i.prototype.mergeConvexFaces = function(r) {
    var e, t, o, n, s, a, l;
    for (e = this.fHead.next; e !== this.fHead; e = e.next)
      if (!!e.inside)
        for (t = e.anEdge, s = t.Org; o = t.Lnext, n = t.Sym, n && n.Lface && n.Lface.inside && (a = this.countFaceVerts_(e), l = this.countFaceVerts_(n.Lface), a + l - 2 <= r && se.vertCCW(t.Lprev.Org, t.Org, n.Lnext.Lnext.Org) && se.vertCCW(n.Lprev.Org, n.Org, t.Lnext.Lnext.Org) && (o = n.Lnext, this.delete(n), t = null, n = null)), !(t && t.Lnext.Org === s); )
          t = o;
    return true;
  }, i.prototype.check = function() {
    var r = this.fHead, e = this.vHead, t = this.eHead, o, n, s, a, l, c;
    for (n = r, n = r; (o = n.next) !== r; n = o) {
      ue(o.prev === n), l = o.anEdge;
      do
        ue(l.Sym !== l), ue(l.Sym.Sym === l), ue(l.Lnext.Onext.Sym === l), ue(l.Onext.Sym.Lnext === l), ue(l.Lface === o), l = l.Lnext;
      while (l !== o.anEdge);
    }
    for (ue(o.prev === n && o.anEdge === null), a = e, a = e; (s = a.next) !== e; a = s) {
      ue(s.prev === a), l = s.anEdge;
      do
        ue(l.Sym !== l), ue(l.Sym.Sym === l), ue(l.Lnext.Onext.Sym === l), ue(l.Onext.Sym.Lnext === l), ue(l.Org === s), l = l.Onext;
      while (l !== s.anEdge);
    }
    for (ue(s.prev === a && s.anEdge === null), c = t, c = t; (l = c.next) !== t; c = l)
      ue(l.Sym.next === c.Sym), ue(l.Sym !== l), ue(l.Sym.Sym === l), ue(l.Org !== null), ue(l.Dst !== null), ue(l.Lnext.Onext.Sym === l), ue(l.Onext.Sym.Lnext === l);
    ue(l.Sym.next === c.Sym && l.Sym === this.eHeadSym && l.Sym.Sym === l && l.Org === null && l.Dst === null && l.Lface === null && l.Rface === null);
  }, i;
}();
var Sm = function() {
  function i() {
    this.handle = null;
  }
  return i;
}();
var wm = function() {
  function i() {
    this.key = null, this.node = 0;
  }
  return i;
}();
var pb = function() {
  function i(r, e) {
    this.leq = e, this.max = 0, this.nodes = [], this.handles = [], this.initialized = false, this.freeList = 0, this.size = 0, this.max = r, this.nodes = [], this.handles = [];
    for (var t = 0; t < r + 1; t++)
      this.nodes[t] = new Sm(), this.handles[t] = new wm();
    this.initialized = false, this.nodes[1].handle = 1, this.handles[1].key = null;
  }
  return i.prototype.floatDown_ = function(r) {
    var e = this.nodes, t = this.handles, o, n, s;
    for (o = e[r].handle; ; ) {
      if (s = r << 1, s < this.size && this.leq(t[e[s + 1].handle].key, t[e[s].handle].key) && ++s, ue(s <= this.max), n = e[s].handle, s > this.size || this.leq(t[o].key, t[n].key)) {
        e[r].handle = o, t[o].node = r;
        break;
      }
      e[r].handle = n, t[n].node = r, r = s;
    }
  }, i.prototype.floatUp_ = function(r) {
    var e = this.nodes, t = this.handles, o, n, s;
    for (o = e[r].handle; ; ) {
      if (s = r >> 1, n = e[s].handle, s === 0 || this.leq(t[n].key, t[o].key)) {
        e[r].handle = o, t[o].node = r;
        break;
      }
      e[r].handle = n, t[n].node = r, r = s;
    }
  }, i.prototype.init = function() {
    for (var r = this.size; r >= 1; --r)
      this.floatDown_(r);
    this.initialized = true;
  }, i.prototype.min = function() {
    return this.handles[this.nodes[1].handle].key;
  }, i.prototype.insert = function(r) {
    var e, t;
    if (e = ++this.size, e * 2 > this.max) {
      this.max *= 2;
      var o, n;
      for (n = this.nodes.length, this.nodes.length = this.max + 1, o = n; o < this.nodes.length; o++)
        this.nodes[o] = new Sm();
      for (n = this.handles.length, this.handles.length = this.max + 1, o = n; o < this.handles.length; o++)
        this.handles[o] = new wm();
    }
    return this.freeList === 0 ? t = e : (t = this.freeList, this.freeList = this.handles[t].node), this.nodes[e].handle = t, this.handles[t].node = e, this.handles[t].key = r, this.initialized && this.floatUp_(e), t;
  }, i.prototype.extractMin = function() {
    var r = this.nodes, e = this.handles, t = r[1].handle, o = e[t].key;
    return this.size > 0 && (r[1].handle = r[this.size].handle, e[r[1].handle].node = 1, e[t].key = null, e[t].node = this.freeList, this.freeList = t, --this.size, this.size > 0 && this.floatDown_(1)), o;
  }, i.prototype.delete = function(r) {
    var e = this.nodes, t = this.handles, o;
    ue(r >= 1 && r <= this.max && t[r].key !== null), o = t[r].node, e[o].handle = e[this.size].handle, t[e[o].handle].node = o, --this.size, o <= this.size && (o <= 1 || this.leq(t[e[o >> 1].handle].key, t[e[o].handle].key) ? this.floatDown_(o) : this.floatUp_(o)), t[r].key = null, t[r].node = this.freeList, this.freeList = r;
  }, i;
}();
var al = function() {
  function i() {
    this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = false, this.sentinel = false, this.dirty = false, this.fixUpperEdge = false;
  }
  return i;
}();
var Tm = function() {
  function i() {
    this.key = null, this.next = null, this.prev = null;
  }
  return i;
}();
var mb = function() {
  function i(r, e) {
    this.frame = r, this.leq = e, this.head = new Tm(), this.head.next = this.head, this.head.prev = this.head;
  }
  return i.prototype.min = function() {
    return this.head.next;
  }, i.prototype.max = function() {
    return this.head.prev;
  }, i.prototype.insert = function(r) {
    return this.insertBefore(this.head, r);
  }, i.prototype.search = function(r) {
    var e = this.head;
    do
      e = e.next;
    while (e.key !== null && !this.leq(this.frame, r, e.key));
    return e;
  }, i.prototype.insertBefore = function(r, e) {
    do
      r = r.prev;
    while (r.key !== null && !this.leq(this.frame, r.key, e));
    var t = new Tm();
    return t.key = e, t.next = r.next, r.next.prev = t, t.prev = r, r.next = t, t;
  }, i.prototype.delete = function(r) {
    r.next.prev = r.prev, r.prev.next = r.next;
  }, i;
}();
var db = function() {
  function i() {
  }
  return i.regionBelow = function(r) {
    return r.nodeUp.prev.key;
  }, i.regionAbove = function(r) {
    return r.nodeUp.next.key;
  }, i.debugEvent = function(r) {
  }, i.addWinding = function(r, e) {
    r.winding += e.winding, r.Sym.winding += e.Sym.winding;
  }, i.edgeLeq = function(r, e, t) {
    var o = r.event, n = e.eUp, s = t.eUp;
    if (n.Dst === o)
      return s.Dst === o ? se.vertLeq(n.Org, s.Org) ? se.edgeSign(s.Dst, n.Org, s.Org) <= 0 : se.edgeSign(n.Dst, s.Org, n.Org) >= 0 : se.edgeSign(s.Dst, o, s.Org) <= 0;
    if (s.Dst === o)
      return se.edgeSign(n.Dst, o, n.Org) >= 0;
    var a = se.edgeEval(n.Dst, o, n.Org), l = se.edgeEval(s.Dst, o, s.Org);
    return a >= l;
  }, i.deleteRegion = function(r, e) {
    e.fixUpperEdge && ue(e.eUp.winding === 0), e.eUp.activeRegion = null, r.dict.delete(e.nodeUp);
  }, i.fixUpperEdge = function(r, e, t) {
    ue(e.fixUpperEdge), r.mesh.delete(e.eUp), e.fixUpperEdge = false, e.eUp = t, t.activeRegion = e;
  }, i.topLeftRegion = function(r, e) {
    var t = e.eUp.Org, o;
    do
      e = i.regionAbove(e);
    while (e.eUp.Org === t);
    if (e.fixUpperEdge) {
      if (o = r.mesh.connect(i.regionBelow(e).eUp.Sym, e.eUp.Lnext), o === null)
        return null;
      i.fixUpperEdge(r, e, o), e = i.regionAbove(e);
    }
    return e;
  }, i.topRightRegion = function(r) {
    var e = r.eUp.Dst;
    do
      r = i.regionAbove(r);
    while (r.eUp.Dst === e);
    return r;
  }, i.addRegionBelow = function(r, e, t) {
    var o = new al();
    return o.eUp = t, o.nodeUp = r.dict.insertBefore(e.nodeUp, o), o.fixUpperEdge = false, o.sentinel = false, o.dirty = false, t.activeRegion = o, o;
  }, i.isWindingInside = function(r, e) {
    switch (r.windingRule) {
      case Pe.ODD:
        return (e & 1) !== 0;
      case Pe.NONZERO:
        return e !== 0;
      case Pe.POSITIVE:
        return e > 0;
      case Pe.NEGATIVE:
        return e < 0;
      case Pe.ABS_GEQ_TWO:
        return e >= 2 || e <= -2;
    }
    throw new Error("Invalid winding rulle");
  }, i.computeWinding = function(r, e) {
    e.windingNumber = i.regionAbove(e).windingNumber + e.eUp.winding, e.inside = i.isWindingInside(r, e.windingNumber);
  }, i.finishRegion = function(r, e) {
    var t = e.eUp, o = t.Lface;
    o.inside = e.inside, o.anEdge = t, i.deleteRegion(r, e);
  }, i.finishLeftRegions = function(r, e, t) {
    for (var o, n = null, s = e, a = e.eUp; s !== t; ) {
      if (s.fixUpperEdge = false, n = i.regionBelow(s), o = n.eUp, o.Org != a.Org) {
        if (!n.fixUpperEdge) {
          i.finishRegion(r, s);
          break;
        }
        o = r.mesh.connect(a.Lprev, o.Sym), i.fixUpperEdge(r, n, o);
      }
      a.Onext !== o && (r.mesh.splice(o.Oprev, o), r.mesh.splice(a, o)), i.finishRegion(r, s), a = n.eUp, s = n;
    }
    return a;
  }, i.addRightEdges = function(r, e, t, o, n, s) {
    var a, l, c, u, m = true;
    c = t;
    do
      ue(se.vertLeq(c.Org, c.Dst)), i.addRegionBelow(r, e, c.Sym), c = c.Onext;
    while (c !== o);
    for (n === null && (n = i.regionBelow(e).eUp.Rprev), l = e, u = n; a = i.regionBelow(l), c = a.eUp.Sym, c.Org === u.Org; )
      c.Onext !== u && (r.mesh.splice(c.Oprev, c), r.mesh.splice(u.Oprev, c)), a.windingNumber = l.windingNumber - c.winding, a.inside = i.isWindingInside(r, a.windingNumber), l.dirty = true, !m && i.checkForRightSplice(r, l) && (i.addWinding(c, u), i.deleteRegion(r, l), r.mesh.delete(u)), m = false, l = a, u = c;
    l.dirty = true, ue(l.windingNumber - c.winding === a.windingNumber), s && i.walkDirtyRegions(r, l);
  }, i.spliceMergeVertices = function(r, e, t) {
    r.mesh.splice(e, t);
  }, i.vertexWeights = function(r, e, t) {
    var o = se.vertL1dist(e, r), n = se.vertL1dist(t, r), s = 0.5 * n / (o + n), a = 0.5 * o / (o + n);
    r.coords[0] += s * e.coords[0] + a * t.coords[0], r.coords[1] += s * e.coords[1] + a * t.coords[1], r.coords[2] += s * e.coords[2] + a * t.coords[2];
  }, i.getIntersectData = function(r, e, t, o, n, s) {
    e.coords[0] = e.coords[1] = e.coords[2] = 0, e.idx = -1, i.vertexWeights(e, t, o), i.vertexWeights(e, n, s);
  }, i.checkForRightSplice = function(r, e) {
    var t = i.regionBelow(e), o = e.eUp, n = t.eUp;
    if (se.vertLeq(o.Org, n.Org)) {
      if (se.edgeSign(n.Dst, o.Org, n.Org) > 0)
        return false;
      se.vertEq(o.Org, n.Org) ? o.Org !== n.Org && (r.pq.delete(o.Org.pqHandle), i.spliceMergeVertices(r, n.Oprev, o)) : (r.mesh.splitEdge(n.Sym), r.mesh.splice(o, n.Oprev), e.dirty = t.dirty = true);
    } else {
      if (se.edgeSign(o.Dst, n.Org, o.Org) < 0)
        return false;
      i.regionAbove(e).dirty = e.dirty = true, r.mesh.splitEdge(o.Sym), r.mesh.splice(n.Oprev, o);
    }
    return true;
  }, i.checkForLeftSplice = function(r, e) {
    var t = i.regionBelow(e), o = e.eUp, n = t.eUp, s;
    if (ue(!se.vertEq(o.Dst, n.Dst)), se.vertLeq(o.Dst, n.Dst)) {
      if (se.edgeSign(o.Dst, n.Dst, o.Org) < 0)
        return false;
      i.regionAbove(e).dirty = e.dirty = true, s = r.mesh.splitEdge(o), r.mesh.splice(n.Sym, s), s.Lface.inside = e.inside;
    } else {
      if (se.edgeSign(n.Dst, o.Dst, n.Org) > 0)
        return false;
      e.dirty = t.dirty = true, s = r.mesh.splitEdge(n), r.mesh.splice(o.Lnext, n.Sym), s.Rface.inside = e.inside;
    }
    return true;
  }, i.checkForIntersect = function(r, e) {
    var t = i.regionBelow(e), o = e.eUp, n = t.eUp, s = o.Org, a = n.Org, l = o.Dst, c = n.Dst, u, m, p = new ko(), d, f;
    if (ue(!se.vertEq(c, l)), ue(se.edgeSign(l, r.event, s) <= 0), ue(se.edgeSign(c, r.event, a) >= 0), ue(s !== r.event && a !== r.event), ue(!e.fixUpperEdge && !t.fixUpperEdge), s === a || (u = Math.min(s.t, l.t), m = Math.max(a.t, c.t), u > m))
      return false;
    if (se.vertLeq(s, a)) {
      if (se.edgeSign(c, s, a) > 0)
        return false;
    } else if (se.edgeSign(l, a, s) < 0)
      return false;
    return i.debugEvent(r), se.intersect(l, s, c, a, p), ue(Math.min(s.t, l.t) <= p.t), ue(p.t <= Math.max(a.t, c.t)), ue(Math.min(c.s, l.s) <= p.s), ue(p.s <= Math.max(a.s, s.s)), se.vertLeq(p, r.event) && (p.s = r.event.s, p.t = r.event.t), d = se.vertLeq(s, a) ? s : a, se.vertLeq(d, p) && (p.s = d.s, p.t = d.t), se.vertEq(p, s) || se.vertEq(p, a) ? (i.checkForRightSplice(r, e), false) : !se.vertEq(l, r.event) && se.edgeSign(l, r.event, p) >= 0 || !se.vertEq(c, r.event) && se.edgeSign(c, r.event, p) <= 0 ? c === r.event ? (r.mesh.splitEdge(o.Sym), r.mesh.splice(n.Sym, o), e = i.topLeftRegion(r, e), o = i.regionBelow(e).eUp, i.finishLeftRegions(r, i.regionBelow(e), t), i.addRightEdges(r, e, o.Oprev, o, o, true), true) : l === r.event ? (r.mesh.splitEdge(n.Sym), r.mesh.splice(o.Lnext, n.Oprev), t = e, e = i.topRightRegion(e), f = i.regionBelow(e).eUp.Rprev, t.eUp = n.Oprev, n = i.finishLeftRegions(r, t, null), i.addRightEdges(r, e, n.Onext, o.Rprev, f, true), true) : (se.edgeSign(l, r.event, p) >= 0 && (i.regionAbove(e).dirty = e.dirty = true, r.mesh.splitEdge(o.Sym), o.Org.s = r.event.s, o.Org.t = r.event.t), se.edgeSign(c, r.event, p) <= 0 && (e.dirty = t.dirty = true, r.mesh.splitEdge(n.Sym), n.Org.s = r.event.s, n.Org.t = r.event.t), false) : (r.mesh.splitEdge(o.Sym), r.mesh.splitEdge(n.Sym), r.mesh.splice(n.Oprev, o), o.Org.s = p.s, o.Org.t = p.t, o.Org.pqHandle = r.pq.insert(o.Org), i.getIntersectData(r, o.Org, s, l, a, c), i.regionAbove(e).dirty = e.dirty = t.dirty = true, false);
  }, i.walkDirtyRegions = function(r, e) {
    for (var t = i.regionBelow(e), o, n; ; ) {
      for (; t.dirty; )
        e = t, t = i.regionBelow(t);
      if (!e.dirty && (t = e, e = i.regionAbove(e), e === null || !e.dirty))
        return;
      if (e.dirty = false, o = e.eUp, n = t.eUp, o.Dst !== n.Dst && i.checkForLeftSplice(r, e) && (t.fixUpperEdge ? (i.deleteRegion(r, t), r.mesh.delete(n), t = i.regionBelow(e), n = t.eUp) : e.fixUpperEdge && (i.deleteRegion(r, e), r.mesh.delete(o), e = i.regionAbove(t), o = e.eUp)), o.Org !== n.Org)
        if (o.Dst !== n.Dst && !e.fixUpperEdge && !t.fixUpperEdge && (o.Dst === r.event || n.Dst === r.event)) {
          if (i.checkForIntersect(r, e))
            return;
        } else
          i.checkForRightSplice(r, e);
      o.Org === n.Org && o.Dst === n.Dst && (i.addWinding(n, o), i.deleteRegion(r, e), r.mesh.delete(o), e = i.regionAbove(t));
    }
  }, i.connectRightVertex = function(r, e, t) {
    var o, n = t.Onext, s = i.regionBelow(e), a = e.eUp, l = s.eUp, c = false;
    if (a.Dst !== l.Dst && i.checkForIntersect(r, e), se.vertEq(a.Org, r.event) && (r.mesh.splice(n.Oprev, a), e = i.topLeftRegion(r, e), n = i.regionBelow(e).eUp, i.finishLeftRegions(r, i.regionBelow(e), s), c = true), se.vertEq(l.Org, r.event) && (r.mesh.splice(t, l.Oprev), t = i.finishLeftRegions(r, s, null), c = true), c) {
      i.addRightEdges(r, e, t.Onext, n, n, true);
      return;
    }
    se.vertLeq(l.Org, a.Org) ? o = l.Oprev : o = a, o = r.mesh.connect(t.Lprev, o), i.addRightEdges(r, e, o, o.Onext, o.Onext, false), o.Sym.activeRegion.fixUpperEdge = true, i.walkDirtyRegions(r, e);
  }, i.connectLeftDegenerate = function(r, e, t) {
    var o, n, s, a, l;
    if (o = e.eUp, se.vertEq(o.Org, t)) {
      ue(false), i.spliceMergeVertices(r, o, t.anEdge);
      return;
    }
    if (!se.vertEq(o.Dst, t)) {
      r.mesh.splitEdge(o.Sym), e.fixUpperEdge && (r.mesh.delete(o.Onext), e.fixUpperEdge = false), r.mesh.splice(t.anEdge, o), i.sweepEvent(r, t);
      return;
    }
    ue(false), e = i.topRightRegion(e), l = i.regionBelow(e), s = l.eUp.Sym, n = a = s.Onext, l.fixUpperEdge && (ue(n !== s), i.deleteRegion(r, l), r.mesh.delete(s), s = n.Oprev), r.mesh.splice(t.anEdge, s), se.edgeGoesLeft(n) || (n = null), i.addRightEdges(r, e, s.Onext, a, n, true);
  }, i.connectLeftVertex = function(r, e) {
    var t, o, n, s, a, l, c = new al();
    if (c.eUp = e.anEdge.Sym, t = r.dict.search(c).key, o = i.regionBelow(t), !!o) {
      if (s = t.eUp, a = o.eUp, se.edgeSign(s.Dst, e, s.Org) === 0) {
        i.connectLeftDegenerate(r, t, e);
        return;
      }
      if (n = se.vertLeq(a.Dst, s.Dst) ? t : o, t.inside || n.fixUpperEdge) {
        if (n === t)
          l = r.mesh.connect(e.anEdge.Sym, s.Lnext);
        else {
          var u = r.mesh.connect(a.Dnext, e.anEdge);
          l = u.Sym;
        }
        n.fixUpperEdge ? i.fixUpperEdge(r, n, l) : i.computeWinding(r, i.addRegionBelow(r, t, l)), i.sweepEvent(r, e);
      } else
        i.addRightEdges(r, t, e.anEdge, e.anEdge, null, true);
    }
  }, i.sweepEvent = function(r, e) {
    r.event = e, i.debugEvent(r);
    for (var t = e.anEdge; t.activeRegion === null; )
      if (t = t.Onext, t === e.anEdge) {
        i.connectLeftVertex(r, e);
        return;
      }
    var o = i.topLeftRegion(r, t.activeRegion);
    ue(o !== null);
    var n = i.regionBelow(o), s = n.eUp, a = i.finishLeftRegions(r, n, null);
    a.Onext === s ? i.connectRightVertex(r, o, a) : i.addRightEdges(r, o, a.Onext, s, s, true);
  }, i.addSentinel = function(r, e, t, o) {
    var n = new al(), s = r.mesh.makeEdge();
    s.Org.s = t, s.Org.t = o, s.Dst.s = e, s.Dst.t = o, r.event = s.Dst, n.eUp = s, n.windingNumber = 0, n.inside = false, n.fixUpperEdge = false, n.sentinel = true, n.dirty = false, n.nodeUp = r.dict.insert(n);
  }, i.initEdgeDict = function(r) {
    r.dict = new mb(r, i.edgeLeq);
    var e = r.bmax[0] - r.bmin[0], t = r.bmax[1] - r.bmin[1], o = r.bmin[0] - e, n = r.bmax[0] + e, s = r.bmin[1] - t, a = r.bmax[1] + t;
    i.addSentinel(r, o, n, s), i.addSentinel(r, o, n, a);
  }, i.doneEdgeDict = function(r) {
    for (var e, t = 0; (e = r.dict.min().key) !== null; )
      e.sentinel || (ue(e.fixUpperEdge), ue(++t === 1)), ue(e.windingNumber === 0), i.deleteRegion(r, e);
  }, i.removeDegenerateEdges = function(r) {
    var e, t, o, n = r.mesh.eHead;
    for (e = n.next; e !== n; e = t)
      t = e.next, o = e.Lnext, se.vertEq(e.Org, e.Dst) && e.Lnext.Lnext !== e && (i.spliceMergeVertices(r, o, e), r.mesh.delete(e), e = o, o = e.Lnext), o.Lnext === e && (o !== e && ((o === t || o === t.Sym) && (t = t.next), r.mesh.delete(o)), (e === t || e === t.Sym) && (t = t.next), r.mesh.delete(e));
  }, i.initPriorityQ = function(r) {
    var e, t, o, n = 0;
    for (o = r.mesh.vHead, t = o.next; t !== o; t = t.next)
      n++;
    for (n += 8, e = r.pq = new pb(n, se.vertLeq), o = r.mesh.vHead, t = o.next; t !== o; t = t.next)
      t.pqHandle = e.insert(t);
    return t !== o ? false : (e.init(), true);
  }, i.donePriorityQ = function(r) {
    r.pq = null;
  }, i.removeDegenerateFaces = function(r, e) {
    var t, o, n;
    for (t = e.fHead.next; t !== e.fHead; t = o)
      o = t.next, n = t.anEdge, ue(n.Lnext !== n), n.Lnext.Lnext === n && (i.addWinding(n.Onext, n), r.mesh.delete(n));
    return true;
  }, i.computeInterior = function(r, e) {
    e === void 0 && (e = true);
    var t, o;
    if (i.removeDegenerateEdges(r), !i.initPriorityQ(r))
      return false;
    for (i.initEdgeDict(r); (t = r.pq.extractMin()) !== null; ) {
      for (; o = r.pq.min(), !(o === null || !se.vertEq(o, t)); )
        o = r.pq.extractMin(), i.spliceMergeVertices(r, t.anEdge, o.anEdge);
      i.sweepEvent(r, t);
    }
    return r.event = r.dict.min().key.eUp.Org, i.debugEvent(r), i.doneEdgeDict(r), i.donePriorityQ(r), i.removeDegenerateFaces(r, r.mesh) ? (e && r.mesh.check(), true) : false;
  }, i;
}();
var fb = function() {
  function i() {
    this.mesh = new bm(), this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = Pe.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
  }
  return i.prototype.dot_ = function(r, e) {
    return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
  }, i.prototype.normalize_ = function(r) {
    var e = r[0] * r[0] + r[1] * r[1] + r[2] * r[2];
    if (!e)
      throw "Zero-size vector!";
    e = Math.sqrt(e), r[0] /= e, r[1] /= e, r[2] /= e;
  }, i.prototype.longAxis_ = function(r) {
    var e = 0;
    return Math.abs(r[1]) > Math.abs(r[0]) && (e = 1), Math.abs(r[2]) > Math.abs(r[e]) && (e = 2), e;
  }, i.prototype.computeNormal_ = function(r) {
    var e, t, o, n, s, a, l = [0, 0, 0], c = [0, 0, 0], u = [0, 0, 0], m = [0, 0, 0], p = [0, 0, 0], d = [null, null, null], f = [null, null, null], g = this.mesh.vHead;
    e = g.next;
    for (var x = 0; x < 3; ++x)
      n = e.coords[x], c[x] = n, f[x] = e, l[x] = n, d[x] = e;
    for (e = g.next; e !== g; e = e.next)
      for (var y = 0; y < 3; ++y)
        n = e.coords[y], n < c[y] && (c[y] = n, f[y] = e), n > l[y] && (l[y] = n, d[y] = e);
    var v = 0;
    if (l[1] - c[1] > l[0] - c[0] && (v = 1), l[2] - c[2] > l[v] - c[v] && (v = 2), c[v] >= l[v]) {
      r[0] = 0, r[1] = 0, r[2] = 1;
      return;
    }
    for (a = 0, t = f[v], o = d[v], u[0] = t.coords[0] - o.coords[0], u[1] = t.coords[1] - o.coords[1], u[2] = t.coords[2] - o.coords[2], e = g.next; e !== g; e = e.next)
      m[0] = e.coords[0] - o.coords[0], m[1] = e.coords[1] - o.coords[1], m[2] = e.coords[2] - o.coords[2], p[0] = u[1] * m[2] - u[2] * m[1], p[1] = u[2] * m[0] - u[0] * m[2], p[2] = u[0] * m[1] - u[1] * m[0], s = p[0] * p[0] + p[1] * p[1] + p[2] * p[2], s > a && (a = s, r[0] = p[0], r[1] = p[1], r[2] = p[2]);
    a <= 0 && (r[0] = r[1] = r[2] = 0, r[this.longAxis_(u)] = 1);
  }, i.prototype.checkOrientation_ = function() {
    for (var r = this.mesh.fHead, e, t = this.mesh.vHead, o, n = 0, s = r.next; s !== r; s = s.next)
      if (o = s.anEdge, !(o.winding <= 0))
        do
          n += (o.Org.s - o.Dst.s) * (o.Org.t + o.Dst.t), o = o.Lnext;
        while (o !== s.anEdge);
    if (n < 0) {
      for (e = t.next; e !== t; e = e.next)
        e.t = -e.t;
      this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
    }
  }, i.prototype.projectPolygon_ = function() {
    var r = this.mesh.vHead, e = [0, 0, 0], t, o, n = false;
    e[0] = this.normal[0], e[1] = this.normal[1], e[2] = this.normal[2], !e[0] && !e[1] && !e[2] && (this.computeNormal_(e), n = true), t = this.sUnit, o = this.tUnit;
    var s = this.longAxis_(e);
    t[s] = 0, t[(s + 1) % 3] = 1, t[(s + 2) % 3] = 0, o[s] = 0, o[(s + 1) % 3] = 0, o[(s + 2) % 3] = e[s] > 0 ? 1 : -1;
    for (var a = r.next; a !== r; a = a.next)
      a.s = this.dot_(a.coords, t), a.t = this.dot_(a.coords, o);
    n && this.checkOrientation_();
    for (var l = true, c = r.next; c !== r; c = c.next)
      l ? (this.bmin[0] = this.bmax[0] = c.s, this.bmin[1] = this.bmax[1] = c.t, l = false) : (c.s < this.bmin[0] && (this.bmin[0] = c.s), c.s > this.bmax[0] && (this.bmax[0] = c.s), c.t < this.bmin[1] && (this.bmin[1] = c.t), c.t > this.bmax[1] && (this.bmax[1] = c.t));
  }, i.prototype.addWinding_ = function(r, e) {
    r.winding += e.winding, r.Sym.winding += e.Sym.winding;
  }, i.prototype.tessellateMonoRegion_ = function(r, e) {
    var t, o;
    if (t = e.anEdge, !(t.Lnext !== t && t.Lnext.Lnext !== t))
      throw "Mono region invalid";
    for (; se.vertLeq(t.Dst, t.Org); t = t.Lprev)
      ;
    for (; se.vertLeq(t.Org, t.Dst); t = t.Lnext)
      ;
    o = t.Lprev;
    for (var n = void 0; t.Lnext !== o; )
      if (se.vertLeq(t.Dst, o.Org)) {
        for (; o.Lnext !== t && (se.edgeGoesLeft(o.Lnext) || se.edgeSign(o.Org, o.Dst, o.Lnext.Dst) <= 0); )
          n = r.connect(o.Lnext, o), o = n.Sym;
        o = o.Lprev;
      } else {
        for (; o.Lnext !== t && (se.edgeGoesRight(t.Lprev) || se.edgeSign(t.Dst, t.Org, t.Lprev.Org) >= 0); )
          n = r.connect(t, t.Lprev), t = n.Sym;
        t = t.Lnext;
      }
    if (o.Lnext === t)
      throw "Mono region invalid";
    for (; o.Lnext.Lnext !== t; )
      n = r.connect(o.Lnext, o), o = n.Sym;
    return true;
  }, i.prototype.tessellateInterior_ = function(r) {
    for (var e, t = r.fHead.next; t !== r.fHead; t = e)
      if (e = t.next, t.inside && !this.tessellateMonoRegion_(r, t))
        return false;
    return true;
  }, i.prototype.discardExterior_ = function(r) {
    for (var e, t = r.fHead.next; t !== r.fHead; t = e)
      e = t.next, t.inside || r.zapFace(t);
  }, i.prototype.setWindingNumber_ = function(r, e, t) {
    for (var o, n = r.eHead.next; n !== r.eHead; n = o)
      o = n.next, n.Rface.inside !== n.Lface.inside ? n.winding = n.Lface.inside ? e : -e : t ? r.delete(n) : n.winding = 0;
  }, i.prototype.getNeighbourFace_ = function(r) {
    return !r.Rface || !r.Rface.inside ? -1 : r.Rface.n;
  }, i.prototype.outputPolymesh_ = function(r, e, t, o) {
    var n, s = 0, a = 0, l;
    t > 3 && r.mergeConvexFaces(t);
    for (var c = r.vHead.next; c !== r.vHead; c = c.next)
      c.n = -1;
    for (var u = r.fHead.next; u !== r.fHead; u = u.next)
      if (u.n = -1, !!u.inside) {
        n = u.anEdge, l = 0;
        do {
          var c = n.Org;
          c.n === -1 && (c.n = a, a++), l++, n = n.Lnext;
        } while (n !== u.anEdge);
        if (l > t)
          throw "Face vertex greater that support polygon";
        u.n = s, ++s;
      }
    this.elementCount = s, e === Fe.CONNECTED_POLYGONS && (s *= 2), this.elements = [], this.elements.length = s * t, this.vertexCount = a, this.vertices = [], this.vertices.length = a * o, this.vertexIndices = [], this.vertexIndices.length = a;
    for (var c = r.vHead.next; c !== r.vHead; c = c.next)
      if (c.n !== -1) {
        var m = c.n * o;
        this.vertices[m + 0] = c.coords[0], this.vertices[m + 1] = c.coords[1], o > 2 && (this.vertices[m + 2] = c.coords[2]), this.vertexIndices[c.n] = c.idx;
      }
    for (var p = 0, u = r.fHead.next; u !== r.fHead; u = u.next)
      if (!!u.inside) {
        n = u.anEdge, l = 0;
        do {
          var c = n.Org;
          this.elements[p++] = c.n, l++, n = n.Lnext;
        } while (n !== u.anEdge);
        for (var d = l; d < t; ++d)
          this.elements[p++] = -1;
        if (e === Fe.CONNECTED_POLYGONS) {
          n = u.anEdge;
          do
            this.elements[p++] = this.getNeighbourFace_(n), n = n.Lnext;
          while (n !== u.anEdge);
          for (var f = l; f < t; ++f)
            this.elements[p++] = -1;
        }
      }
  }, i.prototype.outputContours_ = function(r, e) {
    var t, o, n = 0, s = 0;
    this.vertexCount = 0, this.elementCount = 0;
    for (var a = r.fHead.next; a !== r.fHead; a = a.next)
      if (!!a.inside) {
        o = t = a.anEdge;
        do
          this.vertexCount++, t = t.Lnext;
        while (t !== o);
        this.elementCount++;
      }
    this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * e, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
    var l = 0, c = 0, u = 0;
    n = 0;
    for (var a = r.fHead.next; a !== r.fHead; a = a.next)
      if (!!a.inside) {
        s = 0, o = t = a.anEdge;
        do
          this.vertices[l++] = t.Org.coords[0], this.vertices[l++] = t.Org.coords[1], e > 2 && (this.vertices[l++] = t.Org.coords[2]), this.vertexIndices[c++] = this.vertexIdCallback ? this.vertexIdCallback(t) : t.Org.idx, s++, t = t.Lnext;
        while (t !== o);
        this.elements[u++] = n, this.elements[u++] = s, n += s;
      }
  }, i.prototype.addContour = function(r, e) {
    this.mesh === null && (this.mesh = new bm()), r < 2 && (r = 2), r > 3 && (r = 3);
    for (var t = null, o = 0; o < e.length; o += r)
      t === null ? (t = this.mesh.makeEdge(), this.mesh.splice(t, t.Sym)) : (this.mesh.splitEdge(t), t = t.Lnext), t.Org.coords[0] = e[o + 0], t.Org.coords[1] = e[o + 1], r > 2 ? t.Org.coords[2] = e[o + 2] : t.Org.coords[2] = 0, t.Org.idx = this.vertexIndexCounter++, this.edgeCreateCallback && this.edgeCreateCallback(t), t.winding = 1, t.Sym.winding = -1;
  }, i.prototype.tesselate = function(r, e, t, o, n, s) {
    if (r === void 0 && (r = Pe.ODD), e === void 0 && (e = Fe.POLYGONS), s === void 0 && (s = true), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, n && (this.normal[0] = n[0], this.normal[1] = n[1], this.normal[2] = n[2]), this.windingRule = r, o < 2 && (o = 2), o > 3 && (o = 3), !this.mesh)
      return false;
    this.projectPolygon_(), db.computeInterior(this, s);
    var a = this.mesh;
    return e === Fe.BOUNDARY_CONTOURS ? this.setWindingNumber_(a, 1, true) : this.tessellateInterior_(a), s && a.check(), e === Fe.BOUNDARY_CONTOURS ? this.outputContours_(a, o) : this.outputPolymesh_(a, e, t, o), true;
  }, i;
}();
function Zr(i) {
  var r = i.windingRule, e = r === void 0 ? Pe.ODD : r, t = i.elementType, o = t === void 0 ? Fe.POLYGONS : t, n = i.polySize, s = n === void 0 ? 3 : n, a = i.vertexSize, l = a === void 0 ? 2 : a, c = i.normal, u = c === void 0 ? [0, 0, 1] : c, m = i.contours, p = m === void 0 ? [] : m, d = i.strict, f = d === void 0 ? true : d, g = i.debug, x = g === void 0 ? false : g;
  if (!p && f)
    throw new Error("Contours can't be empty");
  if (!!p) {
    var y = new fb();
    i.edgeCreateCallback && (y.edgeCreateCallback = i.edgeCreateCallback), i.vertexIdCallback && (y.vertexIdCallback = i.vertexIdCallback);
    for (var v = 0; v < p.length; v++)
      y.addContour(l || 2, p[v]);
    return y.tesselate(e, o, s, l, u, f), { vertices: y.vertices, vertexIndices: y.vertexIndices, vertexCount: y.vertexCount, elements: y.elements, elementCount: y.elementCount, mesh: x ? y.mesh : void 0 };
  }
}
var o3 = Pe.ODD;
var n3 = Pe.NONZERO;
var i3 = Pe.POSITIVE;
var s3 = Pe.NEGATIVE;
var a3 = Pe.ABS_GEQ_TWO;
var l3 = Fe.POLYGONS;
var c3 = Fe.CONNECTED_POLYGONS;
var u3 = Fe.BOUNDARY_CONTOURS;
var Ho = class extends BufferGeometry {
  constructor(e, t = 12, o = {}) {
    super();
    var _a2, _b2, _c2;
    this.type = "ShapeGeometry";
    this.windingRule = Pe.ODD;
    this.elementType = Fe.POLYGONS;
    this.polySize = 3;
    this.vertexSize = 2;
    this.strict = true;
    this._shape = e, this._curveSegments = t, this._triangulationOptions = Object.assign({ windingRule: Pe.ODD, elementType: Fe.POLYGONS, polySize: 3, vertexSize: 2, strict: true }, o);
    let n = this._shape.extractShapePointsToFlatArray([], this._curveSegments), s = this._shape.shapeHoles.map((f) => f.extractShapePointsToFlatArray([], this._curveSegments)), a, l = true, c = true, u, m;
    for (let f = 0, g = n.length / 2; f < g; f++) {
      let x = f * 2, y = n[x + 0], v = n[x + 1];
      if (u !== void 0 && y !== u && (l = false), m !== void 0 && v !== m && (c = false), u = y, m = v, !l && !c)
        break;
    }
    !l && !c && (a = Zr({ contours: [n, ...s], windingRule: this._triangulationOptions.windingRule, elementType: this._triangulationOptions.elementType, polySize: this._triangulationOptions.polySize, vertexSize: this._triangulationOptions.vertexSize, strict: this._triangulationOptions.strict }));
    let p = (_a2 = a == null ? void 0 : a.vertexCount) != null ? _a2 : 1, d = (_b2 = a == null ? void 0 : a.elementCount) != null ? _b2 : 1;
    if (this._positionAttribute = new BufferAttribute(new Float32Array(p * 3), 3), this._normalAttribute = new BufferAttribute(new Float32Array(p * 3), 3), this._uvAttribute = new BufferAttribute(new Float32Array(p * 2), 2), this._indexAttribute = new BufferAttribute(new Uint32Array(d * 3), 1), a) {
      let f = 1 / 0, g = -1 / 0, x = 1 / 0, y = -1 / 0;
      for (let S = 0, b = p; S < b; S++) {
        let E = S * 2, w = a.vertices[E + 0], h = a.vertices[E + 1];
        w < f && (f = w), w > g && (g = w), h < x && (x = h), h > y && (y = h);
      }
      let v = g - f, P = y - x;
      for (let S = 0, b = p; S < b; S++) {
        let E = S * 2, w = a.vertices[E + 0], h = a.vertices[E + 1], _ = (w - f) / v, N = (h - x) / P;
        this._positionAttribute.setXYZ(S, w, h, 0), this._normalAttribute.setXYZ(S, 0, 0, 1), this._uvAttribute.setXY(S, _, N);
      }
      for (let S = 0, b = d; S < b; S++) {
        let E = S * 3, w = a.elements[E + 0], h = a.elements[E + 1], _ = a.elements[E + 2];
        this._indexAttribute.setX(E + 0, w), this._indexAttribute.setX(E + 1, h), this._indexAttribute.setX(E + 2, _);
      }
    }
    this.setAttribute("position", this._positionAttribute), this.setAttribute("normal", this._normalAttribute), this.setAttribute("uv", this._uvAttribute), this.setIndex(this._indexAttribute), this.setDrawRange(0, ((_c2 = a == null ? void 0 : a.elementCount) != null ? _c2 : 1) * 3);
  }
  clone() {
    let e = new Ho(this._shape, this._curveSegments);
    return e.userData = Cn(this.userData), e;
  }
};
var Bs = class {
  constructor(r = 256, e = false) {
    this.capacity = r, this.size = 0, this.debug = e, this.debug && console.log(`allocating with cap ${r}`);
    let t = r * Bs.eSize;
    this.buffer = new ArrayBuffer(t);
    let o = Float32Array.BYTES_PER_ELEMENT, n = 0;
    this.positions = new Float32Array(this.buffer, n * o, 3 * r), n += 3 * r, this.normals = new Float32Array(this.buffer, n * o, 3 * r), n += 3 * r, this.uvs = new Float32Array(this.buffer, n * o, 2 * r);
  }
  realloc(r, e = false) {
    if (r < this.size)
      throw Error("cannot shrink buffer");
    if (r <= this.capacity && !e)
      return;
    this.debug && console.log(`resizing from ${this.capacity} \u2192 ${r}`);
    let t = r * Bs.eSize, o = new ArrayBuffer(t), n = Float32Array.BYTES_PER_ELEMENT, s = 0, a = new Float32Array(o, s * n, 3 * r);
    s += 3 * r;
    let l = new Float32Array(o, s * n, 3 * r);
    s += 3 * r;
    let c = new Float32Array(o, s * n, 2 * r);
    a.set(this.positions.slice(0, this.size * 3)), l.set(this.normals.slice(0, this.size * 3)), c.set(this.uvs.slice(0, this.size * 2)), this.buffer = o, this.positions = a, this.normals = l, this.uvs = c, this.capacity = r;
  }
  get(r = 1) {
    let e = this.size + r;
    if (e > this.capacity) {
      let o = this.capacity;
      for (; e > o; )
        o *= 2;
      this.realloc(o);
    }
    let t = this.size;
    return this.size = e, t;
  }
  reserve(r) {
    let e = this.size + r;
    e > this.capacity && this.realloc(e);
  }
  shrink() {
    this.debug && console.log(`shrinking ${this.capacity} \u2192 ${this.size}`), this.realloc(this.size, true);
  }
};
var Un = Bs;
Un.eSize = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT;
var ll = (i, r) => ([e, t]) => (t < e && (t += r), (i >= e ? i : i + r) <= t);
var Wo = class extends BufferGeometry {
  constructor(e, t, o = 0, n = 12, s = 3) {
    super();
    this.type = "ShapeGeometry";
    this.vertexCache = {};
    this._shape = e, this._depth = t, this._bevel = o, this._curveSegments = n, this._bevelSegmentsInput = s, o <= 0 ? (this._bevelSize = 0, this._bevelSegments = 0) : (this._bevelSize = Math.min(o, t / 2 - 1e-12), this._bevelSegments = Math.floor(s));
    let a = this._shape.extractShapePointsToFlatArray([], n), l = this._shape.shapeHoles.map((w) => {
      let h = w.extractShapePointsToFlatArray([], n), _ = [];
      for (let N = h.length - 1; N >= 1; N -= 2) {
        let I = h[N - 1], L = h[N - 0];
        _.push(I, L);
      }
      return _;
    }), c = Zr({ windingRule: Pe.ODD, elementType: Fe.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [a] }), u = Zr({ windingRule: Pe.ODD, elementType: Fe.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [...l] });
    if (!c)
      throw new Error("error generating geometry");
    let m = c.elementCount;
    if (u) {
      c.elementCount += u.elementCount;
      for (let w = 0; w < u.elements.length; w++) {
        let h = u.elements[w], _ = w % 2 === 0 ? c.vertexCount : 0;
        c.elements.push(h + _);
      }
      for (let w = 0; w < u.vertexIndices.length; w++) {
        let h = u.vertexIndices[w], _ = c.vertexCount;
        c.vertexIndices.push(h + _);
      }
      for (let w = 0; w < u.vertices.length; w++) {
        let h = u.vertices[w];
        c.vertices.push(h);
      }
    }
    let p = 1 / 0, d = -1 / 0, f = 1 / 0, g = -1 / 0;
    for (let w = 0, h = c.vertexCount; w < h; w++) {
      let _ = w * 2, N = c.vertices[_ + 0], I = c.vertices[_ + 1];
      N < p && (p = N), N > d && (d = N), I < f && (f = I), I > g && (g = I);
    }
    this._minX = p, this._minY = f, this._width = d - p, this._height = g - f;
    let x = c.vertexCount * 2 * (2 + this._bevelSegments);
    this._buffer = new Un(x);
    let y = [], v = [];
    for (let w = c.elementCount - 1; w >= 0; w--) {
      let h = w >= m, _ = w * 2, N = c.elements[_ + 0], I = c.elements[_ + 1], L = N + I, A = { start: N, count: I, normals: [], continuous: [], concave: [] }, k = N, q = L - 1, oe = N + 1, ce = this._shape.roundedCurves.length;
      do {
        let z = k - N, B = c.vertices[q * 2 + 0], D = c.vertices[q * 2 + 1], M = c.vertices[k * 2 + 0], G = c.vertices[k * 2 + 1], Q = c.vertices[oe * 2 + 0], j = c.vertices[oe * 2 + 1], V = M - B, F = G - D, O = Math.sqrt(V * V + F * F);
        V /= O, F /= O;
        let $ = M - Q, Z = G - j, ee = Math.sqrt($ * $ + Z * Z);
        $ /= ee, Z /= ee, A.normals[z * 2 + 0] = -Z, A.normals[z * 2 + 1] = $, A.concave[z] = V * Z - F * $ > 0;
        let H = c.vertexIndices[k];
        if (Array.isArray(H))
          A.continuous[z] = false;
        else {
          let [J, X] = this._shape.getCurveIndexFromVertexId(H - 1, true);
          if (X > 0 && X < 1)
            A.continuous[z] = true;
          else {
            let re = X === 1 ? J + 1 : J - 1;
            re = (re + ce) % ce;
            let le = X === 1 ? 0 : 1, ne = this._shape.roundedCurves[J].getTangent(X), de = this._shape.roundedCurves[re].getTangent(le);
            A.continuous[z] = ne.dot(de) > 0.95;
          }
        }
        h && (A.normals[z * 2 + 0] *= -1, A.normals[z * 2 + 1] *= -1), [q, k, oe] = [k, oe, oe + 1], oe >= L && (oe -= I);
      } while (oe !== N + 1);
      let ie = [];
      ie.push({ bevelI: 0, angle: 0, size: 0, boundary: { vertices: c.vertices.slice(N * 2, L * 2), vertexCount: I, vertexIndices: new Array(I).fill(true).map((z, B) => [B, B]), elements: [0, I], elementCount: 1, mesh: null }, reverseMap: [], insetPoints: c.vertices.slice(N * 2, L * 2) });
      for (let z = 1; z <= this._bevelSegments; z++) {
        let B = z / this._bevelSegments * Math.PI / 2, D = (1 - Math.cos(B)) * this._bevelSize, M = [], G = [], Q = [], j = [], V = 0;
        for (let O = 0; O < I; O++) {
          let $ = O * 2, Z = (O - 1 + I) % I * 2, ee = c.vertices[A.start * 2 + $ + 0], H = c.vertices[A.start * 2 + $ + 1], J = -A.normals[Z + 0] * D, X = -A.normals[Z + 1] * D, re = -A.normals[$ + 0] * D, le = -A.normals[$ + 1] * D;
          if (A.concave[O] || !A.concave[O] && h) {
            let ne = Math.atan2(X, J), de = Math.atan2(le, re);
            de > ne && (de -= Math.PI * 2);
            let Me = de - ne;
            if (A.continuous[O] || h) {
              let he = ne + Me / 2, Be = Math.cos(he) * D, be = Math.sin(he) * D;
              M[2 * V + 0] = ee + Be * (h ? -1 : 1), M[2 * V + 1] = H + be * (h ? -1 : 1), j[V] = O, V++;
            } else {
              let he = Math.max(1, Math.floor(n / 4 * Math.abs(Me) / Math.PI));
              for (let Be = 0; Be <= he; Be++) {
                let be = ne + Me * (Be / he), ct = Math.cos(be) * D, St = Math.sin(be) * D;
                M[2 * V + 0] = ee + ct, M[2 * V + 1] = H + St, j[V] = O, V++;
              }
            }
          } else
            M[2 * V + 0] = ee + J, M[2 * V + 1] = H + X, j[V] = O, G[O] = V, V++, M[2 * V + 0] = ee, M[2 * V + 1] = H, j[V] = O, V++, M[2 * V + 0] = ee + re, M[2 * V + 1] = H + le, j[V] = O, Q[O] = V, V++;
        }
        let F = Zr({ windingRule: Pe.POSITIVE, elementType: Fe.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [M], edgeCreateCallback: (O) => {
          let Z = O.Org.idx, ee = j[Z], H = j[(Z + 1) % j.length];
          O.idx = [ee, H], O.Sym.idx = [H, ee];
        }, vertexIdCallback: (O) => {
          let $ = O.Lprev.idx;
          return [$ ? $[1] : 0, O.idx[0]];
        } });
        if (!F)
          throw console.log("Error"), new Error(`error generating bevel geometry for ${z}'th loop`);
        if (!F.vertexCount)
          break;
        for (let O = 0; O < F.vertexIndices.length; O++) {
          let [$, Z] = F.vertexIndices[O];
          if ($ === Z)
            continue;
          let ee = Z;
          Z < $ && (ee += I);
          for (let H = $; H < ee; H++) {
            let J = H % I, X = (H + 1) % I;
            if (!A.continuous[J] || !A.continuous[X]) {
              F.vertexIndices[O] = [$, J], F.vertexIndices.splice(O + 1, 0, [X, Z]), F.vertices.splice((O + 1) * 2, 0, F.vertices[O * 2], F.vertices[O * 2 + 1]);
              break;
            }
          }
        }
        ie.push({ bevelI: z, angle: B, size: D, boundary: F, reverseMap: j, insetPoints: M });
      }
      let K = (z, B, D) => {
        let M = 0, G = z.boundary.vertexIndices.length;
        for (; M < G && D(z.boundary.vertexIndices[B]); )
          B = (B + 1) % G, M++;
        return M;
      }, U = y.length;
      for (let z = 1; z < ie.length; z++) {
        let B = ie[z - 1], D = ie[z], M = B.boundary.vertexIndices.length, G = D.boundary.vertexIndices.length;
        if (!M || !G)
          break;
        let Q = A.concave.length, j = 0, V = ll(j, I);
        for (; !B.boundary.vertexIndices.filter(V).length || !D.boundary.vertexIndices.filter(V).length; )
          j++, V = ll(j, I);
        let F = B.boundary.vertexIndices.findIndex(V), O = D.boundary.vertexIndices.findIndex(V);
        do
          F = (F + 1) % M;
        while (V(B.boundary.vertexIndices[F]));
        do
          O = (O + 1) % G;
        while (V(D.boundary.vertexIndices[O]));
        j = (j + 1) % I;
        let $ = j, Z = this.buildBevelVert(A, B, (F - 1 + M) % M), ee = this.buildBevelVert(A, D, (O - 1 + G) % G), H = Z, J = ee, X, re, le = false;
        do {
          V = ll(j, I);
          let ne = K(B, F, V), de = K(D, O, V), Me = le;
          if (le = false, ne && !de) {
            for (let he = 0; he < ne; he++)
              X = this.buildBevelVert(A, B, (F + he) % M, he / (ne - 1)), y.push(H.topN, X.topP, J.topN), y.push(X.bottomP, H.bottomN, J.bottomN), H = X;
            le = true;
          } else if (!ne && de)
            for (let he = 0; he < de; he++)
              re = this.buildBevelVert(A, D, (O + he) % G, he / (de - 1)), y.push(J.topN, H.topP, re.topP), y.push(H.bottomP, J.bottomN, re.bottomP), J = re;
          else if (ne && de)
            if (X = this.buildBevelVert(A, B, F, 0), re = this.buildBevelVert(A, D, O, 0), Me ? (y.push(H.topN, re.topP, J.topN), y.push(H.topN, X.topP, re.topP), y.push(re.bottomP, H.bottomN, J.bottomN), y.push(re.bottomP, X.bottomP, H.bottomN)) : (y.push(J.topN, H.topN, X.topP), y.push(J.topN, X.topP, re.topP), y.push(X.bottomP, H.bottomN, J.bottomN), y.push(X.bottomP, J.bottomN, re.bottomP)), H = X, J = re, ne === de)
              for (let he = 1; he < ne; he++)
                X = this.buildBevelVert(A, B, (F + he) % M, he / (ne - 1)), re = this.buildBevelVert(A, D, (O + he) % G, he / (de - 1)), y.push(H.topN, X.topP, J.topN), y.push(J.topN, X.topP, re.topP), y.push(X.bottomP, H.bottomN, J.bottomN), y.push(X.bottomP, J.bottomN, re.bottomP), H = X, J = re;
            else if (ne > de) {
              let he = ne / de, Be = 0;
              for (let be = 1; be < ne; be++)
                X = this.buildBevelVert(A, B, (F + be) % M, be / (ne - 1)), y.push(H.topN, X.topP, J.topN), y.push(X.bottomP, H.bottomN, J.bottomN), H = X, be > (Be + 1) * he && (Be++, re = this.buildBevelVert(A, D, (O + Be) % G, Be / (de - 1)), y.push(J.topN, X.topP, re.topP), y.push(X.bottomP, J.bottomN, re.bottomP), J = re);
            } else {
              let he = de / ne, Be = 0;
              for (let be = 1; be < de; be++)
                re = this.buildBevelVert(A, D, (O + be) % G, be / (de - 1)), y.push(J.topN, X.topP, re.topP), y.push(X.bottomP, J.bottomN, re.bottomP), J = re, be > (Be + 1) * he && (Be++, X = this.buildBevelVert(A, B, (F + Be) % M, Be / (ne - 1)), y.push(H.topN, X.topP, J.topN), y.push(X.bottomP, H.bottomN, J.bottomN), H = X);
            }
          F = (F + ne) % M, O = (O + de) % G, j = (j + 1) % Q;
        } while (j !== $);
      }
      {
        let z = ie[0];
        for (let B = 0, D = z.boundary.vertexCount; B < D; B++) {
          let M = this.buildBevelVert(A, z, B), G = this.buildBevelVert(A, z, (B + 1) % D);
          y.push(G.topP, M.topN, M.bottomN), y.push(G.topP, M.bottomN, G.bottomP);
        }
      }
      if (h) {
        let z = [];
        for (let B = y.length - 1; B >= U + 2; B -= 3) {
          let D = y[B - 2], M = y[B - 1], G = y[B - 0];
          z.push(G, M, D);
        }
        y.splice(U, y.length - U, ...z);
      }
      if (h) {
        let z = [];
        for (let B = ie[ie.length - 1].boundary.vertices.length - 1; B >= 1; B -= 2) {
          let D = ie[ie.length - 1].boundary.vertices[B - 1], M = ie[ie.length - 1].boundary.vertices[B - 0];
          z.push(D, M);
        }
        v.push(z);
      }
      if (!h) {
        let z = ie[ie.length - 1], B = Zr({ windingRule: ie.length > 1 ? Pe.POSITIVE : Pe.ODD, elementType: Fe.POLYGONS, vertexSize: 2, strict: true, contours: [z.insetPoints, ...v] });
        if (!B)
          throw new Error("Error generating geometry for surface");
        l.length === 0 && Object.assign(this, { capStartIndex: y.length });
        for (let D = 0; D < B.elementCount * 3; D += 3) {
          let M = this.buildSurfaceVert(B, B.elements[D + 0]), G = this.buildSurfaceVert(B, B.elements[D + 1]), Q = this.buildSurfaceVert(B, B.elements[D + 2]);
          y.push(M.top, G.top, Q.top), y.push(Q.bottom, G.bottom, M.bottom);
        }
      }
      this.vertexCache = {};
    }
    this._buffer.shrink();
    let P = new BufferAttribute(Uint32Array.from(y), 1), S = new BufferAttribute(this._buffer.positions, 3), b = new BufferAttribute(this._buffer.normals, 3), E = new BufferAttribute(this._buffer.uvs, 2);
    S.needsUpdate = true, b.needsUpdate = true, E.needsUpdate = true, P.needsUpdate = true, this.setAttribute("position", S), this.setAttribute("normal", b), this.setAttribute("uv", E), this.setIndex(P);
  }
  buildSurfaceVert(e, t) {
    let o = t.toString();
    if (o in this.vertexCache)
      return this.vertexCache[o];
    let n = e.vertices[t * 2 + 0], s = e.vertices[t * 2 + 1], a = (n - this._minX) / this._width, l = (s - this._minY) / this._height, c = this._buffer.get(2), u = c * 3, m = c * 2, p = { top: c + 0, bottom: c + 1 };
    return this._buffer.positions[u + 0] = n, this._buffer.positions[u + 1] = s, this._buffer.positions[u + 2] = this._depth, this._buffer.normals[u + 0] = 0, this._buffer.normals[u + 1] = 0, this._buffer.normals[u + 2] = 1, this._buffer.uvs[m + 0] = a, this._buffer.uvs[m + 1] = l, this._buffer.positions[u + 3] = n, this._buffer.positions[u + 4] = s, this._buffer.positions[u + 5] = 0, this._buffer.normals[u + 3] = 0, this._buffer.normals[u + 4] = 0, this._buffer.normals[u + 5] = -1, this._buffer.uvs[m + 2] = a, this._buffer.uvs[m + 3] = l, this.vertexCache[o] = p, p;
  }
  buildBevelVert(e, t, o, n = 1) {
    let s = `${t.bevelI}:${o}`;
    if (s in this.vertexCache)
      return this.vertexCache[s];
    let [a, l] = t.boundary.vertexIndices[o], c, u, m, p;
    a !== l ? (u = a, c = l, p = false, m = e.continuous[u] && e.continuous[c]) : (c = a, u = (c - 1 + e.count) % e.count, p = e.concave[c] && t.bevelI > 0, m = e.continuous[c] || p);
    let d = Math.cos(t.angle), f = Math.sin(t.angle), g = o * 2, x = c * 2, y = u * 2, v = t.boundary.vertices[g + 0], P = t.boundary.vertices[g + 1], S = (1 - f) * this._bevelSize, b = (v - this._minX) / this._width, E = (P - this._minY) / this._height, w = e.normals[x + 0], h = e.normals[x + 1], _ = e.normals[y + 0], N = e.normals[y + 1];
    if (p) {
      let q = _ - w, oe = N - h;
      w = w + q * (1 - n), h = h + oe * (1 - n);
      let ce = Math.sqrt(w * w + h * h);
      w /= ce, h /= ce;
    }
    let I = this._buffer.get(m ? 2 : 4), L = I * 3, A = I * 2, k = { i: o, fi: c, topP: I + 0, topN: I + 0, bottomP: I + 1, bottomN: I + 1 };
    return this._buffer.positions[L + 0] = v, this._buffer.positions[L + 1] = P, this._buffer.positions[L + 2] = this._depth - S, this._buffer.normals[L + 0] = w * d, this._buffer.normals[L + 1] = h * d, this._buffer.normals[L + 2] = f, this._buffer.uvs[A + 0] = b, this._buffer.uvs[A + 1] = E, this._buffer.positions[L + 3] = v, this._buffer.positions[L + 4] = P, this._buffer.positions[L + 5] = S, this._buffer.normals[L + 3] = w * d, this._buffer.normals[L + 4] = h * d, this._buffer.normals[L + 5] = -f, this._buffer.uvs[A + 2] = E, this._buffer.uvs[A + 3] = b, m || (I += 2, L += 6, A += 4, k.topP = I + 0, k.bottomP = I + 1, this._buffer.positions[L + 0] = v, this._buffer.positions[L + 1] = P, this._buffer.positions[L + 2] = this._depth - S, this._buffer.normals[L + 0] = _ * d, this._buffer.normals[L + 1] = N * d, this._buffer.normals[L + 2] = f, this._buffer.uvs[A + 0] = b, this._buffer.uvs[A + 1] = E, this._buffer.positions[L + 3] = v, this._buffer.positions[L + 4] = P, this._buffer.positions[L + 5] = S, this._buffer.normals[L + 3] = _ * d, this._buffer.normals[L + 4] = N * d, this._buffer.normals[L + 5] = -f, this._buffer.uvs[A + 2] = E, this._buffer.uvs[A + 3] = b), this.vertexCache[s] = k, k;
  }
  clone() {
    let e = new Wo(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
    return e.userData = Cn(this.userData), e;
  }
};
var st = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2, _d2, _e, _f, _g2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, subdivisions: 40, roundness: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, i.parameters), t = Math.abs(e.width), o = Math.abs((_b2 = e.height) != null ? _b2 : e.width), n = Math.abs((_c2 = e.depth) != null ? _c2 : 0), s = (_d2 = i.shape) != null ? _d2 : r == null ? void 0 : r.shape, a = (_e = s == null ? void 0 : s.roundness) != null ? _e : e.roundness;
    s !== void 0 && (s instanceof Se ? (s.width !== t || s.height !== o) && s.applySize(t, o) : s = new Se(t, o).fromJSON(s), ((_f = i.parameters) == null ? void 0 : _f.roundness) !== void 0 && ((_g2 = i.parameters) == null ? void 0 : _g2.roundness) > 0 && s.update(false));
    let l = s != null ? s : new Se(t, o);
    return { parameters: Object.assign(e, { width: t, height: o, depth: n, roundness: a }), shape: l };
  }
  static build(i) {
    let { depth: r, extrudeBevelSize: e, extrudeBevelSegments: t, subdivisions: o, roundness: n } = i.parameters;
    i.shape.roundness = n;
    let s;
    return r <= 0 ? s = new Ho(i.shape, o) : s = new Wo(i.shape, r, e, o, t), Object.assign(s, { userData: __spreadProps(__spreadValues({}, i), { type: "VectorGeometry" }) });
  }
};
var Im = Math.PI * 2;
var Pm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, depth: 0, spikes: 64, angle: 360, innerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, i.parameters);
    return { shape: i.shape && i.shape instanceof Se ? i.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : 0) }) };
  }
  static build(i) {
    let { width: r, height: e, spikes: t, angle: o, innerRadius: n, depth: s, extrudeBevelSize: a, extrudeBevelSegments: l } = i.parameters, c = i.shape, u = r * 0.5, m = e * 0.5, p = yb(c, u, m, o * Math.PI / 180, t, n);
    c.isClosed = true, c.update();
    let d = st.create({ shape: c, parameters: { subdivisions: p, depth: s, extrudeBevelSize: a, extrudeBevelSegments: l } });
    return Object.assign(d, { userData: __spreadProps(__spreadValues({}, i), { type: "EllipseGeometry" }) });
  }
};
function yb(i, r, e, t, o, n) {
  if (t >= Im)
    return o > 30 || o % 4 === 0 ? (vb(i, r, e, n), Math.round(o / 4)) : Nm(i, t, o, r, e, n);
  let s = { x: 0, y: e }, a = t + Math.PI * 0.5, l = { x: Math.cos(a) * r, y: Math.sin(a) * e }, c = vm({ px: s.x, py: s.y, cx: l.x, cy: l.y, rx: r, ry: e, largeArcFlag: t > Math.PI, sweepFlag: true });
  return o > 30 || o % c.length === 0 ? xb(i, s.x, s.y, c, o, r, e, n) : Nm(i, t, o, r, e, n);
}
function xb(i, r, e, t, o, n, s, a) {
  let l = Math.round(o / t.length);
  i.addPoint(qo(r, e));
  for (let c = 0, u = t.length; c < u; c++) {
    let m = t[c], p = i.points[c], d = qo(m.x, m.y);
    p.controls[1].position.set(m.x1, m.y1), d.controls[0].position.set(m.x2, m.y2), i.addPoint(d);
  }
  return a > 0 ? Am(i, n, s, a) : i.addPoint(qo(0, 0)), l;
}
function Nm(i, r, e, t, o, n) {
  let s = -r / e;
  for (let a = 0; a <= e; a++) {
    let l = s * a, c = Math.sin(l) * t, u = Math.cos(l) * o;
    i.addPoint(qo(c, u));
  }
  return r < Im ? n > 0 ? Am(i, t, o, n) : i.addPoint(qo(0, 0)) : (i.removePoint(i.points[i.points.length - 1]), n > 0 && Mm(i, t, o, n)), 1;
}
function vb(i, r, e, t = 0, o = 0, n = 0) {
  let s = 0.5522847498, a = r * s, l = e * s;
  i.addPoint(Rs(o - r, n, o - r, n - l, o - r, n + l)), i.addPoint(Rs(o, n + e, o - a, n + e, o + a, n + e)), i.addPoint(Rs(o + r, n, o + r, n + l, o + r, n - l)), i.addPoint(Rs(o, n - e, o + a, n - e, o - a, n - e)), t > 0 && Mm(i, r, e, t);
}
function qo(i, r) {
  return new _t(MathUtils.generateUUID(), new Vector2(i, r));
}
function Rs(i, r, e, t, o, n) {
  let s = qo(i, r);
  return s.controls[0].position.set(e, t), s.controls[1].position.set(o, n), s;
}
function Am(i, r, e, t) {
  Om(i, r, e, t).forEach((n) => i.addPoint(n));
}
function Mm(i, r, e, t) {
  let o = Om(i, r, e, t), n = new Se();
  o.forEach((s) => n.addPoint(s)), n.isClosed = true, i.shapeHoles.push(n);
}
function Om(i, r, e, t) {
  let o = t * r / 100, n = o * (Math.abs(e) / Math.abs(r)), s = new Vector2(o / r, n / e), a = i.points.map((l) => {
    let c = l.clone();
    return c.uuid = MathUtils.generateUUID(), c;
  }).reverse();
  return a.forEach((l) => {
    l.position.multiply(s);
    let c = l.controls[0].position.clone().multiply(s), u = l.controls[1].position.clone().multiply(s);
    l.controls[0].position.copy(u), l.controls[1].position.copy(c);
  }), a;
}
var Dm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, revolutions: 2, segments: 40, pathRadius: 10, pathType: 0, pathSegments: 30, cornerRadius: 30, cornerSegments: 4 }, i.parameters), t = Math.abs(e.width), o = Math.abs((_b2 = e.height) != null ? _b2 : t), n = Math.abs((_c2 = e.depth) != null ? _c2 : t), s = Math.abs(Math.min(t, n)) / 2;
    return { parameters: Object.assign(e, { width: t, height: o, depth: n, radius: s, segments: Math.round(e.segments), pathSegments: Math.round(e.pathSegments), cornerSegments: Math.round(e.cornerSegments) }) };
  }
  static build(i) {
    let { width: r, height: e, depth: t, radius: o, revolutions: n, segments: s, pathRadius: a, pathType: l, pathSegments: c, cornerRadius: u, cornerSegments: m } = i.parameters, p = new jn(false, r, e, t, o, n, s, a, l, c, u, m);
    return Object.assign(p, { userData: __spreadProps(__spreadValues({}, i), { type: "HelixGeometry" }) });
  }
};
var jn = class extends BufferGeometry {
  constructor(r = true, e = 1, t = 1, o = 1, n = 1, s = 1, a = 1, l = 1, c = 1, u = 1, m = 1, p = 1) {
    super();
    let d = r && s === 1;
    d && (p = 0), m > 100 && (m = 100);
    let f = () => new Vector3(), g = new Vector3(), x = f(), y = f(), v = f(), P, S, b, E, w, h, _, N, I = f(), L = f(), A = f(), k = f(), q = f(), oe = f(), ce = f(), ie = f(), K = t - 2 * l + 1e-3, U = K / s, z = Math.ceil(a * s), B = z + 1, D = K / z, M = -K / 2, G = u + 1, Q = 2 * Math.PI / u, j = Math.PI / 2 / p, V = 0.01, F = Math.min((1 - m / 100) * l, l - V), O = l - F, $ = 0, Z = 2, ee = p * Z + Z, H = G * ee / Z, J = H + G * B, X = G * (B + ee), [re, le, ne] = [3, 3, 2].map((_e) => Array(X * _e).fill(0)), de = [], Me = n - l;
    function he(_e, gt) {
      let jt = Math.PI / 2;
      h = gt * D, N = 2 * Math.PI * (h % U) / U + jt, h += M, _ = Math.sin(N) * Me, w = Math.cos(N) * Me, r ? _e.set(w, _, h) : _e.set(w, h, _);
    }
    he(g, -1e-10), he(x, 0), I.copy(g), he(g, 1);
    let Be = g.distanceTo(x), be = O + F, ct = Be * z + 2 * be, St = F, po = ct - be;
    for (let _e = 0; _e <= z; _e++) {
      he(y, _e), ie.subVectors(y, I).normalize(), I.copy(y), oe.copy(y).setComponent(+r + 1, 0).normalize(), ce.crossVectors(ie, oe).normalize();
      let gt = _e === 0, jt = _e === z, Of = gt ? 3 * Math.PI / 2 : j, _f = gt ? St : po, Df = gt ? G : J, Ef = gt ? 0 : X - G, Bf = ie.clone().multiplyScalar(gt ? -O : O).add(y), Gf = ie.clone().multiplyScalar(gt ? -1 : 1).normalize();
      for (let mr = 0; mr < G; mr++) {
        let ac = mr * Q;
        if (L.addVectors(g.copy(oe).multiplyScalar(l * Math.cos(ac)), x.copy(ce).multiplyScalar(l * Math.sin(ac))), A.copy(L).normalize(), gt || jt) {
          d || ($ = Ef + mr, [0, 1, 2].forEach((ut) => {
            re[$ * 3 + ut] = Bf.getComponent(ut), le[$ * 3 + ut] = Gf.getComponent(ut);
          }), ne[$ * 2] = +jt, ne[$ * 2 + 1] = mr / u), x.copy(A).multiplyScalar(F), v.addVectors(y, x);
          for (let ut = 0; ut < p; ut++) {
            let da = ut * j + Of;
            k.addVectors(g.copy(ie).multiplyScalar(O * Math.sin(da)), x.copy(A).multiplyScalar(O * Math.cos(da))), q.copy(k).normalize(), x.addVectors(v, k), k.normalize(), $ = Df + ut * G + mr, [0, 1, 2].forEach((Ti) => {
              re[$ * 3 + Ti] = x.getComponent(Ti), le[$ * 3 + Ti] = q.getComponent(Ti);
            });
            let Rf = +gt + Math.sin(da);
            ne[$ * 2] = (_f + O * Rf) / ct, ne[$ * 2 + 1] = mr / u;
          }
        }
        x.addVectors(y, L), $ = H + _e * G + mr, [0, 1, 2].forEach((ut) => {
          re[$ * 3 + ut] = x.getComponent(ut), le[$ * 3 + ut] = A.getComponent(ut);
        }), ne[$ * 2] = (be + _e * Be) / ct, ne[$ * 2 + 1] = mr / u;
      }
    }
    let ht = B + 2 * p + Z, mo = 1, [Si, wi] = d ? [mo, mo + B - 1] : [0, ht - 1];
    for (let _e = Si; _e <= wi - 1; _e++) {
      let gt = d && _e === wi - 1;
      for (let jt = 0; jt < G - 1; jt++)
        P = _e * G + jt, S = P + 1, b = (gt ? jt : P) + G, E = (gt ? jt + 1 : S) + G, _e === 0 ? de.push(S, E, b) : _e === ht - 2 ? de.push(P, S, b) : de.push(P, S, b, S, E, b);
    }
    this.setIndex(de), this.setAttribute("position", new Float32BufferAttribute(re, 3)), this.setAttribute("normal", new Float32BufferAttribute(le, 3)), this.setAttribute("uv", new Float32BufferAttribute(ne, 2));
  }
};
var Em = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, detail: 0, corner: 0, cornerSides: 4 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width) }) };
  }
  static build(i) {
    let { width: r, height: e, depth: t, detail: o, corner: n, cornerSides: s } = i.parameters, a = o === 0 && n !== 0 ? new kn(r * 0.5, n, s) : new IcosahedronGeometry(r * 0.5, o);
    return a.scale(1, e / r, t / r), Object.assign(a, { userData: __spreadProps(__spreadValues({}, i), { type: "IcosahedronGeometry" }) });
  }
};
var kn = class extends Rr {
  constructor(r = 1, e = 0.2, t = 4) {
    let o = (1 + Math.sqrt(5)) / 2, n = [-1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, 0, 0, -1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, o, 0, -1, o, 0, 1, -o, 0, -1, -o, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a = "IcosahedronGeometry";
    super(n, s, a, r, e, t), this.type = a;
  }
  static fromJSON(r) {
    return new kn(r.radius, r.corner, r.cornerSides);
  }
};
var Bm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2, _d2, _e;
    ((_b2 = (_a2 = i.parameters) == null ? void 0 : _a2.points) != null ? _b2 : []).forEach((t) => {
      Array.isArray(t) && (t.x = t[0], t.y = t[1]);
    });
    let e = Object.assign({}, (_c2 = r == null ? void 0 : r.parameters) != null ? _c2 : { width: 100, segments: 64, verticalSegments: 64, points: [{ x: 0, y: -50, id: 0 }, { x: 50, y: -50, id: 1 }, { x: 50, y: 50, id: 2 }, { x: 0, y: 50, id: 3 }] }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_d2 = e.height) != null ? _d2 : e.width), depth: Math.abs((_e = e.depth) != null ? _e : e.width) }) };
  }
  static build(i) {
    let { points: r, segments: e, verticalSegments: t } = i.parameters, o = new Shape();
    o.moveTo(r[0].x, r[0].y), o.bezierCurveTo(r[1].x, r[1].y, r[2].x, r[2].y, r[3].x, r[3].y);
    let n = new LatheGeometry(o.extractPoints(t).shape, e);
    return n.rotateZ(Math.PI), Object.assign(n, { userData: __spreadProps(__spreadValues({}, i), { type: "LatheGeometry" }) });
  }
};
var Yt = new Matrix4();
var ul = new Object3D();
var zs = new Vector3();
var Vr = class extends EventDispatcher {
  constructor() {
    super(), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = false, this.verticesNeedUpdate = false, this.uvsNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.lineDistancesNeedUpdate = false, this.groupsNeedUpdate = false;
  }
  applyMatrix4(r) {
    let e = new Matrix3().getNormalMatrix(r);
    for (let t = 0, o = this.vertices.length; t < o; t++)
      this.vertices[t].applyMatrix4(r);
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let n = this.faces[t];
      n.normal.applyMatrix3(e).normalize();
      for (let s = 0, a = n.vertexNormals.length; s < a; s++)
        n.vertexNormals[s].applyMatrix3(e).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = true, this.normalsNeedUpdate = true, this;
  }
  rotateX(r) {
    return Yt.makeRotationX(r), this.applyMatrix4(Yt), this;
  }
  rotateY(r) {
    return Yt.makeRotationY(r), this.applyMatrix4(Yt), this;
  }
  rotateZ(r) {
    return Yt.makeRotationZ(r), this.applyMatrix4(Yt), this;
  }
  translate(r, e, t) {
    return Yt.makeTranslation(r, e, t), this.applyMatrix4(Yt), this;
  }
  scale(r, e, t) {
    return Yt.makeScale(r, e, t), this.applyMatrix4(Yt), this;
  }
  lookAt(r) {
    return ul.lookAt(r), ul.updateMatrix(), this.applyMatrix4(ul.matrix), this;
  }
  fromBufferGeometry(r) {
    let e = this, t = r.index !== null ? r.index : void 0, o = r.attributes;
    if (o.position === void 0)
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    let n = o.position, s = o.normal, a = o.color, l = o.uv, c = o.uv2;
    c !== void 0 && (this.faceVertexUvs[1] = []);
    for (let p = 0; p < n.count; p++)
      e.vertices.push(new Vector3().fromBufferAttribute(n, p)), a !== void 0 && e.colors.push(new Color().fromBufferAttribute(a, p));
    function u(p, d, f, g) {
      let x = a === void 0 ? [] : [e.colors[p].clone(), e.colors[d].clone(), e.colors[f].clone()], y = s === void 0 ? [] : [new Vector3().fromBufferAttribute(s, p), new Vector3().fromBufferAttribute(s, d), new Vector3().fromBufferAttribute(s, f)], v = new Xo(p, d, f, y, x, g);
      e.faces.push(v), l !== void 0 && e.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(l, p), new Vector2().fromBufferAttribute(l, d), new Vector2().fromBufferAttribute(l, f)]), c !== void 0 && e.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(c, p), new Vector2().fromBufferAttribute(c, d), new Vector2().fromBufferAttribute(c, f)]);
    }
    let m = r.groups;
    if (m.length > 0)
      for (let p = 0; p < m.length; p++) {
        let d = m[p], f = d.start, g = d.count;
        for (let x = f, y = f + g; x < y; x += 3)
          t !== void 0 ? u(t.getX(x), t.getX(x + 1), t.getX(x + 2), d.materialIndex) : u(x, x + 1, x + 2, d.materialIndex);
      }
    else if (t !== void 0)
      for (let p = 0; p < t.count; p += 3)
        u(t.getX(p), t.getX(p + 1), t.getX(p + 2));
    else
      for (let p = 0; p < n.count; p += 3)
        u(p, p + 1, p + 2);
    return this.computeFaceNormals(), r.boundingBox !== null && (this.boundingBox = r.boundingBox.clone()), r.boundingSphere !== null && (this.boundingSphere = r.boundingSphere.clone()), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(zs).negate(), this.translate(zs.x, zs.y, zs.z), this;
  }
  normalize() {
    this.computeBoundingSphere();
    let r = this.boundingSphere.center, e = this.boundingSphere.radius, t = e === 0 ? 1 : 1 / e, o = new Matrix4();
    return o.set(t, 0, 0, -t * r.x, 0, t, 0, -t * r.y, 0, 0, t, -t * r.z, 0, 0, 0, 1), this.applyMatrix4(o), this;
  }
  computeFaceNormals() {
    let r = new Vector3(), e = new Vector3();
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let n = this.faces[t], s = this.vertices[n.a], a = this.vertices[n.b], l = this.vertices[n.c];
      r.subVectors(l, a), e.subVectors(s, a), r.cross(e), r.normalize(), n.normal.copy(r);
    }
  }
  computeVertexNormals(r = true) {
    let e = new Array(this.vertices.length);
    for (let t = 0, o = this.vertices.length; t < o; t++)
      e[t] = new Vector3();
    if (r) {
      let t = new Vector3(), o = new Vector3();
      for (let n = 0, s = this.faces.length; n < s; n++) {
        let a = this.faces[n], l = this.vertices[a.a], c = this.vertices[a.b], u = this.vertices[a.c];
        t.subVectors(u, c), o.subVectors(l, c), t.cross(o), e[a.a].add(t), e[a.b].add(t), e[a.c].add(t);
      }
    } else {
      this.computeFaceNormals();
      for (let t = 0, o = this.faces.length; t < o; t++) {
        let n = this.faces[t];
        e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal);
      }
    }
    for (let t = 0, o = this.vertices.length; t < o; t++)
      e[t].normalize();
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let n = this.faces[t], s = n.vertexNormals;
      s.length === 3 ? (s[0].copy(e[n.a]), s[1].copy(e[n.b]), s[2].copy(e[n.c])) : (s[0] = e[n.a].clone(), s[1] = e[n.b].clone(), s[2] = e[n.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = true);
  }
  computeFlatVertexNormals() {
    this.computeFaceNormals();
    for (let r = 0, e = this.faces.length; r < e; r++) {
      let t = this.faces[r], o = t.vertexNormals;
      o.length === 3 ? (o[0].copy(t.normal), o[1].copy(t.normal), o[2].copy(t.normal)) : (o[0] = t.normal.clone(), o[1] = t.normal.clone(), o[2] = t.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = true);
  }
  computeMorphNormals() {
    for (let e = 0, t = this.faces.length; e < t; e++) {
      let o = this.faces[e];
      o.__originalFaceNormal ? o.__originalFaceNormal.copy(o.normal) : o.__originalFaceNormal = o.normal.clone(), o.__originalVertexNormals || (o.__originalVertexNormals = []);
      for (let n = 0, s = o.vertexNormals.length; n < s; n++)
        o.__originalVertexNormals[n] ? o.__originalVertexNormals[n].copy(o.vertexNormals[n]) : o.__originalVertexNormals[n] = o.vertexNormals[n].clone();
    }
    let r = new Vr();
    r.faces = this.faces;
    for (let e = 0, t = this.morphTargets.length; e < t; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        let n = this.morphNormals[e].faceNormals, s = this.morphNormals[e].vertexNormals;
        for (let a = 0, l = this.faces.length; a < l; a++) {
          let c = new Vector3(), u = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
          n.push(c), s.push(u);
        }
      }
      let o = this.morphNormals[e];
      r.vertices = this.morphTargets[e].vertices, r.computeFaceNormals(), r.computeVertexNormals();
      for (let n = 0, s = this.faces.length; n < s; n++) {
        let a = this.faces[n], l = o.faceNormals[n], c = o.vertexNormals[n];
        l.copy(a.normal), c.a.copy(a.vertexNormals[0]), c.b.copy(a.vertexNormals[1]), c.c.copy(a.vertexNormals[2]);
      }
    }
    for (let e = 0, t = this.faces.length; e < t; e++) {
      let o = this.faces[e];
      o.normal = o.__originalFaceNormal, o.vertexNormals = o.__originalVertexNormals;
    }
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3()), this.boundingBox.setFromPoints(this.vertices);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingSphere.setFromPoints(this.vertices);
  }
  merge(r, e, t = 0) {
    if (!(r && r.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", r);
      return;
    }
    let o, n = this.vertices.length, s = this.vertices, a = r.vertices, l = this.faces, c = r.faces, u = this.colors, m = r.colors;
    e !== void 0 && (o = new Matrix3().getNormalMatrix(e));
    for (let p = 0, d = a.length; p < d; p++) {
      let g = a[p].clone();
      e !== void 0 && g.applyMatrix4(e), s.push(g);
    }
    for (let p = 0, d = m.length; p < d; p++)
      u.push(m[p].clone());
    for (let p = 0, d = c.length; p < d; p++) {
      let f = c[p], g, x, y = f.vertexNormals, v = f.vertexColors, P = new Xo(f.a + n, f.b + n, f.c + n);
      P.normal.copy(f.normal), o !== void 0 && P.normal.applyMatrix3(o).normalize();
      for (let S = 0, b = y.length; S < b; S++)
        g = y[S].clone(), o !== void 0 && g.applyMatrix3(o).normalize(), P.vertexNormals.push(g);
      P.color.copy(f.color);
      for (let S = 0, b = v.length; S < b; S++)
        x = v[S], P.vertexColors.push(x.clone());
      P.materialIndex = f.materialIndex + t, l.push(P);
    }
    for (let p = 0, d = r.faceVertexUvs.length; p < d; p++) {
      let f = r.faceVertexUvs[p];
      this.faceVertexUvs[p] === void 0 && (this.faceVertexUvs[p] = []);
      for (let g = 0, x = f.length; g < x; g++) {
        let y = f[g], v = [];
        for (let P = 0, S = y.length; P < S; P++)
          v.push(y[P].clone());
        this.faceVertexUvs[p].push(v);
      }
    }
  }
  mergeMesh(r) {
    if (!(r && r.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", r);
      return;
    }
    r.matrixAutoUpdate && r.updateMatrix(), this.merge(r.geometry, r.matrix);
  }
  mergeVertices(r = 4) {
    let e = {}, t = [], o = [], n = Math.pow(10, r);
    for (let l = 0, c = this.vertices.length; l < c; l++) {
      let u = this.vertices[l], m = Math.round(u.x * n) + "_" + Math.round(u.y * n) + "_" + Math.round(u.z * n);
      e[m] === void 0 ? (e[m] = l, t.push(this.vertices[l]), o[l] = t.length - 1) : o[l] = o[e[m]];
    }
    let s = [];
    for (let l = 0, c = this.faces.length; l < c; l++) {
      let u = this.faces[l];
      u.a = o[u.a], u.b = o[u.b], u.c = o[u.c];
      let m = [u.a, u.b, u.c];
      for (let p = 0; p < 3; p++)
        if (m[p] === m[(p + 1) % 3]) {
          s.push(l);
          break;
        }
    }
    for (let l = s.length - 1; l >= 0; l--) {
      let c = s[l];
      this.faces.splice(c, 1);
      for (let u = 0, m = this.faceVertexUvs.length; u < m; u++)
        this.faceVertexUvs[u].splice(c, 1);
    }
    let a = this.vertices.length - t.length;
    return this.vertices = t, a;
  }
  setFromPoints(r) {
    this.vertices = [];
    for (let e = 0, t = r.length; e < t; e++) {
      let o = r[e];
      this.vertices.push(new Vector3(o.x, o.y, o.z || 0));
    }
    return this;
  }
  sortFacesByMaterialIndex() {
    let r = this.faces, e = r.length;
    for (let l = 0; l < e; l++)
      r[l]._id = l;
    function t(l, c) {
      return l.materialIndex - c.materialIndex;
    }
    r.sort(t);
    let o = this.faceVertexUvs[0], n = this.faceVertexUvs[1], s, a;
    o && o.length === e && (s = []), n && n.length === e && (a = []);
    for (let l = 0; l < e; l++) {
      let c = r[l]._id;
      s && s.push(o[c]), a && a.push(n[c]);
    }
    s && (this.faceVertexUvs[0] = s), a && (this.faceVertexUvs[1] = a);
  }
  toJSON() {
    let r = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.parameters !== void 0) {
      let f = this.parameters;
      for (let g in f)
        f[g] !== void 0 && (r[g] = f[g]);
      return r;
    }
    let e = [];
    for (let f = 0; f < this.vertices.length; f++) {
      let g = this.vertices[f];
      e.push(g.x, g.y, g.z);
    }
    let t = [], o = [], n = {}, s = [], a = {}, l = [], c = {};
    for (let f = 0; f < this.faces.length; f++) {
      let g = this.faces[f], x = true, y = false, v = this.faceVertexUvs[0][f] !== void 0, P = g.normal.length() > 0, S = g.vertexNormals.length > 0, b = g.color.r !== 1 || g.color.g !== 1 || g.color.b !== 1, E = g.vertexColors.length > 0, w = 0;
      if (w = u(w, 0, 0), w = u(w, 1, x), w = u(w, 2, y), w = u(w, 3, v), w = u(w, 4, P), w = u(w, 5, S), w = u(w, 6, b), w = u(w, 7, E), t.push(w), t.push(g.a, g.b, g.c), t.push(g.materialIndex), v) {
        let h = this.faceVertexUvs[0][f];
        t.push(d(h[0]), d(h[1]), d(h[2]));
      }
      if (P && t.push(m(g.normal)), S) {
        let h = g.vertexNormals;
        t.push(m(h[0]), m(h[1]), m(h[2]));
      }
      if (b && t.push(p(g.color)), E) {
        let h = g.vertexColors;
        t.push(p(h[0]), p(h[1]), p(h[2]));
      }
    }
    function u(f, g, x) {
      return x ? f | 1 << g : f & ~(1 << g);
    }
    function m(f) {
      let g = f.x.toString() + f.y.toString() + f.z.toString();
      return n[g] !== void 0 || (n[g] = o.length / 3, o.push(f.x, f.y, f.z)), n[g];
    }
    function p(f) {
      let g = f.r.toString() + f.g.toString() + f.b.toString();
      return a[g] !== void 0 || (a[g] = s.length, s.push(f.getHex())), a[g];
    }
    function d(f) {
      let g = f.x.toString() + f.y.toString();
      return c[g] !== void 0 || (c[g] = l.length / 2, l.push(f.x, f.y)), c[g];
    }
    return r.data = {}, r.data.vertices = e, r.data.normals = o, s.length > 0 && (r.data.colors = s), l.length > 0 && (r.data.uvs = [l]), r.data.faces = t, r;
  }
  clone() {
    return new Vr().copy(this);
  }
  copy(r) {
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = r.name;
    let e = r.vertices;
    for (let p = 0, d = e.length; p < d; p++)
      this.vertices.push(e[p].clone());
    let t = r.colors;
    for (let p = 0, d = t.length; p < d; p++)
      this.colors.push(t[p].clone());
    let o = r.faces;
    for (let p = 0, d = o.length; p < d; p++)
      this.faces.push(o[p].clone());
    for (let p = 0, d = r.faceVertexUvs.length; p < d; p++) {
      let f = r.faceVertexUvs[p];
      this.faceVertexUvs[p] === void 0 && (this.faceVertexUvs[p] = []);
      for (let g = 0, x = f.length; g < x; g++) {
        let y = f[g], v = [];
        for (let P = 0, S = y.length; P < S; P++) {
          let b = y[P];
          v.push(b.clone());
        }
        this.faceVertexUvs[p].push(v);
      }
    }
    let n = r.morphTargets;
    for (let p = 0, d = n.length; p < d; p++) {
      let f = {};
      if (f.name = n[p].name, n[p].vertices !== void 0) {
        f.vertices = [];
        for (let g = 0, x = n[p].vertices.length; g < x; g++)
          f.vertices.push(n[p].vertices[g].clone());
      }
      if (n[p].normals !== void 0) {
        f.normals = [];
        for (let g = 0, x = n[p].normals.length; g < x; g++)
          f.normals.push(n[p].normals[g].clone());
      }
      this.morphTargets.push(f);
    }
    let s = r.morphNormals;
    for (let p = 0, d = s.length; p < d; p++) {
      let f = {};
      if (s[p].vertexNormals !== void 0) {
        f.vertexNormals = [];
        for (let g = 0, x = s[p].vertexNormals.length; g < x; g++) {
          let y = s[p].vertexNormals[g], v = {};
          v.a = y.a.clone(), v.b = y.b.clone(), v.c = y.c.clone(), f.vertexNormals.push(v);
        }
      }
      if (s[p].faceNormals !== void 0) {
        f.faceNormals = [];
        for (let g = 0, x = s[p].faceNormals.length; g < x; g++)
          f.faceNormals.push(s[p].faceNormals[g].clone());
      }
      this.morphNormals.push(f);
    }
    let a = r.skinWeights;
    for (let p = 0, d = a.length; p < d; p++)
      this.skinWeights.push(a[p].clone());
    let l = r.skinIndices;
    for (let p = 0, d = l.length; p < d; p++)
      this.skinIndices.push(l[p].clone());
    let c = r.lineDistances;
    for (let p = 0, d = c.length; p < d; p++)
      this.lineDistances.push(c[p]);
    let u = r.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    let m = r.boundingSphere;
    return m !== null && (this.boundingSphere = m.clone()), this.elementsNeedUpdate = r.elementsNeedUpdate, this.verticesNeedUpdate = r.verticesNeedUpdate, this.uvsNeedUpdate = r.uvsNeedUpdate, this.normalsNeedUpdate = r.normalsNeedUpdate, this.colorsNeedUpdate = r.colorsNeedUpdate, this.lineDistancesNeedUpdate = r.lineDistancesNeedUpdate, this.groupsNeedUpdate = r.groupsNeedUpdate, this;
  }
  toBufferGeometry() {
    let r = new pl().fromGeometry(this), e = new BufferGeometry(), t = new Float32Array(r.vertices.length * 3);
    if (e.setAttribute("position", new BufferAttribute(t, 3).copyVector3sArray(r.vertices)), r.normals.length > 0) {
      let o = new Float32Array(r.normals.length * 3);
      e.setAttribute("normal", new BufferAttribute(o, 3).copyVector3sArray(r.normals));
    }
    if (r.colors.length > 0) {
      let o = new Float32Array(r.colors.length * 3);
      e.setAttribute("color", new BufferAttribute(o, 3).copyColorsArray(r.colors));
    }
    if (r.uvs.length > 0) {
      let o = new Float32Array(r.uvs.length * 2);
      e.setAttribute("uv", new BufferAttribute(o, 2).copyVector2sArray(r.uvs));
    }
    if (r.uvs2.length > 0) {
      let o = new Float32Array(r.uvs2.length * 2);
      e.setAttribute("uv2", new BufferAttribute(o, 2).copyVector2sArray(r.uvs2));
    }
    e.groups = r.groups;
    for (let o in r.morphTargets) {
      let n = [], s = r.morphTargets[o];
      for (let a = 0, l = s.length; a < l; a++) {
        let c = s[a], u = new Float32BufferAttribute(c.data.length * 3, 3);
        u.name = c.name, n.push(u.copyVector3sArray(c.data));
      }
      e.morphAttributes[o] = n;
    }
    if (r.skinIndices.length > 0) {
      let o = new Float32BufferAttribute(r.skinIndices.length * 4, 4);
      e.setAttribute("skinIndex", o.copyVector4sArray(r.skinIndices));
    }
    if (r.skinWeights.length > 0) {
      let o = new Float32BufferAttribute(r.skinWeights.length * 4, 4);
      e.setAttribute("skinWeight", o.copyVector4sArray(r.skinWeights));
    }
    return r.boundingSphere !== null && (e.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (e.boundingBox = r.boundingBox.clone()), e;
  }
  computeTangents() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }
  computeLineDistances() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
  applyMatrix(r) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(r);
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  static createBufferGeometryFromObject(r) {
    let e = new BufferGeometry(), t = r.geometry;
    if (r.isPoints || r.isLine) {
      let o = new Float32BufferAttribute(t.vertices.length * 3, 3), n = new Float32BufferAttribute(t.colors.length * 3, 3);
      if (e.setAttribute("position", o.copyVector3sArray(t.vertices)), e.setAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
        let s = new Float32BufferAttribute(t.lineDistances.length, 1);
        e.setAttribute("lineDistance", s.copyArray(t.lineDistances));
      }
      t.boundingSphere !== null && (e.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (e.boundingBox = t.boundingBox.clone());
    } else
      r.isMesh && (e = t.toBufferGeometry());
    return e;
  }
};
Vr.prototype.isGeometry = true;
var pl = class {
  constructor() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.uvsNeedUpdate = false, this.groupsNeedUpdate = false;
  }
  computeGroups(r) {
    let e = [], t, o, n, s = r.faces;
    for (o = 0; o < s.length; o++) {
      let a = s[o];
      a.materialIndex !== n && (n = a.materialIndex, t !== void 0 && (t.count = o * 3 - t.start, e.push(t)), t = { start: o * 3, materialIndex: n });
    }
    t !== void 0 && (t.count = o * 3 - t.start, e.push(t)), this.groups = e;
  }
  fromGeometry(r) {
    let e = r.faces, t = r.vertices, o = r.faceVertexUvs, n = o[0] && o[0].length > 0, s = o[1] && o[1].length > 0, a = r.morphTargets, l = a.length, c;
    if (l > 0) {
      c = [];
      for (let y = 0; y < l; y++)
        c[y] = { name: a[y].name, data: [] };
      this.morphTargets.position = c;
    }
    let u = r.morphNormals, m = u.length, p;
    if (m > 0) {
      p = [];
      for (let y = 0; y < m; y++)
        p[y] = { name: u[y].name, data: [] };
      this.morphTargets.normal = p;
    }
    let d = r.skinIndices, f = r.skinWeights, g = d.length === t.length, x = f.length === t.length;
    t.length > 0 && e.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (let y = 0; y < e.length; y++) {
      let v = e[y];
      this.vertices.push(t[v.a], t[v.b], t[v.c]);
      let P = v.vertexNormals;
      if (P.length === 3)
        this.normals.push(P[0], P[1], P[2]);
      else {
        let b = v.normal;
        this.normals.push(b, b, b);
      }
      let S = v.vertexColors;
      if (S.length === 3)
        this.colors.push(S[0], S[1], S[2]);
      else {
        let b = v.color;
        this.colors.push(b, b, b);
      }
      if (n === true) {
        let b = o[0][y];
        b !== void 0 ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", y), this.uvs.push(new Vector2(), new Vector2(), new Vector2()));
      }
      if (s === true) {
        let b = o[1][y];
        b !== void 0 ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", y), this.uvs2.push(new Vector2(), new Vector2(), new Vector2()));
      }
      for (let b = 0; b < l; b++) {
        let E = a[b].vertices;
        c[b].data.push(E[v.a], E[v.b], E[v.c]);
      }
      for (let b = 0; b < m; b++) {
        let E = u[b].vertexNormals[y];
        p[b].data.push(E.a, E.b, E.c);
      }
      g && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), x && this.skinWeights.push(f[v.a], f[v.b], f[v.c]);
    }
    return this.computeGroups(r), this.verticesNeedUpdate = r.verticesNeedUpdate, this.normalsNeedUpdate = r.normalsNeedUpdate, this.colorsNeedUpdate = r.colorsNeedUpdate, this.uvsNeedUpdate = r.uvsNeedUpdate, this.groupsNeedUpdate = r.groupsNeedUpdate, r.boundingSphere !== null && (this.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (this.boundingBox = r.boundingBox.clone()), this;
  }
};
var Xo = class {
  constructor(r, e, t, o, n, s = 0) {
    this.a = r, this.b = e, this.c = t, this.normal = o && o.isVector3 ? o : new Vector3(), this.vertexNormals = Array.isArray(o) ? o : [], this.color = n && n.isColor ? n : new Color(), this.vertexColors = Array.isArray(n) ? n : [], this.materialIndex = s;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.a = r.a, this.b = r.b, this.c = r.c, this.normal.copy(r.normal), this.color.copy(r.color), this.materialIndex = r.materialIndex;
    for (let e = 0, t = r.vertexNormals.length; e < t; e++)
      this.vertexNormals[e] = r.vertexNormals[e].clone();
    for (let e = 0, t = r.vertexColors.length; e < t; e++)
      this.vertexColors[e] = r.vertexColors[e].clone();
    return this;
  }
};
var Mb = ["a", "b", "c"];
function Ob(i, r) {
  switch (r) {
    case "c":
      return i.c;
    case "b":
      return i.b;
    case "a":
    default:
      return i.a;
  }
}
function dl(i, r, e) {
  let t = Math.min(i, r), o = Math.max(i, r), n = t + "_" + o;
  return e.get(n);
}
function fl(i, r, e, t, o, n) {
  let s = Math.min(i, r), a = Math.max(i, r), l = s + "_" + a, c;
  if (t.has(l))
    c = t.get(l);
  else {
    let u = e[s], m = e[a];
    c = { a: u, b: m, newEdge: null, faces: [] }, t.set(l, c);
  }
  c.faces.push(o), n[i].edges.push(c), n[r].edges.push(c);
}
function _b(i, r, e, t) {
  let o, n, s;
  for (o = 0, n = i.length; o < n; o++)
    e[o] = { edges: [] };
  for (o = 0, n = r.length; o < n; o++)
    s = r[o], fl(s.a, s.b, i, t, s, e), fl(s.b, s.c, i, t, s, e), fl(s.c, s.a, i, t, s, e);
}
function Vs(i, r, e, t, o) {
  i.push(new Xo(r, e, t, void 0, void 0, o));
}
function Yo(i, r) {
  return Math.abs(r - i) / 2 + Math.min(i, r);
}
function Fs(i, r, e, t) {
  i.push([r.clone(), e.clone(), t.clone()]);
}
var Us = class {
  constructor(r = 1) {
    this.subdivisions = r;
  }
  modify(r) {
    r instanceof BufferGeometry ? r = new Vr().fromBufferGeometry(r) : r = r.clone(), r.mergeVertices();
    let e = this.subdivisions;
    for (; e-- > 0; )
      this._smooth(r);
    return r.computeFaceNormals(), r.computeVertexNormals(), r;
  }
  _smooth(r) {
    let e = new Vector3(), t, o, n, s, a, l = r.vertices, c = r.faces, u = r.faceVertexUvs[0], m = u !== void 0 && u.length > 0, p = [], d = new Map();
    _b(l, c, p, d);
    let f = [], g, x, y, v, P, S, b;
    for (let V of Array.from(d.keys())) {
      for (x = d.get(V), y = new Vector3(), P = 3 / 8, S = 1 / 8, b = x.faces.length, b != 2 && (P = 0.5, S = 0, b != 1), y.addVectors(x.a, x.b).multiplyScalar(P), e.set(0, 0, 0), s = 0; s < b; s++) {
        for (v = x.faces[s], a = 0; a < 3 && (g = l[Ob(v, Mb[a])], !(g !== x.a && g !== x.b)); a++)
          ;
        g && e.add(g);
      }
      e.multiplyScalar(S), y.add(e), x.newEdge = f.length, f.push(y);
    }
    let E, w, h, _, N, I, L, A = [];
    for (o = 0, n = l.length; o < n; o++) {
      for (I = l[o], N = p[o].edges, t = N.length, t == 3 ? E = 3 / 16 : t > 3 && (E = 3 / (8 * t)), w = 1 - t * Number(E), h = E, t <= 2 && (t == 2 ? (w = 3 / 4, h = 1 / 8) : t == 1 || t == 0), L = I.clone().multiplyScalar(w), e.set(0, 0, 0), s = 0; s < t; s++)
        _ = N[s], g = _.a !== I ? _.a : _.b, e.add(g);
      e.multiplyScalar(Number(h)), L.add(e), A.push(L);
    }
    let k = A.concat(f), q = A.length, oe, ce, ie, K = [], U = [], z, B, D, M, G = new Vector2(), Q = new Vector2(), j = new Vector2();
    for (o = 0, n = c.length; o < n; o++)
      v = c[o], oe = Number(dl(v.a, v.b, d).newEdge) + q, ce = Number(dl(v.b, v.c, d).newEdge) + q, ie = Number(dl(v.c, v.a, d).newEdge) + q, Vs(K, oe, ce, ie, v.materialIndex), Vs(K, v.a, oe, ie, v.materialIndex), Vs(K, v.b, ce, oe, v.materialIndex), Vs(K, v.c, ie, ce, v.materialIndex), m && (z = u[o], B = z[0], D = z[1], M = z[2], G.set(Yo(B.x, D.x), Yo(B.y, D.y)), Q.set(Yo(D.x, M.x), Yo(D.y, M.y)), j.set(Yo(B.x, M.x), Yo(B.y, M.y)), Fs(U, G, Q, j), Fs(U, B, G, j), Fs(U, D, Q, G), Fs(U, M, j, Q));
    r.vertices = k, r.faces = K, m && (r.faceVertexUvs[0] = U);
  }
};
var Ue = new Vector3();
var km = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2;
    let e = (_b2 = (_a2 = i.geometry) != null ? _a2 : r == null ? void 0 : r.geometry) != null ? _b2 : new BufferGeometry().copy(new BoxGeometry(100, 100, 100)), t;
    r === void 0 ? (e.computeBoundingBox(), e.boundingBox.getSize(Ue), t = { width: Ue.x, height: Ue.y, depth: Ue.z, subdivisions: 0 }) : t = r.parameters;
    let o = __spreadValues(__spreadValues({}, t), i.parameters);
    return { parameters: { width: Math.abs(o.width), height: Math.abs(o.height), depth: Math.abs(o.depth), subdivisions: Math.abs(o.subdivisions) }, geometry: e };
  }
  static build(i) {
    var _a2;
    let { width: r, height: e, depth: t, subdivisions: o } = i.parameters, n = (_a2 = i.geometry) != null ? _a2 : new BufferGeometry().copy(new BoxGeometry(100, 100, 100)), s = n.userData.parameters;
    s === void 0 ? (n.computeBoundingBox(), n.boundingBox.getSize(Ue)) : Ue.set(s.width, s.height, s.depth), (r !== Ue.x || e !== Ue.y || t !== Ue.z) && n.scale(Ue.x === 0 ? 1 : r / Ue.x, Ue.y === 0 ? 1 : e / Ue.y, Ue.z === 0 ? 1 : t / Ue.z);
    let a = n.originalGeometry;
    return o > 0 ? (a === void 0 || (s == null ? void 0 : s.subdivisions) !== o) && (a === void 0 && (a = n), n = new Us(o).modify(a).toBufferGeometry()) : (a !== void 0 && (n = a), a = void 0, n.getAttribute("normal") === void 0 && n.computeVertexNormals()), a !== void 0 && Object.assign(n, { originalGeometry: a }), delete i.geometry, Object.assign(n, { userData: __spreadProps(__spreadValues({}, i), { type: "NonParametricGeometry" }) });
  }
  static loadFromUrl(i, r, e) {
    new BufferGeometryLoader(e).load(i, (o) => {
      let n = this.normalizeInputs({ geometry: o });
      o.boundingBox.getSize(Ue);
      let s = 100 / Ue.x;
      Object.assign(n.parameters, { width: 100, height: Ue.y * s, depth: Ue.z * s }), r(this.build(n));
    });
  }
};
var Hm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, i.parameters);
    return { shape: i.shape && i.shape instanceof Se ? i.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : 0) }) };
  }
  static build(i) {
    let { width: r, height: e, spikes: t, cornerRadius: o, depth: n, extrudeBevelSize: s, extrudeBevelSegments: a } = i.parameters, l = i.shape, c = r * 0.5, u = e * 0.5, m = 0, p = 0, d = 2 * Math.PI / t;
    for (let g = 0; g < t; g++) {
      let x = d * g, y = m + Math.sin(x) * c, v = p + Math.cos(x) * u;
      l.addPoint(l.createPoint(y, v));
    }
    l.isClosed = true;
    for (let g = 0, x = l.points.length; g < x; g++)
      l.points[g].roundness = o;
    l.roundness = o, l.update();
    let f = st.create({ shape: l, parameters: { roundness: o, depth: n, extrudeBevelSize: s, extrudeBevelSegments: a } });
    return Object.assign(f, { userData: __spreadProps(__spreadValues({}, i), { type: "PolygonGeometry" }) });
  }
};
var Wm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, radialSegments: 4, heightSegments: 1, cornerRadius: 0, cornerSegments: 8, openEnded: false }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width) }) };
  }
  static build(i) {
    let { width: r, height: e, depth: t, radialSegments: o, heightSegments: n, openEnded: s, cornerRadius: a, cornerSegments: l } = i.parameters, c = new yl(r * 0.5, e, o, n, s, a, l);
    return c.scale(1, 1, t / r), Object.assign(c, { userData: __spreadProps(__spreadValues({}, i), { type: "PyramidGeometry" }) });
  }
};
function Wn(i, r, e) {
  e.x = i.x * r.x, e.y = i.y, e.z = i.x * r.y;
}
function gl(i, r, e, t, o, n) {
  let s = r.clone().sub(i), a = e.clone().sub(i), l = s.angleTo(a);
  if (s.normalize(), a.normalize(), t === o) {
    let c = s.add(a).normalize();
    n.copy(i).addScaledVector(c, t / Math.sin(l / 2));
  } else {
    let c = s.angleTo(a);
    n.copy(i), n.addScaledVector(s, o / Math.sin(c)), n.addScaledVector(a, t / Math.sin(c));
  }
}
function Gb(i, r, e) {
  let t = i.clone().sub(r), o = e.clone().sub(r);
  return t.projectOnVector(o), t.add(r);
}
var yl = class extends BufferGeometry {
  constructor(r = 0.5, e = 1, t = 4, o = 1, n = false, s = 0, a = 4) {
    super(), t = Math.floor(Math.max(3, t)), o = Math.floor(o), a = Math.floor(a);
    let l = [], c = [], u = [], m = [], p = 0, d = e / 2, f = Math.PI / t, g = r * Math.cos(Math.PI / t), x = 2 * Math.PI / t, y = (t - 2) * Math.PI / t, v = Math.PI - y, P = new Vector3(0, -d, 0), S = new Vector3(0, d, 0), b = new Vector2(r, -d), E = new Vector2(g, -d), w = new Vector2(0, S.y).sub(E), h = new Vector2(0, S.y).sub(b), _ = new Vector2(w.y, -w.x).normalize(), N = new Vector2(h.y, -h.x).normalize(), L = r * Math.cos(Math.PI / t) * Math.tan((Math.PI - w.angle()) / 2) - 1e-8;
    s = Math.min(s, L);
    let A;
    {
      let U = new Vector3(_.x, _.y, 0), z = new Vector3(Math.cos(x) * U.x, U.y, Math.sin(x) * U.x);
      A = U.angleTo(z);
    }
    let k = s / Math.tan((Math.PI - w.angle()) / 2), q = s / Math.tan((Math.PI - A) / 2), oe = new Vector3();
    if (!n) {
      c.push(P.x, P.y, P.z), u.push(0, -1, 0), m.push(0, 0);
      let U = p++, z = [], B = b.clone(), D = k / Math.cos(Math.PI / t);
      B.x -= D;
      for (let M = 0; M < t; M++) {
        let G = M / t * Math.PI * 2 + f, Q = new Vector2(Math.sin(G), Math.cos(G));
        Wn(B, Q, oe), c.push(oe.x, oe.y, oe.z), u.push(0, -1, 0), m.push(0, 0), z.push(p++);
      }
      for (let M = 0; M < z.length; M++)
        l.push(z[M], U, z[(M + 1) % z.length]);
    }
    let ce = [];
    {
      let U = new Vector3(), z = new Vector3(), B = new Vector3(), D = new Vector3(), M = new Vector3(), G = new Vector3();
      for (let Q = 0; Q < t; Q++) {
        let j = Q / t * Math.PI * 2 + f, V = (Q + 0.5) / t * Math.PI * 2 + f, F = (Q + 1) / t * Math.PI * 2 + f, O = new Vector2(Math.sin(j), Math.cos(j)), $ = new Vector2(Math.sin(V), Math.cos(V)), Z = new Vector2(Math.sin(F), Math.cos(F));
        Wn(b, O, z), Wn(b, Z, B), Wn(_, $, U), gl(S, z, B, q, q, D), c.push(D.x, D.y, D.z), gl(z, S, B, q, k, M), c.push(M.x, M.y, M.z), gl(B, z, S, k, q, G), c.push(G.x, G.y, G.z), u.push(U.x, U.y, U.z), u.push(U.x, U.y, U.z), u.push(U.x, U.y, U.z), m.push(0, 0), m.push(0, 0), m.push(0, 0);
        let ee = p++, H = p++, J = p++;
        if (l.push(ee, H, J), s > 0) {
          {
            let le = z.clone().add(B).multiplyScalar(0.5), ne = S.clone().sub(le).normalize(), Me = P.clone().sub(le).normalize().add(ne).normalize().multiplyScalar(-1), he = G.clone().sub(M);
            ie(le, he, Me, w.angle());
          }
          let X, re;
          {
            let le = new Vector3();
            Wn(N, Z, le);
            let ne = G.clone().add(D).multiplyScalar(0.5);
            ne = Gb(ne, B, S);
            let de = G.clone().sub(D);
            [X, re] = ie(ne, de, le, A, D.y);
          }
          {
            let le = X, ne = le.clone().setY(0).normalize(), de = new Vector3(0, -1, 0), Me = ne.clone().cross(de);
            K(le, ne, de, Me);
          }
          ce.concat(re);
          {
            let le = w.angle(), ne = Math.PI - le, de = S.clone();
            de.y -= s / Math.sin(le - Math.PI / 2);
            let Me = new Vector3(), he = [];
            for (let be = 0; be < a; be++) {
              let ct = [], St = Math.PI / 2 - ne * be / a, po = Math.cos(St), ht = Math.sin(St), mo = V;
              for (let Si = 0; Si <= be; Si++) {
                let wi = Math.cos(mo), _e = Math.sin(mo);
                U.x = po * _e, U.y = ht, U.z = po * wi, Me.copy(de).addScaledVector(U, s), c.push(Me.x, Me.y, Me.z), u.push(U.x, U.y, U.z), m.push(0, 0), ct.push(p++), mo += Math.PI * 2 / be / t;
              }
              he.push(ct);
            }
            re.reverse(), he.push(re);
            let Be = he.length - 1;
            for (let be = 0; be < Be; be++) {
              let ct = he[be], St = he[be + 1], po = ct.length - 1;
              l.push(St[1], ct[0], St[0]);
              for (let ht = 1; ht <= po; ht++)
                l.push(ct[ht], ct[ht - 1], St[ht]), l.push(St[ht + 1], ct[ht], St[ht]);
            }
          }
        }
      }
    }
    this.setIndex(l), this.setAttribute("position", new Float32BufferAttribute(c, 3)), this.setAttribute("normal", new Float32BufferAttribute(u, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2));
    function ie(U, z, B, D, M) {
      let G = -D / 2, Q = (Math.PI - D) / 2, j = z.clone().normalize().cross(B);
      U.addScaledVector(B, -s / Math.sin(Q));
      let V = new Vector3(), F = new Vector3(), O = 1, $ = p, Z = [];
      for (let ee = 0; ee <= a; ee++) {
        let H = G + ee / a * D;
        F.set(0, 0, 0), F.addScaledVector(j, Math.sin(H)), F.addScaledVector(B, Math.cos(H));
        for (let J = 0; J <= O; J++) {
          let X = J / O - 0.5;
          if (V.copy(U), V.addScaledVector(z, X), V.addScaledVector(F, s), M != null) {
            let re = Math.max(0, V.y - M);
            V.addScaledVector(z, -re / z.y);
          }
          c.push(V.x, V.y, V.z), u.push(F.x, F.y, F.z), m.push(0, 0), J === 0 && Z.push(p), p++;
        }
      }
      for (let ee = 0; ee < a; ee++)
        for (let H = 0; H < O; H++) {
          let J = $ + H + (O + 1) * ee, X = J + (O + 1), re = X + 1, le = J + 1;
          l.push(J, X, le), l.push(X, re, le);
        }
      return [U.clone().addScaledVector(z, 0.5), Z];
    }
    function K(U, z, B, D) {
      let M = Math.PI / 2, G = h.angle() - M, Q = [], j = new Vector3(), V = new Vector3();
      for (let O = 0; O <= a; O++) {
        let $ = [], Z = O / a;
        for (let ee = 0; ee <= O; ee++) {
          let J = ((O ? ee / O : 0) - 0.5) * v, X = Math.cos(J), re = Math.sin(J), le = Math.atan(Math.tan(G) * X), ne = (M + le) * Z, de = Math.cos(ne), Me = Math.sin(ne);
          j.set(0, 0, 0), j.addScaledVector(z, Me * X), j.addScaledVector(B, de), j.addScaledVector(D, Me * re), V.copy(U).addScaledVector(j, s), c.push(V.x, V.y, V.z), u.push(j.x, j.y, j.z), m.push(0, 0), $.push(p++);
        }
        Q.push($);
      }
      let F = Q.length - 1;
      for (let O = 0; O < F; O++) {
        let $ = Q[O], Z = Q[O + 1], ee = $.length - 1;
        l.push($[0], Z[1], Z[0]);
        for (let H = 1; H <= ee; H++)
          l.push($[H - 1], $[H], Z[H]), l.push($[H], Z[H + 1], Z[H]);
      }
    }
  }
};
var qm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2, _d2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, depth: 0, cornerRadius: [0, 0, 0, 0], cornerType: 1, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, i.parameters), t = Object.assign((_b2 = r == null ? void 0 : r.ui) != null ? _b2 : { enabledIndieCorners: false }, i.ui);
    return { shape: i.shape && i.shape instanceof Se ? i.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_c2 = e.height) != null ? _c2 : e.width), depth: Math.abs((_d2 = e.depth) != null ? _d2 : 0) }), ui: t };
  }
  static build(i) {
    let r = i.shape, { width: e, height: t, cornerRadius: o, cornerType: n, depth: s, extrudeBevelSize: a, extrudeBevelSegments: l } = i.parameters, c = { x: e * 0.5, y: t * 0.5 }, u = { x: -c.x, y: -c.y }, m = { x: c.x, y: c.y };
    function p(S, b, E) {
      return b > e && E > t ? Math.min(S * e / b, S * t / E) : b > e ? S * e / b : E > t ? S * t / E : S;
    }
    let d = [];
    d[0] = o[0] === 0 ? 0 : p(o[0], o[0] + o[3], o[0] + o[1]), d[1] = o[1] === 0 ? 0 : p(o[1], o[1] + o[2], o[1] + o[0]), d[2] = o[2] === 0 ? 0 : p(o[2], o[2] + o[1], o[2] + o[3]), d[3] = o[3] === 0 ? 0 : p(o[3], o[3] + o[0], o[3] + o[2]);
    let f = u.x, g = m.x, x = m.y, y = u.y;
    r.addPoint(r.createPoint(f, x)), r.addPoint(r.createPoint(g, x)), r.addPoint(r.createPoint(g, y)), r.addPoint(r.createPoint(f, y)), r.isClosed = true;
    let v = true;
    for (let S = 0, b = r.points.length; S < b; S++)
      r.points[S].roundness = d[S], S > 0 && d[S] !== d[S - 1] && (v = false);
    v && (r.roundness = d[0]), r.useCubicForRoundedCorners = n !== 1, r.update();
    let P = st.create({ shape: r, parameters: { depth: s, extrudeBevelSize: a, extrudeBevelSegments: l } });
    return Object.assign(P, { userData: __spreadProps(__spreadValues({}, i), { type: "RectangleGeometry" }) });
  }
};
var $m = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, widthSegments: 64, heightSegments: 64, phiStart: 0, phiLength: 2 * Math.PI, thetaStart: 0, thetaLength: Math.PI }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width) }) };
  }
  static build(i) {
    let { width: r = 100, height: e = r, depth: t = r, widthSegments: o = 64, heightSegments: n = 64, phiStart: s, phiLength: a, thetaStart: l, thetaLength: c } = i.parameters, u = new SphereGeometry(0.5 * r, o, n, s, a, l, c);
    return u.scale(1, e / r, t / r), Object.assign(u, { userData: __spreadProps(__spreadValues({}, i), { type: "SphereGeometry" }) });
  }
};
var Xm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, depth: 0, widthSegments: 8, heightSegments: 8 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: 0 }) };
  }
  static build(i) {
    let { width: r = 100, height: e = r, widthSegments: t = 8, heightSegments: o = 8 } = i.parameters, n = new PlaneGeometry(r, e, t, o);
    return n.scale(1, 1, 1), Object.assign(n, { userData: __spreadProps(__spreadValues({}, i), { type: "PlaneGeometry" }) });
  }
};
var Ym = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, angle: 90, cornerRadius: 24, cornerSegments: 8 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width) }) };
  }
  static build(i) {
    let { width: r, height: e, depth: t, angle: o, cornerRadius: n, cornerSegments: s } = i.parameters, a = new vl(r, e, t, o, n, s);
    return Object.assign(a, { userData: __spreadProps(__spreadValues({}, i), { type: "BackdropGeometry" }) });
  }
};
var vl = class extends BufferGeometry {
  constructor(r = 1, e = 1, t = 1, o = 90, n = 10, s = 24) {
    super(), this.type = "BackdropGeometry";
    let a = [], l = [], c = [], u = 1e-3;
    n == 0 && (s = 1), s = Math.max(1, Math.floor(s)), n = Math.min(n, 100), o = Math.min(180 - u, o), o *= Math.PI / 180;
    let m = [], p = Math.PI / 2, d = (V = 0, F = 0, O = 0) => new Vector3(V, F, O), f = d(), g = d(), [x, y, v] = [e / 2, r / 2, t / 2], P = -y, S = +y, [b, E, w] = [d(P, -x, +v), d(P, -x, -v), d(P, +x, -v)], h = (V, F = false) => Math.sin(V - Math.PI / (1 + +F)), _ = (V, F = false) => Math.cos(V - Math.PI / (1 + +F));
    w.y = Math.sin(o) * e - x;
    let N = Math.cos(o) * e - v, I = b.z - u;
    o <= p ? (w.z = Math.min(N, I), w.z == I && (w.y -= (N - I) / Math.tan(p - o))) : E.z = Math.min(E.z - N - v, b.z - u), f.subVectors(b, E), g.subVectors(w, E);
    let L = Math.min(f.length(), g.length()) * n / 100, A = L * Math.tan(o / 2), k = L / Math.cos(o / 2), q = f.clone().normalize().add(g.normalize()).setLength(k).add(E);
    f.set(0, h(o, true), _(o, true)), m.push([w, f.clone()]);
    let oe = (Math.PI - o) / s;
    for (let V = 0; V <= s; V++) {
      let F = p + o + V * oe;
      f.set(0, Math.sin(F) * A, Math.cos(F) * A), f.add(q), g.set(0, h(F), _(F)), m.push([f.clone(), g.clone()]);
    }
    m.push([b, d(0, 1, 0)]);
    let ce = Math.sin(oe / 2) * A * 2, ie = m.length - 1, K = m[0][0].distanceTo(m[1][0]), U = m[ie - 1][0].distanceTo(m[ie][0]), z = K + ce * s + U;
    m[0].push(1);
    for (let V = 0; V <= s; V++)
      m[V + 1].push(1 - (K + V * ce) / z);
    m[ie].push(0);
    let [B, D, M] = m[0], G, Q, j;
    for (let V = 1; V < m.length; V++)
      [G, Q, j] = m[V], a.push(P, B.y, B.z, P, G.y, G.z, S, B.y, B.z, S, B.y, B.z, P, G.y, G.z, S, G.y, G.z), l.push(0, D.y, D.z, 0, Q.y, Q.z, 0, D.y, D.z, 0, D.y, D.z, 0, Q.y, Q.z, 0, Q.y, Q.z), c.push(0, M, 0, j, 1, M, 1, M, 0, j, 1, j), [B, D, M] = [G, Q, j];
    this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2));
  }
};
var Km = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, depth: 0, innerRadiusPercent: 38.19, spikes: 5, cornerRadius: 0, angle: 360, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, i.parameters);
    return { shape: i.shape && i.shape instanceof Se ? i.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : 0) }) };
  }
  static build(i) {
    let { width: r, height: e, innerRadiusPercent: t, spikes: o, cornerRadius: n, angle: s, depth: a, extrudeBevelSize: l, extrudeBevelSegments: c } = i.parameters, u = i.shape, m = r * 0.5, p = e * 0.5, d = 0, f = 0, g = s * Math.PI / 360 / o, x = Math.PI / 2 * 3 * -1, y = m * t / 100, v = p * t / 100;
    if (o === 3 && t === 50) {
      g = 2 * Math.PI / o;
      for (let S = 0; S < o; S++) {
        let b = g * S, E = d + Math.sin(b) * m, w = f + Math.cos(b) * p;
        u.addPoint(u.createPoint(E, w));
      }
    } else
      for (let S = 0; S < o; S++) {
        let b = d + Math.cos(x) * m, E = f + Math.sin(x) * p;
        u.addPoint(u.createPoint(b, E)), x += g, b = d + Math.cos(x) * y, E = f + Math.sin(x) * v, S <= o, u.addPoint(u.createPoint(b, E)), x += g;
      }
    u.isClosed = true;
    for (let S = 0, b = u.points.length; S < b; S++)
      u.points[S].roundness = n;
    u.roundness = n, u.update();
    let P = st.create({ shape: u, parameters: { roundness: n, depth: a, extrudeBevelSize: l, extrudeBevelSegments: c } });
    return Object.assign(P, { userData: __spreadProps(__spreadValues({}, i), { type: "StarGeometry" }) });
  }
};
var js = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, depth: 0 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : 0) }) };
  }
  static build(i) {
    let { width: r, height: e } = i.parameters, t = new PlaneGeometry(r, e);
    return Object.assign(t, { userData: __spreadProps(__spreadValues({}, i), { type: "TextFrameGeometry" }) });
  }
};
var Qm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, radialSegments: 32, tubularSegments: 64, arc: Math.PI * 2, cornerRadius: 30, cornerSegments: 8 }, i.parameters), t = Math.abs(e.width), o = Math.abs((_b2 = e.height) != null ? _b2 : e.width), n = Math.abs((_c2 = e.depth) != null ? _c2 : e.width * 0.25);
    return { parameters: Object.assign(e, { width: t, height: o, depth: n }) };
  }
  static build(i) {
    let { width: r, height: e, depth: t, radialSegments: o, tubularSegments: n, arc: s, cornerRadius: a, cornerSegments: l } = i.parameters, c = jb(r, e, t, r * 0.5, s, n, 0, 0, o, a, l);
    return c.scale(1, e / r, 1), Object.assign(c, { userData: __spreadProps(__spreadValues({}, i), { type: "TorusGeometry" }) });
  }
};
function jb(i, r, e, t, o, n, s, a, l, c, u) {
  return [r, e] = [e, r], s = r / 2, o /= 2 * Math.PI, o == 1 && (c = 0), new jn(true, i, r, e, t, o, n, s, a, l, c, u);
}
var Jm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2, _d2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, tubularSegments: 64, radialSegments: 32, p: 2, q: 3 }, i.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width), depth: Math.abs((_c2 = e.depth) != null ? _c2 : e.width), tube: (_d2 = e.tube) != null ? _d2 : e.width * 0.125 }) };
  }
  static build(i) {
    let { width: r, tube: e, tubularSegments: t, radialSegments: o, p: n, q: s } = i.parameters, a = r * 0.5;
    a !== e && (a -= e);
    let l = new TorusKnotGeometry(a, e, t, o, n, s);
    return Object.assign(l, { userData: __spreadProps(__spreadValues({}, i), { type: "TorusKnotGeometry" }) });
  }
};
var Zm = class {
  static create(i) {
    return this.build(this.normalizeInputs(i));
  }
  static normalizeInputs(i, r) {
    var _a2, _b2, _c2;
    let e = Object.assign({}, (_a2 = r == null ? void 0 : r.parameters) != null ? _a2 : { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1, isRect: false }, i.parameters);
    return { shape: i.shape && i.shape instanceof Se ? i.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs((_b2 = e.height) != null ? _b2 : e.width * (e.isRect ? 1 : Math.sqrt(3) / 2)), depth: Math.abs((_c2 = e.depth) != null ? _c2 : 0) }) };
  }
  static build(i) {
    let { width: r = 100, height: e, cornerRadius: t, depth: o, extrudeBevelSize: n, extrudeBevelSegments: s, isRect: a } = i.parameters, l = i.shape, c = r * 0.5, u = e * 0.5;
    a ? (l.addPoint(l.createPoint(-c, u)), l.addPoint(l.createPoint(c, -u)), l.addPoint(l.createPoint(-c, -u))) : (l.addPoint(l.createPoint(0, u)), l.addPoint(l.createPoint(c, -u)), l.addPoint(l.createPoint(-c, -u))), l.isClosed = true;
    for (let p = 0, d = l.points.length; p < d; p++)
      l.points[p].roundness = t;
    l.roundness = t, l.update();
    let m = st.create({ shape: l, parameters: { roundness: t, depth: o, extrudeBevelSize: n, extrudeBevelSegments: s } });
    return Object.assign(m, { userData: __spreadProps(__spreadValues({}, i), { type: "TriangleGeometry" }) });
  }
};
var Hb;
var ks = new Promise((i) => {
  Hb = i;
});
function ze(i, r) {
  return r.color(i);
}
var bl = (i) => "isEntity" in i;
var Qt = (i) => "isAbstractMesh" in i;
var Jt = (i) => i !== null && i.isBooleanMesh;
var td = (i) => i.objectType === "CombinedCamera";
var wr = (i) => "objectHelper" in i;
function Wb(i, r) {
  var _a2;
  let e = false;
  r.position && (i.position.fromArray(r.position), e = true), r.rotation && (i.rotation.fromArray(r.rotation), e = true), r.scale && (e = true, i.scale.fromArray(r.scale)), r.hiddenMatrix !== void 0 && "hiddenMatrix" in i && (e = true, i.hiddenMatrix.fromArray((_a2 = r.hiddenMatrix) != null ? _a2 : _r.identity)), e && (i.updateMatrix(), Jt(i.parent) && Qt(i) && i.invalidateDownstreamBooleanData(true).recomputeBoolean()), r.position && r.rotation && r.scale && r.hiddenMatrix !== void 0 && i.updateWorldMatrix(false, true), i.objectType === "CombinedCamera" && (r.isUpVectorFlipped !== void 0 && (i.isUpVectorFlipped = r.isUpVectorFlipped), i.updateUp());
}
function qb(i, r) {
  Wb(i, r), r.name !== void 0 && (i.name = r.name), r.visible !== void 0 && (i.isEntity ? i.visibility = r.visible : i.visible = r.visible);
}
function rd(i, r, e) {
  qb(i, r), r.color !== void 0 && (i.color = ze(r.color, e)), r.intensity !== void 0 && (i.intensity = r.intensity), r.shadows !== void 0 && !(i instanceof HemisphereLight) && (i.castShadow = r.shadows), i.shadow && !(i instanceof HemisphereLight) && r.depth !== void 0 && (i.shadow.camera.far = r.depth, i.shadow.needsUpdate = true), r.helper !== void 0 && wr(i) && (i.enableHelper = r.helper, i.gizmos.shadowmap.visible = r.helper);
}
function od(i, r) {
  i.shadow.camera.right = r / 2, i.shadow.camera.left = -r / 2, i.shadow.camera.top = r / 2, i.shadow.camera.bottom = -r / 2, i.shadow.needsUpdate = true;
}
var Ko = new Box3();
var Zt = new Vector3();
var er = new Vector3();
var Qo = new Matrix4();
var sd = [new Vector3(-1, 1, 1), new Vector3(-1, -1, 1), new Vector3(1, -1, 1), new Vector3(1, 1, 1), new Vector3(-1, 1, -1), new Vector3(-1, -1, -1), new Vector3(1, -1, -1), new Vector3(1, 1, -1)];
var Xb = [[0, 3], [1, 2], [5, 6], [4, 7], [0, 1], [3, 2], [7, 6], [4, 5], [0, 4], [1, 5], [2, 6], [3, 7]];
var Yb = [[0, 2], [7, 5], [4, 1], [3, 6], [4, 3], [1, 6]];
function Kb(i, r, e = 0, t = r.count) {
  let o = 1 / 0, n = 1 / 0, s = 1 / 0, a = -1 / 0, l = -1 / 0, c = -1 / 0;
  for (let u = e; u < t; u++) {
    let m = r.getX(u), p = r.getY(u), d = r.getZ(u);
    m < o && (o = m), p < n && (n = p), d < s && (s = d), m > a && (a = m), p > l && (l = p), d > c && (c = d);
  }
  return i.min.set(o, n, s), i.max.set(a, l, c), i;
}
var nd = (i, r, e, t) => {
  var _a2;
  if (Qt(i)) {
    let o = i.geometry.userData.parameters, n = i.geometry.getAttribute("position");
    i.geometry.userData.type === "SubdivGeometry" ? Zt.copy(i.originalGeometry.boundingSphere.center) : n !== void 0 && (Kb(Ko, n, i.geometry.drawRange.start, i.geometry.drawRange.count < 1 / 0 ? i.geometry.drawRange.count : n.count), Ko.getCenter(Zt)), i.forceComputeSize ? Ko.getSize(er).multiplyScalar(0.5) : er.set(o.width, o.height, (_a2 = o.depth) != null ? _a2 : 0).multiplyScalar(0.5);
  } else if (wr(i) && t === true) {
    let o = i.geometryHelper.getAttribute("position");
    Ko.setFromArray(o.array), Ko.getCenter(Zt), Ko.getSize(er).multiplyScalar(0.5);
  } else
    Zt.setScalar(0), er.setScalar(0);
  Qo.copy(r).multiply(i.matrixWorld), er.x === 0 && er.y === 0 && er.z === 0 ? e.push(new Vector3(Zt.x, Zt.y, Zt.z).applyMatrix4(Qo)) : sd.forEach((o) => {
    e.push(o.clone().multiply(er).add(Zt).applyMatrix4(Qo));
  });
};
var qn = class extends Box3 {
  constructor() {
    super(...arguments);
    this.matrix = new Matrix4();
    this.vertices = [];
    this.faces = [];
    this.edges = [];
    this.centerEdges = [];
  }
  copy(e) {
    return super.copy(e), this.matrix.copy(e.matrix), this.vertices = e.vertices.map((t) => t.clone()), this.faces = e.faces.map((t) => t.clone()), this.edges = e.edges.map((t) => t.clone()), this.centerEdges = e.centerEdges.map((t) => t.clone()), this;
  }
  setFromObjectSize(e, t = false) {
    e.updateWorldMatrix(false, t), this.makeEmpty(), this.matrix.copy(e.matrixWorld);
    let o = new Matrix4().copy(e.matrixWorld).invert();
    return this.expandByObjectSize(e, o, t);
  }
  expandByObjectSize(e, t, o = false) {
    let n = [];
    return o === true ? e.traverseEntity((s) => {
      s.visible && nd(s, t, n, e.enableHelper === true);
    }) : nd(e, t, n, e.enableHelper === true), this.setFromPoints(n);
  }
  getCenter(e) {
    return e = super.getCenter(e), e.applyMatrix4(this.matrix), e;
  }
  getPositionToCenter(e) {
    return e = super.getCenter(e), e.applyMatrix4(Qo.copy(this.matrix).setPosition(0, 0, 0)), e;
  }
  computeVertices() {
    this.getSize(er).multiplyScalar(0.5), this.getCenter(Zt), Qo.copy(this.matrix).setPosition(Zt), this.vertices = sd.map((e) => e.clone().multiply(er).applyMatrix4(Qo));
  }
  computeEdges() {
    this.vertices.length > 0 && this.computeVertices(), this.edges = Xb.map(([e, t]) => new Line3(this.vertices[e], this.vertices[t])), this.centerEdges = this.edges.map((e) => e.getCenter(new Vector3()));
  }
  computeFaces() {
    this.vertices.length > 0 && this.computeVertices(), this.faces = Yb.map(([e, t]) => this.vertices[e].clone().add(this.vertices[t]).multiplyScalar(0.5));
  }
};
var Hs = (i) => class extends i {
  hasEntityChild() {
    return this.children.some((e) => bl(e));
  }
  isDescendantOf(e) {
    e instanceof Object3D && (e = e.uuid);
    let t = this;
    for (; t.parent; ) {
      if (t.parent.uuid === e)
        return true;
      t = t.parent;
    }
    return false;
  }
  attach(e, t) {
    this.updateWorldMatrix(true, false);
    let o = new Matrix4().copy(this.matrixWorld).invert();
    return e.parent !== null && (e.parent.updateWorldMatrix(true, false), o.multiply(e.parent.matrixWorld)), bl(e) ? e.hiddenMatrix.premultiply(o) : e.applyMatrix4(o), e.updateWorldMatrix(false, false), this.add(e), t !== void 0 && (this.children.pop(), this.children.splice(t, 0, e)), this;
  }
  copy(e, t = true) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === true)
      for (let o = 0; o < e.children.length; o++) {
        let n = e.children[o];
        this.add(n.clone());
      }
    return this;
  }
};
var Dt = (i) => "isEntity" in i;
var ld = (i) => "isAbstractMesh" in i;
var It = (i) => class extends Hs(i) {
  constructor() {
    super(...arguments);
    this.objectType = "";
    this.isEntity = true;
    this.raycastLock = false;
    this.scaleLock = false;
    this.hiddenMatrix = new Matrix4();
    this._singleBBox = new qn();
    this._recursiveBBox = new qn();
    this.singleBBoxNeedsUpdate = true;
    this.recursiveBBoxNeedsUpdate = true;
    this.forceComputeSize = false;
  }
  set visibility(t) {
    this.visible = t;
    for (let o of this.children)
      Dt(o) && o.traverseEntity((n) => {
        wr(n) && n.visible && (n.objectHelper.visible = t);
      });
  }
  get visibility() {
    return this.visible;
  }
  get singleBBox() {
    return this.singleBBoxNeedsUpdate && (this.singleBBoxNeedsUpdate = false, this._singleBBox.setFromObjectSize(this, false), this._singleBBox.computeVertices(), this._singleBBox.computeEdges(), this._singleBBox.computeFaces()), this._singleBBox;
  }
  get recursiveBBox() {
    return this.recursiveBBoxNeedsUpdate && (this.recursiveBBoxNeedsUpdate = false, this._recursiveBBox.setFromObjectSize(this, true), this._recursiveBBox.computeVertices(), this._recursiveBBox.computeEdges(), this._recursiveBBox.computeFaces()), this._recursiveBBox;
  }
  resetBBoxNeedsUpdate() {
    this.singleBBoxNeedsUpdate = true, this.recursiveBBoxNeedsUpdate = true, this.traverseAncestors((t) => {
      Dt(t) && (t.singleBBoxNeedsUpdate = true, t.recursiveBBoxNeedsUpdate = true);
    }), this.traverseEntity((t) => {
      t.singleBBoxNeedsUpdate = true, t.recursiveBBoxNeedsUpdate = true;
    });
  }
  traverseEntity(t) {
    t(this);
    for (let o of this.children)
      Dt(o) && o.traverseEntity(t);
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, t = true);
    for (let o of this.children)
      o.updateMatrixWorld(t);
  }
  updateWorldMatrix(t, o) {
    let n = this.parent;
    if (t && n !== null && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), o)
      for (let s of this.children)
        s.updateWorldMatrix(false, true);
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, o = true) {
    if (super.copy(t, false), this.raycastLock = t.raycastLock, this.scaleLock = t.scaleLock, this.hiddenMatrix.copy(t.hiddenMatrix), o === true)
      for (let n of t.children)
        Dt(n) && this.add(n.clone());
    return this;
  }
  keepChildrenMatrixWorld() {
    let t = new Matrix4(), o = this.matrixWorld.clone();
    this.updateWorldMatrix(false, false), t.copy(this.matrixWorld).invert(), t.multiply(o);
    for (let n of this.children)
      Dt(n) && n.hiddenMatrix.premultiply(t);
  }
  toObjectTransformState(t = []) {
    this.updateWorldMatrix(true, false);
    let o = { position: this.position.toArray(), rotation: [this.rotation.x, this.rotation.y, this.rotation.z], scale: this.scale.toArray(), hiddenMatrix: this.hiddenMatrix.toArray() };
    return _o(o, t);
  }
  fromObjectTransformState(t) {
    return t.position && this.position.fromArray(t.position), t.rotation && this.rotation.fromArray(t.rotation), t.scale && this.scale.fromArray(t.scale), t.hiddenMatrix && this.hiddenMatrix.fromArray(t.hiddenMatrix), this.updateMatrix(), this;
  }
  toState(t = []) {
    let o = __spreadValues({ name: this.name, visible: this.visible, raycastLock: this.raycastLock }, this.toObjectTransformState(t));
    return _o(o, t);
  }
  fromState(t, o) {
    return t.name && (this.name = t.name), t.raycastLock !== void 0 && (this.raycastLock = t.raycastLock), t.type !== "OrthographicCamera" && t.type !== "PerspectiveCamera" && (this.matrixAutoUpdate = false), t.visible !== void 0 && (this.visibility = t.visible), this.fromObjectTransformState(t), this;
  }
};
var wl = class extends Object3D {
};
var Ws = class extends wl {
  constructor(e) {
    super();
    this.object = e;
    this.matrixAutoUpdate = true;
  }
  get castShadow() {
    return this.object.castShadow;
  }
  set castShadow(e) {
  }
  get receiveShadow() {
    return this.object.receiveShadow;
  }
  set receiveShadow(e) {
  }
  get isMesh() {
    return true;
  }
  get isLight() {
    return false;
  }
  get isCamera() {
    return false;
  }
  get geometry() {
    return this.object.geometry;
  }
  get material() {
    return this.object.material;
  }
};
var eo = class extends Object3D {
  constructor(e, t = {}) {
    super();
    this.object = e;
    let o = e.recursiveBBox.getSize(new Vector3()), n = 0.1;
    this.parameters = es.defaultData(o.toArray(), n), Xr(this.parameters, t), this.update(), this.setHideBase(this.parameters.hideBase);
  }
  setHideBase(e) {
    this.parameters.hideBase = e;
  }
  update() {
    switch (this._updateCount(), this.parameters.type) {
      case "radial":
        this._updateRadial(this.parameters);
        break;
      case "linear":
        this._updateLinear(this.parameters);
        break;
      case "grid":
        this._updateGrid(this.parameters);
    }
    this.children.forEach((e) => e.updateMatrix());
  }
  _updateCount() {
    let e = this.parameters.type === "grid" ? this.parameters.grid.count[0] * this.parameters.grid.count[1] * this.parameters.grid.count[2] : this.parameters.count;
    if (this.children.length !== e)
      if (this.children.length < e)
        for (let t = 0, o = e - this.children.length; t < o; ++t) {
          let n = new Ws(this.object);
          n.visible = true, this.add(n), this.parameters.hideBase && this.setHideBase(true);
        }
      else
        for (let t = 0, o = this.children.length - e; t < o; ++t)
          this.remove(this.children[0]);
  }
  _updateRadial(e) {
    let t = e.radial, o = t.start * MathUtils.DEG2RAD, n = t.end * MathUtils.DEG2RAD, s = o - n, a = new Euler(t.rotation[0] * MathUtils.DEG2RAD, t.rotation[1] * MathUtils.DEG2RAD, t.rotation[2] * MathUtils.DEG2RAD), l;
    switch (t.axis) {
      case "z":
        l = new Vector3(0, 0, 1);
        break;
      case "y":
        l = new Vector3(0, 1, 0);
        break;
      default:
      case "x":
        l = new Vector3(1, 0, 0);
        break;
    }
    for (let [c, u] of this.children.entries()) {
      u.scale.x = t.scale[0], u.scale.y = t.scale[1], u.scale.z = t.scale[2], u.position.setScalar(0);
      let m = s / e.count * c - o;
      switch (t.axis) {
        case "x":
          u.rotation.set(0, m, 0);
          break;
        case "y":
          u.rotation.set(0, 0, m);
          break;
        case "z":
          u.rotation.set(m, 0, 0);
          break;
      }
      u.translateOnAxis(l, t.radius), u.position.x += t.position[0], u.position.y += t.position[1], u.position.z += t.position[2], t.alignment === true ? (u.rotation.x += a.x, u.rotation.y += a.y, u.rotation.z += a.z) : u.rotation.copy(a);
    }
  }
  _updateLinear(e) {
    if (e.type !== "linear")
      throw new Error();
    let t = e.linear, o = new Euler(t.rotation[0] * MathUtils.DEG2RAD, t.rotation[1] * MathUtils.DEG2RAD, t.rotation[2] * MathUtils.DEG2RAD);
    for (let [n, s] of this.children.entries())
      s.scale.x = 1 + (t.scale[0] - 1) * n, s.scale.y = 1 + (t.scale[1] - 1) * n, s.scale.z = 1 + (t.scale[2] - 1) * n, s.rotation.x = o.x * n, s.rotation.y = o.y * n, s.rotation.z = o.z * n, s.position.x = t.position[0] * n, s.position.y = t.position[1] * n, s.position.z = t.position[2] * n;
  }
  _updateGrid(e) {
    let t = 0, o = e.grid;
    if (o.useCenter === true) {
      let n = { x: o.count[0] % 2 === 0 ? 2 : 1, y: o.count[1] % 2 === 0 ? 2 : 1, z: o.count[2] % 2 === 0 ? 2 : 1 }, s = new Vector3(o.size[0] * (o.count[0] - n.x) * 0.5, o.size[1] * (o.count[1] - n.y) * 0.5, o.size[2] * (o.count[2] - n.z) * 0.5);
      for (let a = 0; a < o.count[0]; a++)
        for (let l = 0; l < o.count[1]; l++)
          for (let c = 0; c < o.count[2]; c++) {
            let u = this.children[t++];
            u.scale.setScalar(1), u.rotation.set(0, 0, 0), u.position.x = o.size[0] * a - s.x, u.position.y = o.size[1] * l - s.y, u.position.z = o.size[2] * c - s.z;
          }
    } else
      for (let n = 0; n < o.count[0]; n++)
        for (let s = 0; s < o.count[1]; s++)
          for (let a = 0; a < o.count[2]; a++) {
            let l = this.children[t++];
            l.scale.setScalar(1), l.rotation.set(0, 0, 0), l.position.x = o.size[0] * n, l.position.y = -o.size[1] * s, l.position.z = -o.size[2] * a;
          }
  }
  fromClonerState(e) {
    return e.hideBase !== void 0 && this.setHideBase(e.hideBase), Xr(this.parameters, e), this.update(), this;
  }
};
var Xn = class {
  constructor(r) {
    r = r != null ? r : {}, this.name = r.name, this.type = r.type, this.node = r.node, this.size = r.size, this.needsUpdate = r.needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(r) {
    this.node.value = r;
  }
};
var Xe = class {
  constructor(r) {
    this.hashProperties = void 0;
    this.isNode = true;
    this.shortcuts = {};
    this.uuid = MathUtils.generateUUID(), this.type = r, this.name = "";
  }
  analyze(r, e) {
    e = e != null ? e : {}, r.analyzing = true, this.build(r.addFlow(e.slot, e.cache, e.context), "v4"), r.clearVertexNodeCode(), r.clearFragmentNodeCode(), r.removeFlow(), r.analyzing = false;
  }
  analyzeAndFlow(r, e, t) {
    return t = t != null ? t : {}, this.analyze(r, t), this.flow(r, e, t);
  }
  flow(r, e, t) {
    t = t != null ? t : {}, r.addFlow(t.slot, t.cache, t.context);
    let o = { result: this.build(r, e), code: r.clearNodeCode(), extra: r.context.extra };
    return r.removeFlow(), o;
  }
  build(r, e, t) {
    e = e != null ? e : this.getType(r, e);
    let o = r.getNodeData(t != null ? t : this);
    return r.analyzing && this.appendDepsNode(r, o, e), r.nodes.indexOf(this) === -1 && r.nodes.push(this), this.updateFrame !== void 0 && r.updaters.indexOf(this) === -1 && r.updaters.push(this), this.generate(r, e, t);
  }
  updateFrame(r) {
  }
  generateReadonly(r, e, t, o, n, s) {
    return "";
  }
  generate(r, e, t, o, n) {
    return "";
  }
  parse(r, e, t, o) {
  }
  appendDepsNode(r, e, t) {
    e.deps = (e.deps || 0) + 1;
    let o = r.getTypeLength(t);
    (o > (e.outputMax || 0) || this.getType(r, t)) && (e.outputMax = o, e.output = t);
  }
  setName(r) {
    this.name = r;
  }
  getName() {
    return this.name;
  }
  getType(r, e) {
    return e === "sampler2D" || e === "samplerCube" ? e : this.type;
  }
  getHash() {
    let r = "{", e, t;
    for (e in this)
      t = this[e], t instanceof Xe && (r += '"' + e + '":' + t.getHash() + ",");
    if (this.hashProperties)
      for (let o = 0; o < this.hashProperties.length; o++)
        e = this.hashProperties[o], t = this[e], r += '"' + e + '":"' + String(t) + '",';
    return r += '"id":"' + this.uuid + '"}', r;
  }
};
var Tl = class {
  constructor() {
    this.nodes = {};
    this.keywords = {};
  }
  add(r) {
    this.nodes[r.name] = r;
  }
  addKeyword(r, e, t) {
    t = t !== void 0 ? t : true, this.keywords[r] = { callback: e, cache: t };
  }
  remove(r) {
    delete this.nodes[r.name];
  }
  removeKeyword(r) {
    delete this.keywords[r];
  }
  get(r) {
    return this.nodes[r];
  }
  getKeyword(r, e) {
    return this.keywords[r].callback(e);
  }
  getKeywordData(r) {
    return this.keywords[r];
  }
  contains(r) {
    return this.nodes[r] !== void 0;
  }
  containsKeyword(r) {
    return this.keywords[r] !== void 0;
  }
};
var je = new Tl();
var ae = class extends Xe {
  constructor(e, t) {
    super(e);
    this.scope = "";
    t = t != null ? t : {}, this.shared = t.shared !== void 0 ? t.shared : true, this.unique = t.unique !== void 0 ? t.unique : false;
  }
  build(e, t, o, n) {
    if (t = t != null ? t : this.getType(e), this.getShared(e, t)) {
      let s = this.getUnique(e, t);
      s && this.uuid === void 0 && (this.uuid = MathUtils.generateUUID()), o = e.getUUID(o != null ? o : this.getUUID(), !s);
      let a = e.getNodeData(o), l = a.output || this.getType(e);
      if (e.analyzing)
        return (a.deps || 0) > 0 || this.getLabel() ? (this.appendDepsNode(e, a, t), this.generate(e, t, o)) : super.build(e, t, o);
      if (s)
        return a.name = a.name || super.build(e, t, o), a.name;
      if (!this.getLabel() && (!this.getShared(e, l) || e.context.ignoreCache || a.deps === 1))
        return super.build(e, t, o);
      o = this.getUUID(false);
      let c = this.getTemp(e, o);
      if (c)
        return e.format(c, l, t);
      {
        c = super.generate(e, t, o, a.output, n);
        let u = this.generate(e, l, o);
        return e.addNodeCode(c + " = " + u + ";"), e.format(c, l, t);
      }
    }
    return super.build(e, t, o);
  }
  getShared(e, t) {
    return t !== "sampler2D" && t !== "samplerCube" && this.shared;
  }
  getUnique(e, t) {
    return this.unique;
  }
  setLabel(e) {
    return this.label = e, this;
  }
  getLabel() {
    return this.label;
  }
  getUUID(e) {
    let t = this.uuid;
    return typeof this.scope == "string" && (t = this.scope + "-" + t), t;
  }
  getTemp(e, t) {
    t = t || this.uuid;
    let o = e.getVars()[t];
    return o ? o.name : void 0;
  }
  generate(e, t, o, n, s) {
    return this.getShared(e, t) || console.error("TempNode is not shared"), o = o != null ? o : this.uuid, e.getTempVar(o, n != null ? n : this.getType(e), s, this.getLabel()).name;
  }
};
var Ne = class extends ae {
  constructor(e, t) {
    t = t != null ? t : {}, t.shared = t.shared !== void 0 ? t.shared : false;
    super(e, t);
    this.readonly = false;
  }
  setReadonly(e) {
    return this.readonly = e, this.hashProperties = this.readonly ? ["value"] : void 0, this;
  }
  getReadonly() {
    return this.readonly;
  }
  generate(e, t, o, n, s, a) {
    o = e.getUUID(o != null ? o : this.getUUID()), n = n != null ? n : this.getType(e);
    let l = e.getNodeData(o);
    return this.getReadonly() && this.generateReadonly !== void 0 ? this.generateReadonly(e, t, o, n, s, a) : e.isShader("vertex") ? (l.vertex || (l.vertex = e.createVertexUniform(n, this, s, a, this.getLabel())), e.format(l.vertex.name, n, t)) : (l.fragment || (l.fragment = e.createFragmentUniform(n, this, s, a, this.getLabel())), e.format(l.fragment.name, n, t));
  }
};
var ke = class extends Ne {
  constructor(e = 0, t) {
    super("v2");
    this.nodeType = "Vector2";
    this.value = e instanceof Vector2 ? e : new Vector2(e, t);
  }
  get x() {
    return this.value.x;
  }
  set x(e) {
    this.value.x = e;
  }
  get y() {
    return this.value.y;
  }
  set y(e) {
    this.value.y = e;
  }
  generateReadonly(e, t, o, n, s, a) {
    return e.format("vec2(" + this.value.x + ", " + this.value.y + ")", n, t);
  }
};
var Je = class extends Ne {
  constructor(e = 0, t, o) {
    super("v3");
    this.nodeType = "Vector3";
    this.value = e instanceof Vector3 ? e : new Vector3(e, t, o);
  }
  get x() {
    return this.value.x;
  }
  set x(e) {
    this.value.x = e;
  }
  get y() {
    return this.value.y;
  }
  set y(e) {
    this.value.y = e;
  }
  get z() {
    return this.value.z;
  }
  set z(e) {
    this.value.z = e;
  }
  generateReadonly(e, t, o, n, s, a) {
    return e.format("vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")", n, t);
  }
};
var Pt = class extends Ne {
  constructor(e) {
    super("v4");
    this.nodeType = "Vector4";
    this.value = e instanceof Qe ? e : new Qe(e.r, e.g, e.b, e.a);
  }
  generateReadonly(e, t, o, n, s, a) {
    return e.format("vec4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")", n, t);
  }
};
var oS = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i;
var md = /[a-z_0-9]+/gi;
var Y = class extends ae {
  constructor(e, t, o, n, s) {
    super(s);
    this.src = "";
    this.nodeType = "Function";
    this.useKeywords = true;
    this.includes = [];
    this.extensions = {};
    this.keywords = {};
    this.isMethod = s === void 0, this.isInterface = false, this.parse(e, t, o, n);
  }
  getShared(e, t) {
    return !this.isMethod;
  }
  getType(e) {
    return e.getTypeByFormat(this.type);
  }
  getInputByName(e) {
    if (this.inputs) {
      let t = this.inputs.length;
      for (; t--; )
        if (this.inputs[t].name === e)
          return this.inputs[t];
    }
  }
  getIncludeByName(e) {
    if (this.includes) {
      let t = this.includes.length;
      for (; t--; )
        if (this.includes[t].name === e)
          return this.includes[t];
    }
  }
  generate(e, t, o, n, s) {
    let a, l = 0, c = this.src;
    if (this.includes)
      for (let m = 0; m < this.includes.length; m++)
        e.include(this.includes[m], this);
    for (let m in this.extensions)
      e.extensions[m] = true;
    let u = [];
    for (; a = md.exec(this.src); )
      u.push(a);
    for (let m = 0; m < u.length; m++) {
      let p = u[m], d = p[0], f = this.isMethod ? !this.getInputByName(d) : true, g = d;
      if (this.keywords[d] || this.useKeywords && f && je.containsKeyword(d)) {
        let x = this.keywords[d];
        if (!x) {
          let y = je.getKeywordData(d);
          y.cache && (x = e.keywords[d]), x = x || je.getKeyword(d, e), y.cache && (e.keywords[d] = x);
        }
        g = x.build(e);
      }
      d !== g && c[p.index + l - 1] !== "." && (c = c.substring(0, p.index + l) + g + c.substring(p.index + d.length + l), l += g.length - d.length), this.getIncludeByName(g) === void 0 && je.contains(g) && e.include(je.get(g));
    }
    return t === "source" ? c : this.isMethod ? (this.isInterface || e.include(this, void 0, c), this.name) : e.format("( " + c + " )", this.getType(e), t);
  }
  parse(e, t, o, n) {
    if (this.src = e || "", this.includes = t != null ? t : [], this.extensions = o != null ? o : {}, this.keywords = n != null ? n : {}, this.isMethod) {
      let s = oS.exec(this.src);
      if (this.inputs = [], s && s.length == 4) {
        this.type = s[1], this.name = s[2];
        let a = s[3].match(md);
        if (a) {
          let l = 0;
          for (; l < a.length; ) {
            let c = a[l++], u;
            c === "in" || c === "out" || c === "inout" ? u = a[l++] : (u = c, c = "");
            let m = a[l++];
            this.inputs.push({ name: m, type: u, qualifier: c });
          }
        }
        this.isInterface = this.src.indexOf("{") === -1;
      } else
        this.type = "", this.name = "";
    }
  }
};
var nS = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i;
var Nl = class extends ae {
  constructor(e = "", t) {
    super();
    this.src = "";
    this.useDefine = false;
    this.nodeType = "Const";
    this.parse(e || Nl.PI, void 0, void 0, void 0, t);
  }
  getType(e) {
    return e.getTypeByFormat(this.type);
  }
  parse(e, t, o, n, s) {
    this.src = e || "";
    let a, l, c = "", u = nS.exec(e);
    this.useDefine = s != null ? s : this.src.charAt(0) === "#", u && u.length > 1 ? (l = u[1], a = u[2], c = u[3]) : (a = this.src, l = "f"), this.name = a, this.type = l, this.value = c;
  }
  build(e, t) {
    if (t === "source") {
      if (this.value)
        return this.useDefine ? "#define " + this.name + " " + this.value : "const " + this.type + " " + this.name + " = " + this.value + ";";
      if (this.useDefine)
        return this.src;
    }
    return e.include(this), e.format(this.name, this.getType(e), t);
  }
  generate(e, t, o, n, s) {
    return e.format(this.name, this.getType(e), t);
  }
};
var ye = Nl;
ye.PI = "PI", ye.PI2 = "PI2", ye.RECIPROCAL_PI = "RECIPROCAL_PI", ye.RECIPROCAL_PI2 = "RECIPROCAL_PI2", ye.LOG2 = "LOG2", ye.EPSILON = "EPSILON";
var iS = new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`, "gim");
var sS = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim");
var Jo = class extends ae {
  constructor(e = "") {
    super();
    this.inputs = [];
    this.src = "";
    this.nodeType = "Struct";
    this.parse(e);
  }
  getType(e) {
    return e.getTypeByFormat(this.name);
  }
  getInputByName(e) {
    let t = this.inputs.length;
    for (; t--; )
      if (this.inputs[t].name === e)
        return this.inputs[t];
  }
  generate(e, t, o, n, s) {
    return t === "source" ? this.src + ";" : e.format("( " + this.src + " )", this.getType(e), t);
  }
  parse(e = "") {
    this.src = e, this.inputs = [];
    let t = iS.exec(e);
    if (t) {
      let o = t[2], n;
      for (; n = sS.exec(o); )
        this.inputs.push({ type: n[1], name: n[2] });
      this.name = t[1];
    } else
      this.name = "";
    this.type = this.name;
  }
};
var Zo = class extends ae {
  constructor(e) {
    super("v2", { shared: false });
    this.nodeType = "UV";
    this.index = e != null ? e : 0;
  }
  generate(e, t) {
    e.requires.uv[this.index] = true;
    let o = this.index > 0 ? this.index + 1 : "", n = e.isShader("vertex") ? "uv" + o : "vUv" + o;
    return e.format(n, this.getType(e), t);
  }
};
je.addKeyword("uv", function() {
  return new Zo();
});
je.addKeyword("uv2", function() {
  return new Zo(1);
});
var to = class extends ae {
  constructor(e, t) {
    super("v4");
    this.nodeType = "ColorSpace";
    this.input = e, this.method = t != null ? t : to.LINEAR_TO_LINEAR, this.hashProperties = ["method"];
  }
  static getEncodingComponents(e) {
    switch (e) {
      case LinearEncoding:
        return ["Linear"];
      case sRGBEncoding:
        return ["sRGB"];
      default:
        return [];
    }
  }
  generate(e, t) {
    var _a2;
    let o = this.input.build(e, "v4"), n = this.getType(e), s = to.Nodes[this.method], a = e.include(s);
    if (a === to.LINEAR_TO_LINEAR)
      return e.format(o, n, t);
    if (((_a2 = s.inputs) == null ? void 0 : _a2.length) === 2) {
      let l = this.factor.build(e, "f");
      return e.format(a + "( " + o + ", " + l + " )", n, t);
    } else
      return e.format(a + "( " + o + " )", n, t);
  }
  fromEncoding(e) {
    let t = to.getEncodingComponents(e);
    this.method = "LinearTo" + t[0], this.factor = t[1];
  }
  fromDecoding(e) {
    let t = to.getEncodingComponents(e);
    this.method = t[0] + "ToLinear", this.factor = t[1];
  }
};
var at = to;
at.Nodes = { LinearToLinear: new Y(["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)), sRGBToLinear: new Y(["vec4 sRGBToLinear( in vec4 value ) {", "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );", "}"].join(`
`)), LinearTosRGB: new Y(["vec4 LinearTosRGB( in vec4 value ) {", "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );", "}"].join(`
`)) }, at.LINEAR_TO_LINEAR = "LinearToLinear", at.SRGB_TO_LINEAR = "sRGBToLinear", at.LINEAR_TO_SRGB = "LinearTosRGB";
var ve = class extends Y {
  constructor(e = "", t, o, n, s) {
    super(e, s, n, o, t);
    this.nodeType = "Expression";
  }
};
var lt = class extends Ne {
  constructor(e = new Texture(), t, o, n) {
    super("v4", { shared: true });
    this.nodeType = "Texture";
    this.value = e, this.uv = t != null ? t : new Zo(), this.bias = o, this.project = n !== void 0 ? n : false;
  }
  getTexture(e, t) {
    return super.generate(e, t, this.value.uuid, "t");
  }
  generate(e, t) {
    var _a2;
    if (t === "sampler2D")
      return this.getTexture(e, t);
    let o = this.getTexture(e, t), n = this.uv.build(e, this.project ? "v4" : "v2"), s = this.bias ? this.bias.build(e, "f") : void 0;
    s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
    let a, l;
    this.project ? a = "texture2DProj" : a = s ? "tex2DBias" : "tex2D", s ? l = a + "( " + o + ", " + n + ", " + s + " )" : l = a + "( " + o + ", " + n + " )";
    let c = { include: e.isShader("vertex"), ignoreCache: true }, u = this.getType(e);
    return e.addContext(c), this.colorSpace = (_a2 = this.colorSpace) != null ? _a2 : new at(new ve("", u)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(l), l = this.colorSpace.build(e, u), e.removeContext(), e.format(l, u, t);
  }
};
var W = class extends Ne {
  constructor(e) {
    super("f");
    this.nodeType = "Float";
    this.value = e != null ? e : 0;
  }
  generateReadonly(e, t, o, n, s, a) {
    return e.format(this.value + (this.value % 1 ? "" : ".0"), n, t);
  }
};
var Yn = class extends ae {
  constructor(e, t) {
    super();
    this.inputs = [];
    this.nodeType = "FunctionCall";
    this.value = e, this.inputs = t != null ? t : [];
  }
  getFunction() {
    return this.value;
  }
  getType(e) {
    return this.value.getType(e);
  }
  generate(e, t, o, n, s) {
    n = this.getType(e);
    let a = this.value, l = a.build(e, t) + "( ", c = [];
    if (a.inputs) {
      for (let u = 0; u < a.inputs.length; u++) {
        let m = a.inputs[u], p = this.inputs[u] || this.inputs[m.name];
        c.push(p.build(e, e.getTypeByFormat(m.type)));
      }
      l += c.join(", ") + " )";
    }
    return e.format(l, n, t);
  }
};
var Cl = class extends ae {
  constructor(e, t, o = Cl.ADD) {
    super();
    this.nodeType = "Operator";
    this.type = e.type, this.a = e, this.b = t, this.op = o;
  }
  getType(e) {
    let t = this.a.getType(e), o = this.b.getType(e);
    return e.isTypeMatrix(t) ? "v4" : e.getTypeLength(o) > e.getTypeLength(t) ? o : t;
  }
  generate(e, t) {
    let o = this.getType(e);
    this.type = o;
    let n = this.a.build(e, o), s = this.b.build(e, o);
    return e.format("( " + n + " " + this.op + " " + s + " )", o, t);
  }
};
var dt = Cl;
dt.ADD = "+", dt.SUB = "-", dt.MUL = "*", dt.DIV = "/";
var Ce = class extends ae {
  constructor(e, t = Ce.ABS, o, n) {
    super();
    this.nodeType = "Math";
    this.a = e, typeof t != "string" ? this.b = t : n = t, typeof o != "string" ? this.c = o : n = o, this.method = n, this.hashProperties = ["method"];
  }
  getNumInputs(e) {
    switch (this.method) {
      case Ce.MIX:
      case Ce.CLAMP:
      case Ce.REFRACT:
      case Ce.SMOOTHSTEP:
      case Ce.FACEFORWARD:
        return 3;
      case Ce.MIN:
      case Ce.MAX:
      case Ce.MOD:
      case Ce.STEP:
      case Ce.REFLECT:
      case Ce.DISTANCE:
      case Ce.DOT:
      case Ce.CROSS:
      case Ce.POW:
        return 2;
      default:
        return 1;
    }
  }
  getInputType(e) {
    let t = e.getTypeLength(this.a.getType(e)), o = this.b ? e.getTypeLength(this.b.getType(e)) : 0, n = this.c ? e.getTypeLength(this.c.getType(e)) : 0;
    return t > o && t > n ? this.a.getType(e) : o > n ? this.b.getType(e) : this.c.getType(e);
  }
  getType(e) {
    switch (this.method) {
      case Ce.LENGTH:
      case Ce.DISTANCE:
      case Ce.DOT:
        return "f";
      case Ce.CROSS:
        return "v3";
    }
    return this.getInputType(e);
  }
  generate(e, t) {
    let o, n, s, a = this.a ? e.getTypeLength(this.a.getType(e)) : 0, l = this.b ? e.getTypeLength(this.b.getType(e)) : 0, c = this.c ? e.getTypeLength(this.c.getType(e)) : 0, u = this.getInputType(e), m = this.getType(e);
    switch (this.type = m, this.method) {
      case Ce.NEGATE:
        return e.format("( -" + this.a.build(e, u) + " )", u, t);
      case Ce.INVERT:
        return e.format("( 1.0 - " + this.a.build(e, u) + " )", u, t);
      case Ce.CROSS:
        o = this.a.build(e, "v3"), n = this.b.build(e, "v3");
        break;
      case Ce.STEP:
        o = this.a.build(e, a === 1 ? "f" : u), n = this.b.build(e, u);
        break;
      case Ce.MIN:
      case Ce.MAX:
      case Ce.MOD:
        o = this.a.build(e, u), n = this.b.build(e, l === 1 ? "f" : u);
        break;
      case Ce.REFRACT:
        o = this.a.build(e, u), n = this.b.build(e, u), s = this.c.build(e, "f");
        break;
      case Ce.MIX:
        o = this.a.build(e, u), n = this.b.build(e, u), s = this.c.build(e, c === 1 ? "f" : u);
        break;
      default:
        o = this.a.build(e, u), this.b && (n = this.b.build(e, u)), this.c && (s = this.c.build(e, u));
        break;
    }
    let p = [];
    p.push(o), n && p.push(n), s && p.push(s);
    let d = this.getNumInputs(e);
    if (p.length !== d)
      throw Error(`Arguments not match used in "${this.method}". Require ${d}, currently ${p.length}.`);
    return e.format(this.method + "( " + p.join(", ") + " )", m, t);
  }
};
var me = Ce;
me.RAD = "radians", me.DEG = "degrees", me.EXP = "exp", me.EXP2 = "exp2", me.LOG = "log", me.LOG2 = "log2", me.SQRT = "sqrt", me.INV_SQRT = "inversesqrt", me.FLOOR = "floor", me.CEIL = "ceil", me.NORMALIZE = "normalize", me.FRACT = "fract", me.SATURATE = "saturate", me.SIN = "sin", me.COS = "cos", me.TAN = "tan", me.ASIN = "asin", me.ACOS = "acos", me.ARCTAN = "atan", me.ABS = "abs", me.SIGN = "sign", me.LENGTH = "length", me.NEGATE = "negate", me.INVERT = "invert", me.MIN = "min", me.MAX = "max", me.MOD = "mod", me.STEP = "step", me.REFLECT = "reflect", me.DISTANCE = "distance", me.DOT = "dot", me.CROSS = "cross", me.POW = "pow", me.MIX = "mix", me.CLAMP = "clamp", me.REFRACT = "refract", me.SMOOTHSTEP = "smoothstep", me.FACEFORWARD = "faceforward";
var en = class extends ae {
  constructor(e, t, o) {
    super("v4");
    this.nodeType = "TextureCubeUV";
    this.value = e, this.uv = t, this.bias = o;
  }
  bilinearCubeUV(e, t, o, n) {
    var _a2, _b2, _c2, _d2;
    let s = new Yn(en.Nodes.bilinearCubeUV, [t, o, n]);
    this.colorSpaceTL = (_a2 = this.colorSpaceTL) != null ? _a2 : new at(new ve("", "v4")), this.colorSpaceTL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTL.input.parse(s.build(e) + ".tl"), this.colorSpaceTR = (_b2 = this.colorSpaceTR) != null ? _b2 : new at(new ve("", "v4")), this.colorSpaceTR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTR.input.parse(s.build(e) + ".tr"), this.colorSpaceBL = (_c2 = this.colorSpaceBL) != null ? _c2 : new at(new ve("", "v4")), this.colorSpaceBL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBL.input.parse(s.build(e) + ".bl"), this.colorSpaceBR = (_d2 = this.colorSpaceBR) != null ? _d2 : new at(new ve("", "v4")), this.colorSpaceBR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBR.input.parse(s.build(e) + ".br");
    let a = { include: e.isShader("vertex"), ignoreCache: true };
    e.addContext(a), this.colorSpaceTLExp = new ve(this.colorSpaceTL.build(e, "v4"), "v4"), this.colorSpaceTRExp = new ve(this.colorSpaceTR.build(e, "v4"), "v4"), this.colorSpaceBLExp = new ve(this.colorSpaceBL.build(e, "v4"), "v4"), this.colorSpaceBRExp = new ve(this.colorSpaceBR.build(e, "v4"), "v4"), e.removeContext();
    let l = new ve("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )", "v4");
    return l.keywords.cubeUV_TL = this.colorSpaceTLExp, l.keywords.cubeUV_TR = this.colorSpaceTRExp, l.keywords.cubeUV_BL = this.colorSpaceBLExp, l.keywords.cubeUV_BR = this.colorSpaceBRExp, l.keywords.cubeUV = s, l;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = this.uv, n = this.bias || e.context.roughness, s = new Yn(en.Nodes.roughnessToMip, [n]), a = new me(s, en.Nodes.m0, en.Nodes.cubeUV_maxMipLevel, me.CLAMP), l = new me(a, me.FLOOR), c = new me(a, me.FRACT), u = this.bilinearCubeUV(e, this.value, o, l), m = this.bilinearCubeUV(e, this.value, o, new dt(l, new W(1).setReadonly(true), dt.ADD)), p = new me(u, m, c, me.MIX);
      return e.format(p.build(e), "v4", t);
    } else
      return console.warn("TextureCubeUVNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t);
  }
};
var tn = en;
tn.Nodes = function() {
  let e = new Jo(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`), t = new ye("float cubeUV_maxMipLevel 8.0", true), o = new ye("float cubeUV_minMipLevel 4.0", true), n = new ye("float cubeUV_maxTileSize 256.0", true), s = new ye("float cubeUV_minTileSize 16.0", true), a = new Y(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);
  a.useKeywords = false;
  let l = new Y(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);
  l.useKeywords = false;
  let c = new Y(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`, [e, a, l, t, o, n, s]);
  c.useKeywords = false;
  let u = new ye("float r0 1.0", true), m = new ye("float v0 0.339", true), p = new ye("float m0 -2.0", true), d = new ye("float r1 0.8", true), f = new ye("float v1 0.276", true), g = new ye("float m1 -1.0", true), x = new ye("float r4 0.4", true), y = new ye("float v4 0.046", true), v = new ye("float m4 2.0", true), P = new ye("float r5 0.305", true), S = new ye("float v5 0.016", true), b = new ye("float m5 3.0", true), E = new ye("float r6 0.21", true), w = new ye("float v6 0.0038", true), h = new ye("float m6 4.0", true), _ = [u, m, p, d, f, g, x, y, v, P, S, b, E, w, h], N = new Y(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`, _);
  return { bilinearCubeUV: c, roughnessToMip: N, m0: p, cubeUV_maxMipLevel: t };
}();
var ro = class extends ae {
  constructor(e) {
    super("v3");
    this.nodeType = "Normal";
    this.scope = e != null ? e : ro.VIEW;
  }
  getShared() {
    return this.scope === ro.WORLD;
  }
  build(e, t, o, n) {
    let s = e.context[this.scope + "Normal"];
    return s ? s.build(e, t, o, n) : super.build(e, t, o);
  }
  generate(e, t, o, n, s) {
    let a;
    switch (this.scope) {
      case ro.VIEW:
        e.isShader("vertex") ? a = "transformedNormal" : a = "geometryNormal";
        break;
      case ro.LOCAL:
        e.isShader("vertex") ? a = "objectNormal" : (e.requires.normal = true, a = "vObjectNormal");
        break;
      case ro.WORLD:
        e.isShader("vertex") ? a = "inverseTransformDirection( transformedNormal, viewMatrix ).xyz" : (e.requires.worldNormal = true, a = "vWNormal");
        break;
    }
    return e.format(a, this.getType(e), t);
  }
};
var Ye = ro;
Ye.LOCAL = "local", Ye.WORLD = "world", Ye.VIEW = "view", Ye.NORMAL = "normal";
je.addKeyword("viewNormal", function() {
  return new Ye(Ye.VIEW);
});
je.addKeyword("localNormal", function() {
  return new Ye(Ye.NORMAL);
});
je.addKeyword("worldNormal", function() {
  return new Ye(Ye.WORLD);
});
var tr = class extends ae {
  constructor(e) {
    super("v3");
    this.nodeType = "Position";
    this.scope = e != null ? e : tr.LOCAL;
  }
  getType() {
    switch (this.scope) {
      case tr.PROJECTION:
        return "v4";
    }
    return this.type;
  }
  getShader() {
    switch (this.scope) {
      case tr.LOCAL:
      case tr.WORLD:
        return false;
    }
    return true;
  }
  generate(e, t, o, n, s) {
    let a;
    switch (this.scope) {
      case tr.LOCAL:
        e.isShader("vertex") ? a = "transformed" : (e.requires.position = true, a = "vPosition");
        break;
      case tr.WORLD:
        if (e.isShader("vertex"))
          return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
        e.requires.worldPosition = true, a = "vWPosition";
        break;
      case tr.VIEW:
        a = e.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
        break;
      case tr.PROJECTION:
        a = e.isShader("vertex") ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )" : "vec4( 0.0 )";
        break;
    }
    return e.format(a, this.getType(), t);
  }
};
var ft = tr;
ft.LOCAL = "local", ft.WORLD = "world", ft.VIEW = "view", ft.PROJECTION = "projection";
je.addKeyword("position", function() {
  return new ft();
});
je.addKeyword("worldPosition", function() {
  return new ft(ft.WORLD);
});
je.addKeyword("viewPosition", function() {
  return new ft(ft.VIEW);
});
var Et = class extends ae {
  constructor(e) {
    super("v3");
    this.nodeType = "Reflect";
    this.scope = e != null ? e : Et.CUBE;
  }
  getUnique(e) {
    return !e.context.viewNormal;
  }
  getType() {
    switch (this.scope) {
      case Et.SPHERE:
        return "v2";
    }
    return this.type;
  }
  generate(e, t) {
    let o = this.getUnique(e);
    if (e.isShader("fragment")) {
      let n;
      switch (this.scope) {
        case Et.VECTOR: {
          let s = new Ye(Ye.VIEW), a = e.context.roughness, l = s.build(e, "v3"), c = new ft(ft.VIEW).build(e, "v3"), u = a ? a.build(e, "f") : void 0, m = `reflect( -normalize( ${c} ), ${l} )`;
          u && (m = `normalize( mix( ${m}, ${l}, ${u} * ${u} ) )`);
          let p = `inverseTransformDirection( ${m}, viewMatrix )`;
          o ? (e.addNodeCode(`vec3 reflectVec = ${p};`), n = "reflectVec") : n = p;
          break;
        }
        case Et.CUBE: {
          let s = new Et(Et.VECTOR).build(e, "v3"), a = "vec3( -" + s + ".x, " + s + ".yz )";
          o ? (e.addNodeCode(`vec3 reflectCubeVec = ${a};`), n = "reflectCubeVec") : n = a;
          break;
        }
        case Et.SPHERE: {
          let s = new Et(Et.VECTOR).build(e, "v3"), a = "normalize( ( viewMatrix * vec4( " + s + ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
          o ? (e.addNodeCode(`vec2 reflectSphereVec = ${a};`), n = "reflectSphereVec") : n = a;
          break;
        }
      }
      return e.format(n, this.getType(), t);
    } else
      return console.warn("ReflectNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.type, t);
  }
};
var rr = Et;
rr.CUBE = "cube", rr.SPHERE = "sphere", rr.VECTOR = "vector";
var qs = class extends ae {
  constructor(e = new lt(), t, o) {
    super("v4");
    this.nodeType = "TextureCube";
    this.value = e, this.radianceNode = new tn(this.value, t != null ? t : new rr(rr.VECTOR), o), this.irradianceNode = new tn(this.value, new Ye(Ye.WORLD), new W(1).setReadonly(true));
  }
  generate(e, t) {
    return e.isShader("fragment") ? (e.require("irradiance"), e.context.bias && e.context.bias.setTexture(this.value), (e.slot === "irradiance" ? this.irradianceNode : this.radianceNode).build(e, t)) : (console.warn("TextureCubeNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t));
  }
};
var $s = class extends Ne {
  constructor(e = new CubeTexture(), t, o) {
    super("v4", { shared: true });
    this.nodeType = "CubeTexture";
    this.value = e, this.uv = t != null ? t : new rr(), this.bias = o;
  }
  getTexture(e, t) {
    return super.generate(e, t, this.value.uuid, "tc");
  }
  generate(e, t) {
    var _a2, _b2;
    if (t === "samplerCube")
      return this.getTexture(e, t);
    let o = this.getTexture(e, t), n = (_a2 = this.uv) == null ? void 0 : _a2.build(e, "v3"), s = this.bias ? this.bias.build(e, "f") : void 0;
    s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
    let a;
    s ? a = "texCubeBias( " + o + ", " + n + ", " + s + " )" : a = "texCube( " + o + ", " + n + " )";
    let l = { include: e.isShader("vertex"), ignoreCache: true }, c = this.getType(e);
    return e.addContext(l), this.colorSpace = (_b2 = this.colorSpace) != null ? _b2 : new at(new ve("", c)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(a), a = this.colorSpace.build(e, c), e.removeContext(), e.format(a, c, t);
  }
};
var fd = ["x", "y", "z", "w"];
var hS = ["float", "vec2", "vec3", "vec4"];
var gS = { float: "f", vec2: "v2", vec3: "v3", vec4: "v4", mat4: "v4", int: "i", bool: "b", "float[]": "f[]", "vec4[]": "v4[]" };
var yS = { t: "sampler2D", tc: "samplerCube", b: "bool", i: "int", f: "float", c: "vec3", v2: "vec2", v3: "vec3", v4: "vec4", m3: "mat3", m4: "mat4", "f[]": "float[]", "v4[]": "vec4[]" };
var Xs = class {
  constructor() {
    this.includes = { consts: {}, functions: {}, structs: {} };
    this.cache = "";
    this.slot = "";
    this.shader = "";
    this.context = {};
    this.getIncludesCode = function() {
      function r(e, t) {
        return e.deps.length - t.deps.length;
      }
      return function(t, o) {
        let n = this.getIncludes(t, o);
        if (!n)
          return "";
        let s = "";
        n = n.sort(r);
        for (let a = 0; a < n.length; a++)
          n[a].src && (s += n[a].src + `
`);
        return s;
      };
    }();
    this.slots = [], this.caches = [], this.contexts = [], this.keywords = {}, this.nodeData = {}, this.fragmentVariables = {}, this.fragmentParsVariables = {}, this.vertexParsVariables = {}, this.requires = { uv: [], color: [], lights: false, fog: false, transparent: false, irradiance: false, position: false, worldPosition: false, normal: false, worldNormal: false, vWorldViewDir: false, modelMatrix: false, viewMatrix: false, projectionMatrix: false }, this.includes = { consts: [], functions: [], structs: [] }, this.attributes = {}, this.prefixCode = ["#ifdef TEXTURE_LOD_EXT", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)", "#else", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCube(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2D(a, b, c)", "#endif", `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`, "#include <packing>", "#include <common>"].join(`
`), this.parsCode = { vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`), fragment: ["float accumAlpha = 0.0;", `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`, ""].join(`
`) }, this.code = { vertex: "", fragment: "" }, this.nodeCode = { vertex: "", fragment: "" }, this.resultCode = { vertex: "", fragment: "" }, this.finalCode = { vertex: "", fragment: "" }, this.inputs = { uniforms: { list: [], vertex: [], fragment: [] }, arrayUniforms: { list: [], vertex: [], fragment: [] }, vars: { varying: [], vertex: [], fragment: [] } }, this.defines = {}, this.uniforms = {}, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.updaters = [], this.nodes = [], this.analyzing = false;
  }
  build(r, e) {
    this.buildShader("vertex", r), this.buildShader("fragment", e);
    for (let t = 0; t < this.requires.uv.length; t++)
      if (this.requires.uv[t]) {
        let o = t > 0 ? t + 1 : "";
        this.addVaryCode("varying vec2 vUv" + o + ";"), t > 0 && this.addVertexParsCode("attribute vec2 uv" + o + ";"), this.addVertexFinalCode("vUv" + o + " = uv" + o + ";");
      }
    return this.requires.color[0] && (this.addVaryCode("varying vec4 vColor;"), this.addVertexParsCode("attribute vec4 color;"), this.addVertexFinalCode("vColor = color;")), this.requires.color[1] && (this.addVaryCode("varying vec4 vColor2;"), this.addVertexParsCode("attribute vec4 color2;"), this.addVertexFinalCode("vColor2 = color2;")), this.requires.position && (this.addVaryCode("varying vec3 vPosition;"), this.addVertexFinalCode("vPosition = transformed;")), this.requires.worldPosition, this.requires.normal && (this.addVaryCode("varying vec3 vObjectNormal;"), this.addVertexFinalCode("vObjectNormal = normal;")), this.requires.modelMatrix && this.addFragmentParsCode("uniform mat4 modelMatrix;"), this.requires.viewMatrix && this.addFragmentParsCode("uniform mat4 viewMatrix;"), this.requires.projectionMatrix && this.addFragmentParsCode("uniform mat4 projectionMatrix;"), this.requires.worldNormal && (this.addVaryCode("varying vec3 vWNormal;"), this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")), this.requires.vWorldViewDir && (this.addVaryCode("varying vec3 vWorldViewDir;"), this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")), this;
  }
  buildShader(r, e) {
    this.resultCode[r] = e.build(this.setShader(r), "v4");
  }
  setMaterial(r, e) {
    return this.material = r, this.renderer = e, this.requires.lights = r.lights, this.requires.fog = r.fog, this.mergeDefines(r.defines), this;
  }
  addFlow(r, e, t) {
    return this.addSlot(r).addCache(e).addContext(t);
  }
  removeFlow() {
    return this.removeSlot().removeCache().removeContext();
  }
  addCache(r) {
    return this.cache = r != null ? r : "", this.caches.push(this.cache), this;
  }
  removeCache() {
    return this.caches.pop(), this.cache = this.caches[this.caches.length - 1] || "", this;
  }
  addContext(r) {
    return this.context = Object.assign({}, this.context, r), this.context.extra = this.context.extra || {}, this.contexts.push(this.context), this;
  }
  removeContext() {
    return this.contexts.pop(), this.context = this.contexts[this.contexts.length - 1] || {}, this;
  }
  addSlot(r) {
    return this.slot = r || "", this.slots.push(this.slot), this;
  }
  removeSlot() {
    return this.slots.pop(), this.slot = this.slots[this.slots.length - 1] || "", this;
  }
  addFragmentVariable(r, e) {
    this.fragmentVariables[r] === void 0 && (this.addFragmentCode(`${e} ${r};`), this.fragmentVariables[r] = "");
  }
  addFragmentParsVariable(r, e) {
    this.fragmentParsVariables[r] === void 0 && (this.addFragmentParsCode(`${e} ${r};`), this.fragmentParsVariables[r] = "");
  }
  addVertexParsVariable(r, e) {
    this.vertexParsVariables[r] === void 0 && (this.addVertexParsCode(`${e} ${r};`), this.vertexParsVariables[r] = "");
  }
  addVertexCode(r) {
    this.addCode(r, "vertex");
  }
  addFragmentCode(r) {
    this.addCode(r, "fragment");
  }
  addCode(r, e) {
    this.code[e != null ? e : this.shader] += r + `
`;
  }
  addVertexNodeCode(r) {
    this.addNodeCode(r, "vertex");
  }
  addFragmentNodeCode(r) {
    this.addNodeCode(r, "fragment");
  }
  addNodeCode(r, e) {
    this.nodeCode[e != null ? e : this.shader] += r + `
`;
  }
  clearNodeCode(r) {
    r = r != null ? r : this.shader;
    let e = this.nodeCode[r];
    return this.nodeCode[r] = "", e;
  }
  clearVertexNodeCode() {
    return this.clearNodeCode("vertex");
  }
  clearFragmentNodeCode() {
    return this.clearNodeCode("fragment");
  }
  addVertexFinalCode(r) {
    this.addFinalCode(r, "vertex");
  }
  addFragmentFinalCode(r) {
    this.addFinalCode(r, "fragment");
  }
  addFinalCode(r, e) {
    this.finalCode[e != null ? e : this.shader] += r + `
`;
  }
  addVertexParsCode(r) {
    this.addParsCode(r, "vertex");
  }
  addFragmentParsCode(r) {
    this.addParsCode(r, "fragment");
  }
  addParsCode(r, e) {
    this.parsCode[e != null ? e : this.shader] += r + `
`;
  }
  addVaryCode(r) {
    this.addVertexParsCode(r), this.addFragmentParsCode(r);
  }
  isCache(r) {
    return this.caches.indexOf(r) !== -1;
  }
  isSlot(r) {
    return this.slots.indexOf(r) !== -1;
  }
  define(r, e) {
    this.defines[r] = e === void 0 ? 1 : e;
  }
  require(r) {
    this.requires[r] = true;
  }
  isDefined(r) {
    return this.defines[r] !== void 0;
  }
  getVar(r, e, t, o = "varying", n = "V", s = "") {
    let a = this.getVars(o), l = a[r];
    if (!l) {
      let c = a.length;
      l = { name: t || "node" + n + c + (s ? "_" + s : ""), type: e }, a.push(l), a[r] = l;
    }
    return l;
  }
  getTempVar(r, e, t, o) {
    return this.getVar(r, e, t, this.shader, "T", o);
  }
  getAttribute(r, e) {
    if (!this.attributes[r]) {
      let t = this.getVar(r, e);
      this.addVertexParsCode("attribute " + e + " " + r + ";"), this.addVertexFinalCode(t.name + " = " + r + ";"), this.attributes[r] = { varying: t, name: r, type: e };
    }
    return this.attributes[r];
  }
  getCode(r) {
    return [this.prefixCode, this.parsCode[r], this.getVarListCode(this.getVars("varying"), "varying"), this.getVarListCode(this.inputs.uniforms[r], "uniform"), this.getVarListCode(this.inputs.arrayUniforms[r], "uniform"), this.getIncludesCode("consts", r), this.getIncludesCode("structs", r), this.getIncludesCode("functions", r), "void main() {", this.getVarListCode(this.getVars(r)), this.code[r], this.resultCode[r], this.finalCode[r], "}"].join(`
`);
  }
  getVarListCode(r, e) {
    e = e != null ? e : "";
    let t = "";
    for (let o = 0, n = r.length; o < n; ++o) {
      let s = r[o], a = s.type, l = s.name, c = s.size, u = this.getFormatByType(a);
      if (u === void 0)
        throw new Error("Node pars " + u + " not found.");
      u.includes("[]") ? t += e + " " + u.substring(0, u.length - 2) + " " + l + `[${c}];
` : t += e + " " + u + " " + l + `;
`;
    }
    return t;
  }
  getVars(r) {
    return this.inputs.vars[r != null ? r : this.shader];
  }
  getNodeData(r) {
    let e = r instanceof Xe ? r.uuid : r;
    return this.nodeData[e] = this.nodeData[e] || {};
  }
  createUniform(r, e, t, o, n, s) {
    if (e.includes("[]")) {
      let a = this.inputs.arrayUniforms, l = a.list.length, c = new Xn({ type: e, size: t.size, name: o || "nodeUA" + l + (s ? "_" + s : ""), node: t, needsUpdate: n });
      return a.list.push(c), a[r].push(c), a[r][c.name] = c, this.uniforms[c.name] = c, c;
    } else {
      let a = this.inputs.uniforms, l = a.list.length, c = new Xn({ type: e, name: o || "nodeU" + l + (s ? "_" + s : ""), node: t, needsUpdate: n });
      return a.list.push(c), a[r].push(c), a[r][c.name] = c, this.uniforms[c.name] = c, c;
    }
  }
  createVertexUniform(r, e, t, o, n) {
    return this.createUniform("vertex", r, e, t, o, n);
  }
  createFragmentUniform(r, e, t, o, n) {
    return this.createUniform("fragment", r, e, t, o, n);
  }
  include(r, e, t) {
    var _a2;
    let o;
    if (r = typeof r == "string" ? je.get(r) : r, this.context.include === false)
      return r.name;
    r instanceof Y ? o = this.includes.functions : r instanceof ye ? o = this.includes.consts : r instanceof Jo && (o = this.includes.structs);
    let n = o[this.shader] = o[this.shader] || [];
    if (r) {
      let s = n[r.name];
      if (s || (s = n[r.name] = { node: r, deps: [] }, n.push(s), s.src = r.build(this, "source")), r instanceof Y && e && n[e.name] && n[e.name].deps.indexOf(r) === -1 && (n[e.name].deps.push(r), (_a2 = r.includes) == null ? void 0 : _a2.length)) {
        let a = 0;
        do
          this.include(r.includes[a++], e);
        while (a < r.includes.length);
      }
      return t && (s.src = t), r.name;
    } else
      throw new Error("Include not found.");
  }
  colorToVectorProperties(r) {
    return r.replace("r", "x").replace("g", "y").replace("b", "z").replace("a", "w");
  }
  colorToVector(r) {
    return r.replace(/c/g, "v3");
  }
  getIncludes(r, e) {
    return this.includes[r][e || this.shader];
  }
  getConstructorFromLength(r) {
    return hS[r - 1];
  }
  isTypeMatrix(r) {
    return /^m/.test(r);
  }
  getTypeLength(r) {
    return r === "f" ? 1 : parseInt(this.colorToVector(r).substr(1));
  }
  getTypeFromLength(r) {
    return r === 1 ? "f" : "v" + r;
  }
  findNode(...r) {
    for (let e = 0; e < arguments.length; e++) {
      let t = r[e];
      if (t == null ? void 0 : t.isNode)
        return t;
    }
  }
  resolve(...r) {
    for (let e = 0; e < arguments.length; e++) {
      let t = r[e];
      if (t !== void 0) {
        if (t.isNode)
          return t;
        if (t.isTexture)
          switch (t.mapping) {
            case CubeReflectionMapping:
            case CubeRefractionMapping:
              return new $s(t);
            case CubeUVReflectionMapping:
              return new qs(new lt(t));
            default:
              return new lt(t);
          }
        else {
          if (t.isVector2)
            return new ke(t);
          if (t.isVector3)
            return new Je(t);
          if (t.isVector4)
            return new Pt(t);
        }
      }
    }
  }
  format(r, e, t) {
    switch (this.colorToVector(t + " <- " + e)) {
      case "f <- v2":
        return r + ".x";
      case "f <- v3":
        return r + ".x";
      case "f <- v4":
        return r + ".x";
      case "f <- i":
      case "f <- b":
        return "float( " + r + " )";
      case "v2 <- f":
        return "vec2( " + r + " )";
      case "v2 <- v3":
        return r + ".xy";
      case "v2 <- v4":
        return r + ".xy";
      case "v2 <- i":
      case "v2 <- b":
        return "vec2( float( " + r + " ) )";
      case "v3 <- f":
        return "vec3( " + r + " )";
      case "v3 <- v2":
        return "vec3( " + r + ", 0.0 )";
      case "v3 <- v4":
        return r + ".xyz";
      case "v3 <- i":
      case "v3 <- b":
        return "vec2( float( " + r + " ) )";
      case "v4 <- f":
        return "vec4( " + r + " )";
      case "v4 <- v2":
        return "vec4( " + r + ", 0.0, 1.0 )";
      case "v4 <- v3":
        return "vec4( " + r + ", 1.0 )";
      case "v4 <- i":
      case "v4 <- b":
        return "vec4( float( " + r + " ) )";
      case "i <- f":
      case "i <- b":
        return "int( " + r + " )";
      case "i <- v2":
        return "int( " + r + ".x )";
      case "i <- v3":
        return "int( " + r + ".x )";
      case "i <- v4":
        return "int( " + r + ".x )";
      case "b <- f":
        return "( " + r + " != 0.0 )";
      case "b <- v2":
        return "( " + r + " != vec2( 0.0 ) )";
      case "b <- v3":
        return "( " + r + " != vec3( 0.0 ) )";
      case "b <- v4":
        return "( " + r + " != vec4( 0.0 ) )";
      case "b <- i":
        return "( " + r + " != 0 )";
    }
    return r;
  }
  getTypeByFormat(r) {
    return gS[r] || r;
  }
  getFormatByType(r) {
    return yS[r] || r;
  }
  getUUID(r, e) {
    return e = e !== void 0 ? e : true, e && this.cache && (r = this.cache + "-" + r), r;
  }
  getElementByIndex(r) {
    return fd[r];
  }
  getIndexByElement(r) {
    return fd.indexOf(r);
  }
  isShader(r) {
    return this.shader === r;
  }
  setShader(r) {
    return this.shader = r, this;
  }
  mergeDefines(r) {
    for (let e in r)
      this.defines[e] = r[e];
    return this.defines;
  }
  mergeUniform(r) {
    for (let e in r)
      this.uniforms[e] = r[e];
    return this.uniforms;
  }
  getTextureEncodingFromMap(r) {
    let e;
    return r ? r.isTexture && (e = r.encoding) : e = LinearEncoding, e === LinearEncoding && this.context.gamma && (e = sRGBEncoding), e;
  }
};
var we = class extends Ne {
  constructor(e = 0, t, o, n) {
    super("c");
    this.nodeType = "Color";
    this.value = e instanceof Qe ? e : new Qe(e || 0, t, o, n);
  }
  setRGBA(e) {
    this.value.setRGBA(e.r, e.g, e.b, e.a);
  }
  generate(e, t, o, n, s, a) {
    o = e.getUUID(o != null ? o : this.getUUID()), n = n != null ? n : this.getType(e);
    let l = e.getNodeData(o), c = this.getReadonly() && this.generateReadonly !== void 0;
    if (this.alpha) {
      let u = this.alpha.build(e, "f");
      e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${u};`);
    }
    return c ? this.generateReadonly(e, t, o, n, s, a) : e.isShader("vertex") ? (l.vertex || (l.vertex = e.createVertexUniform(n, this, s, a, this.getLabel())), e.format(l.vertex.name, n, t)) : (l.fragment || (l.fragment = e.createFragmentUniform(n, this, s, a, this.getLabel())), e.format(l.fragment.name, n, t));
  }
  generateReadonly(e, t, o, n, s, a) {
    return e.format("vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")", n, t);
  }
};
var fe = class extends Ne {
  constructor(e) {
    super("i");
    this.nodeType = "Int";
    this.value = Math.floor(e != null ? e : 0);
  }
  generateReadonly(e, t, o, n, s, a) {
    return e.format(this.value.toString(), n, t);
  }
};
var Ur = class extends Xe {
  constructor() {
    super("basic");
    this.nodeType = "Basic";
    this.color = new we(5855577), this.shadingAlpha = new W(1), this.shadingBlend = new fe(0);
  }
  generate(e) {
    let t;
    if (e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>"].join(`
`));
      let n = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
      o && n.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), n.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "	vNormal = transformedNormal;", "#endif"), n.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>"), n.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = n.join(`
`);
    } else {
      this.color === void 0 && (this.color = new we(5855577)), this.color.analyze(e, { slot: "color" }), this.alpha && this.alpha.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" });
      let o = this.color.flow(e, "c", { slot: "color" }), n = this.alpha ? this.alpha.flow(e, "f") : void 0, s = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0;
      e.requires.transparent = n !== void 0, e.addParsCode(["varying vec3 vWPosition;", "#include <fog_pars_fragment>", "#include <dithering_pars_fragment>", "varying vec3 vViewPosition;", "#include <normal_pars_fragment>"].join(`
`));
      let a = ["#include <normal_fragment_begin>", o.code];
      n && a.push(n.code, "#ifdef ALPHATEST", " if ( " + n.result + " <= ALPHATEST ) discard;", "#endif"), s ? a.push(s.code, `vec3 outgoingLight = ${o.result};`, `vec3 finalColor = spe_blend(outgoingLight, ${s.result}, 1.0, SPE_BLENDING_NORMAL);`) : a.push(`vec3 finalColor = ${o.result};`), n ? a.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${n.result} );`) : a.push("gl_FragColor = vec4(" + o.result + ", 1.0 );"), a.push("#include <fog_fragment>", "#include <dithering_fragment>"), t = a.join(`
`);
    }
    return t;
  }
};
var He = class extends Ne {
  constructor(e = 1, t) {
    super("f[]");
    this.nodeType = "FloatArray";
    this.size = e, this.value = Array.isArray(t) ? t : typeof t == "number" ? new Array(e).fill(t) : new Array(e).fill(0);
  }
};
var Kn = class extends Xe {
  constructor() {
    super("lambert");
    this.nodeType = "Lambert";
    this.color = new we(5855577), this.emissive = new we(0), this.emissiveIntensity = new W(1), this.penumbraSize = new He(5, 0.5), this.shadingAlpha = new W(1), this.shadingBlend = new fe(0);
  }
  build(e) {
    let t;
    if (e.define("LAMBERT"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <color_pars_vertex>", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let n = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && n.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), n.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), n.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`, "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), n.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = n.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: this.penumbraSize }), this.color === void 0 && (this.color = new we(5855577)), this.color.analyze(e, { slot: "color" }), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), n = this.emissive.flow(e, "c", { slot: "emissive" }), s = this.emissiveIntensity.flow(e, "f", { slot: "emissive" }), a = this.shadingAlpha.flow(e, "f"), l = this.shadingBlend.flow(e, "i"), c = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, u = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = u !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#include <normal_pars_fragment>", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <fog_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <shadowmask_pars_fragment>", "#include <clipping_planes_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
      let m = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`, "#include <clipping_planes_fragment>"];
      m.push(o.code, "vec3 diffuseColor = " + o.result + ";", "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"), u && m.push(u.code, "#ifdef ALPHATEST", "if ( " + u.result + " <= ALPHATEST ) discard;", "#endif"), m.push("#ifdef DOUBLE_SIDED", "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;", "#else", "	reflectedLight.indirectDiffuse += vIndirectFront;", "#endif", "#include <lightmap_fragment>", "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );", "#ifdef DOUBLE_SIDED", "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;", "#else", "	reflectedLight.directDiffuse = vLightFront;", "#endif", "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"), n && m.push(n.code, "reflectedLight.directDiffuse += " + n.result + " * " + s.result + ";"), m.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;"), m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`), c && m.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), u ? m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`) : m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), m.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = m.join(`
`);
    }
    return t;
  }
};
var Ys = class extends Xe {
  constructor() {
    super("phong");
    this.nodeType = "Phong";
    this.color = new we(5855577), this.specular = new we(1118481), this.shininess = new W(30), this.penumbraSize = new He(5, 0.5), this.shadingAlpha = new W(1), this.shadingBlend = new fe(0);
  }
  build(e) {
    let t;
    if (e.define("PHONG"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let n = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && n.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), n.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), n.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), n.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = n.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: this.penumbraSize }), this.color === void 0 && (this.color = new we(5855577)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), n = this.specular.flow(e, "c"), s = this.shininess.flow(e, "f"), a = this.shadingAlpha.flow(e, "f"), l = this.shadingBlend.flow(e, "i"), c = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, u = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = u !== void 0, e.addParsCode(["varying vec3 vWPosition;", "uniform vec3 emissive;", `uniform float penumbraSize[${5}];`, "#include <normal_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_phong_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
      let m = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	BlinnPhongMaterial material;"];
      m.push(o.code, "	vec3 diffuseColor = " + o.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveRadiance = emissive;", n.code, "	vec3 specular = " + n.result + ";", s.code, "	float shininess = max( 0.0001, " + s.result + " );", "	float specularStrength = 1.0;"), u && m.push(u.code, "#ifdef ALPHATEST", "if ( " + u.result + " <= ALPHATEST ) discard;", "#endif"), m.push("material.diffuseColor = diffuseColor;"), m.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), m.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"), m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`), c && m.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), u ? m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`) : m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), m.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = m.join(`
`);
    }
    return t;
  }
};
var Qn = class extends Xe {
  constructor() {
    super("standard");
    this.nodeType = "Standard";
    this.color = new we(5855577), this.roughness = new W(0.3), this.metalness = new W(0), this.reflectivity = new W(0.5), this.penumbraSize = new He(5, 0.5), this.shadingAlpha = new W(1), this.shadingBlend = new fe(0);
  }
  build(e) {
    let t;
    if (e.define("STANDARD"), e.requires.lights = true, e.extensions.derivatives = true, e.extensions.shaderTextureLOD = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), UniformsLib.LTC_1 && (e.uniforms.ltc_1 = { value: void 0 }, e.uniforms.ltc_2 = { value: void 0 }), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let n = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
      o && n.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), n.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), n.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>", "#include <shadowmap_vertex>"), n.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = n.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: this.penumbraSize });
      let o = { gamma: true };
      this.color === void 0 && (this.color = new we(5855577)), this.color.analyze(e, { slot: "color", context: o }), this.roughness.analyze(e), this.metalness.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e), this.reflectivity && this.reflectivity.analyze(e);
      let n = this.color.flow(e, "c", { slot: "color", context: o }), s = this.roughness.flow(e, "f"), a = this.metalness.flow(e, "f"), l = this.shadingAlpha.flow(e, "f"), c = this.shadingBlend.flow(e, "i"), u = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, m = this.alpha ? this.alpha.flow(e, "f") : void 0, p = this.reflectivity ? this.reflectivity.flow(e, "f") : void 0;
      e.requires.transparent = m !== void 0, e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", `uniform float penumbraSize[${5}];`, "#include <normal_pars_fragment>", "#include <dithering_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_physical_pars_fragment>", "#include <shadowmap_pars_fragment>"].join(`
`));
      let d = ["#include <clipping_planes_fragment>", "	#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	PhysicalMaterial material;", "	material.diffuseColor = vec3( 1.0 );"];
      d.push(n.code, "	vec3 diffuseColor = " + n.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", s.code, "	float roughnessFactor = " + s.result + ";", a.code, "	float metalnessFactor = " + a.result + ";"), m && d.push(m.code, "#ifdef ALPHATEST", "	if ( " + m.result + " <= ALPHATEST ) discard;", "#endif"), d.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"), d.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );", "material.roughness = max( roughnessFactor, 0.0525 );", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"), p ? d.push(p.code, "material.specularColor = mix( vec3( 0.16 * pow2( " + p.result + " ) ), diffuseColor, metalnessFactor );") : d.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"), d.push("#include <lights_fragment_begin>"), d.push("#include <lights_fragment_end>"), d.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"), d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${c.result} );
				}
				`), u && d.push(u.code, `outgoingLight = spe_blend(outgoingLight, ${u.result}, 1.0, SPE_BLENDING_NORMAL);`), m ? d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${m.result} );`) : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = d.join(`
`);
    }
    return t;
  }
};
var Jn = class extends Xe {
  constructor() {
    super("toon");
    this.nodeType = "Toon";
    this.color = new we(5855577), this.specular = new we(1118481), this.shininess = new W(30), this.penumbraSize = new He(5, 0.5), this.shadingAlpha = new W(1), this.shadingBlend = new fe(0);
  }
  build(e) {
    let t;
    if (e.define("TOON"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let n = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && n.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), n.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), n.push("	#include <project_vertex>", "	#include <fog_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), n.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = n.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: this.penumbraSize }), this.color === void 0 && (this.color = new we(5855577)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), n = this.specular.flow(e, "c"), s = this.shininess.flow(e, "f"), a = this.shadingAlpha.flow(e, "f"), l = this.shadingBlend.flow(e, "i"), c = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, u = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = u !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "varying vec3 vWPosition;", "#include <normal_pars_fragment>", "#include <gradientmap_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <dithering_pars_fragment>", `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`, "#include <shadowmap_pars_fragment>", "#include <bumpmap_pars_fragment>", "#include <normalmap_pars_fragment>"].join(`
`));
      let m = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	ToonMaterial material;"];
      m.push(o.code, "	vec3 diffuseColor = " + o.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", n.code, "	vec3 specular = " + n.result + ";", s.code, "	float shininess = max( 0.0001, " + s.result + " );", "	float specularStrength = 1.0;"), u && m.push(u.code, "#ifdef ALPHATEST", "if ( " + u.result + " <= ALPHATEST ) discard;", "#endif"), m.push("material.diffuseColor = diffuseColor;"), m.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), m.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"), m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`), c && m.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), u ? m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`) : m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), m.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = m.join(`
`);
    }
    return t;
  }
};
var jr = class extends Ne {
  constructor(e) {
    super("b");
    this.nodeType = "Bool";
    this.value = e != null ? e : false;
  }
  generateReadonly(e, t, o, n) {
    return e.format(this.value ? "true" : "false", n, t);
  }
};
var rn = class extends Ne {
  constructor(e) {
    super("m3");
    this.nodeType = "Matrix3";
    this.value = e != null ? e : new Matrix3();
  }
  generateReadonly(e, t, o, n, s, a) {
    return e.format("mat3(" + this.value.elements.join(", ") + ")", n, t);
  }
  get elements() {
    return this.value.elements;
  }
  set elements(e) {
    this.value.fromArray(e);
  }
};
var Bt = class extends Ne {
  constructor(e = 1, t) {
    super("v4[]");
    this.nodeType = "Vector4Array";
    this.size = e, this.value = Array.isArray(t) ? t : t instanceof Vector4 ? new Array(e).fill(t) : new Array(e).fill(new Vector4(0));
  }
};
var Zn = ((n) => (n.SIMPLEX = "simplex3d", n.SIMPLEX_FRACTAL = "simplex3dFractal", n.ASHIMA = "simplexAshima", n.FBM = "fbm", n.PERLIN = "perlin", n))(Zn || {});
var ot = function() {
  let r = new Y(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`), e = new Y(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`, [r]);
  e.keywords.F3 = new ye("float F3 0.3333333"), e.keywords.G3 = new ye("float G3 0.1666667");
  let t = new Y(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`, [e]), o = new Y("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"), n = new Y("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"), s = new Y(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`, [o, n]), a = new Y("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"), l = new Y("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [a]), c = new Y(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`, [l]), u = new Y(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`, [c]);
  u.keywords.NUM_OCTAVES = new ye(`int NUM_OCTAVES ${5}`);
  let m = new Y("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"), p = new Y(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`, [o, n, m]);
  return { simplex: e, simplexFractal: t, simplexAshima: s, fbm: u, perlin: p };
}();
var ei = class extends ae {
  constructor(e, t, o, n, s, a, l, c, u, m, p, d) {
    super("v3");
    this.nodeType = "Noise";
    this.scale = e, this.size = t, this.move = o, this.fA = n, this.fB = s, this.distortion = a, this.colorA = l, this.colorB = c, this.colorC = u, this.colorD = m, this.alpha = p, this.noiseType = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t, o, n, s) {
    e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
    let a = Object.values(Zn)[this.noiseType.value], l = new Y(`vec3 ${a}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, float alpha, out float calpha) {
                vec3 st = position / size;
				st /= scale;
				vec3 q = vec3(${a}(st),
							  ${a}(st + vec3(1.0)),
							  ${a}(st + vec3(1.0)));
				vec3 r = vec3(${a}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
							  ${a}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
							  ${a}(st * q));
				float f = ${a}(st + r);
				vec4 color;
				color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
				color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
				color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));

                float lalpha = alpha * color.a;
                calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			    accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return clamp(color, 0.0, 1.0).rgb;
			}`, [ot.simplex, ot.simplexFractal, ot.simplexAshima, ot.fbm, ot.perlin]), c = e.include(l), u = [];
    return u.push(this.scale.build(e, "f")), u.push(this.size.build(e, "v3")), u.push(this.move.build(e, "f")), u.push(this.fA.build(e, "v2")), u.push(this.fB.build(e, "v2")), u.push(this.distortion.build(e, "v2")), u.push(this.colorA.build(e, "v4")), u.push(this.colorB.build(e, "v4")), u.push(this.colorC.build(e, "v4")), u.push(this.colorD.build(e, "v4")), u.push(this.alpha.build(e, "f")), u.push(this.calpha), e.format(c + "(" + u.join(",") + ")", this.getType(e), t);
  }
};
ei.numOctaves = 5;
var Il = class extends ae {
  constructor(e, t, o, n, s, a, l) {
    super("v3");
    this.nodeType = "Fresnel";
    this.color = e, this.bias = t, this.scale = o, this.intensity = n, this.factor = s, this.alpha = a, this.mode = l, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) {
      e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Il.Nodes.fresnel), n = [];
      return n.push(this.color.build(e, "c")), n.push(this.bias.build(e, "f")), n.push(this.scale.build(e, "f")), n.push(this.intensity.build(e, "f")), n.push(this.factor.build(e, "f")), n.push(this.alpha.build(e, "f")), n.push(this.mode.build(e, "i")), n.push(this.calpha), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("FresnelNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ti = Il;
ti.Nodes = function() {
  return { fresnel: new Y(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, float alpha, int mode, out float calpha) {
				float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

				float lalpha = clamp( fresnel, 0.0, 1.0 ) * alpha;
				calpha = lalpha / clamp(lalpha + accumAlpha, 0.001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;
				return color;
			}`) };
}();
var Pl = class extends ae {
  constructor(e, t, o, n, s, a, l) {
    super("v3");
    this.nodeType = "Rainbow";
    this.filmThickness = e, this.movement = t, this.wavelengths = o, this.noiseStrength = n, this.noiseScale = s, this.offset = a, this.alpha = l, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) {
      e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Pl.Nodes.rainbow), n = [];
      return n.push(this.filmThickness.build(e, "f")), n.push(this.movement.build(e, "f")), n.push(this.wavelengths.build(e, "v3")), n.push(this.noiseStrength.build(e, "f")), n.push(this.noiseScale.build(e, "f")), n.push(this.offset.build(e, "v3")), n.push(this.alpha.build(e, "f")), n.push(this.calpha), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("RainbowNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ri = Pl;
ri.Nodes = function() {
  let e = new Y(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`, [ot.simplex]);
  return { rainbow: new Y(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, float alpha, out float calpha) {
                 vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

                 float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);
                 float lalpha = alpha * rainbowContribution;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

                 return res;
             }`, [e]) };
}();
var Al = class extends ae {
  constructor(e, t, o, n, s, a, l, c, u, m, p, d, f, g, x, y) {
    super("v3");
    this.nodeType = "Outline";
    this.firstTime = true, this.outlineColor = e, this.contourColor = t, this.outlineWidth = o, this.contourWidth = n, this.contourThreshold = s, this.outlineThreshold = a, this.contourFrequency = l, this.outlineSmoothing = c, this.contourDirection = u, this.positionalLines = m, this.compensation = p, this.resolution = d, this.normalMap = f, this.depthMap = g, this.pixelRatio = x, this.alpha = y, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.extensions.derivatives = true, this.firstTime) {
      let o = this.outlineWidth.build(e, "f"), n = this.resolution.build(e, "v2"), s = this.compensation.build(e, "b"), a = this.pixelRatio.build(e, "f");
      e.addVertexParsVariable("randomColor", "attribute vec3"), e.addVertexParsVariable("extrudeNormal", "attribute vec3"), e.addVertexParsVariable(o, "uniform float"), e.addVertexParsVariable(n, "uniform vec2"), e.addVertexParsVariable(s, "uniform bool"), e.addVertexParsVariable(a, "uniform float"), e.addVertexParsVariable("vID", "flat out float"), e.addFragmentParsVariable("vID", "flat in float");
      let l = `g${this.uuid.toString().replace(/-/g, "")}`;
      e.addVertexFinalCode(`
                vID = randomColor.r;
                if (${s}) {
                    vec4 ${l}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    vec3 ${l}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal);
                    vec2 ${l}_offset = normalize(${l}_clipNormal.xy) / ${n} * (${o} / 2.0) * ${l}_clipPosition.w * 2.0 * ${a};
                    ${l}_clipPosition.xy += ${l}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${l}_clipPosition;
                }
            `);
    }
    if (e.isShader("fragment")) {
      e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Al.Nodes.outline), n = [];
      return n.push(this.outlineColor.build(e, "c")), n.push(this.contourColor.build(e, "c")), n.push(this.outlineWidth.build(e, "f")), n.push(this.contourWidth.build(e, "f")), n.push(this.contourThreshold.build(e, "f")), n.push(this.outlineThreshold.build(e, "f")), n.push(this.contourFrequency.build(e, "f")), n.push(this.outlineSmoothing.build(e, "f")), n.push(this.contourDirection.build(e, "v3")), n.push(this.positionalLines.build(e, "b")), n.push(this.resolution.build(e, "v2")), n.push(this.normalMap.getTexture(e, "t")), n.push(this.depthMap.getTexture(e, "t")), n.push(this.pixelRatio.build(e, "f")), n.push(this.compensation.build(e, "b")), n.push(this.alpha.build(e, "f")), n.push(this.calpha), this.firstTime = !this.firstTime, e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("OutlineNode is not compatible with " + e.shader + " shader."), "";
  }
};
var oi = Al;
oi.Nodes = function() {
  let e = new Y(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 texelSize = (vec2(1.0) / resolution) * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -texelSize.x, -texelSize.y);
	uvSamples[1] = uv + vec2(0.0, -texelSize.y);
	uvSamples[2] = uv + vec2(  texelSize.x, -texelSize.y);
	uvSamples[3] = uv + vec2( -texelSize.x, 0.0);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  texelSize.x, 0.0);
	uvSamples[6] = uv + vec2( -texelSize.x, texelSize.y);
	uvSamples[7] = uv + vec2(0.0, texelSize.y);
	uvSamples[8] = uv + vec2(  texelSize.x, texelSize.y);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec4 sobel_edge_h = normalSamples[2] + (2.0*normalSamples[5]) + normalSamples[8] - (normalSamples[0] + (2.0*normalSamples[3]) + normalSamples[6]);
  	vec4 sobel_edge_v = normalSamples[0] + (2.0*normalSamples[1]) + normalSamples[2] - (normalSamples[6] + (2.0*normalSamples[7]) + normalSamples[8]);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`);
  return { outline: new Y(`vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return result;
             }`, [e]) };
}();
var Ml = class extends ae {
  constructor(e, t, o, n, s, a, l, c) {
    super("v3");
    this.nodeType = "Transmission";
    this.thickness = e, this.ior = t, this.roughness = o, this.transmissionSamplerSize = n, this.transmissionSamplerMap = s, this.transmissionDepthMap = a, this.aspectRatio = l, this.alpha = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.extensions.shaderTextureLOD = true, e.extensions.derivatives = true, e.isShader("fragment")) {
      e.define("NUM_SAMPLES", 30), e.require("worldPosition"), e.requires.worldNormal = true, e.requires.modelMatrix = true, e.requires.projectionMatrix = true, e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Ml.Nodes.transmission), n = [];
      return n.push(this.thickness.build(e, "f")), n.push(this.ior.build(e, "f")), n.push(this.roughness.build(e, "f")), n.push(this.transmissionSamplerSize.build(e, "v2")), n.push(this.transmissionSamplerMap.getTexture(e, "t")), n.push(this.transmissionDepthMap.getTexture(e, "t")), n.push(this.aspectRatio.build(e, "v2")), n.push("normal"), n.push(this.alpha.build(e, "f")), n.push(this.calpha), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("TransmissionNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ni = Ml;
ni.Nodes = function() {
  let e = new Y(`
            float gaussian(vec2 i) {
                const float sigma = float(NUM_SAMPLES) * .25;
                return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );
            }`), t = new Y(`
            vec4 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

                const int LOD = 2;
                const int sLOD = 4; // tile size = 2^LOD

                vec4 O = vec4(0);
                const int s = NUM_SAMPLES/sLOD;
                for ( int i = 0; i < s*s; i++ ) {
                    int modulo = (i)-((i)/(s))*(s);
                    vec2 d = vec2(float(modulo), float(i/s))*float(sLOD) - float(NUM_SAMPLES)/2.;
                    vec2 uv = U + (scale * aspectRatio) * d;
                    // What is the depth of the opaque object we're trying to sample
                    float opaqueDepth = texture2D(dm, uv).r;
                    if (opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU + ((scale * min(lod / 2., 1.)) * aspectRatio) * d;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
		            #ifdef TEXTURE_LOD_EXT
                    O += gaussian(d) * texture2DLodEXT( sp, uv, lod);
                    #else
                    O += gaussian(d) * textureLod( sp, uv, lod);
                    #endif
                }
                return O / O.a;
            }`, [e]), o = new Y(`
            vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        // Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		        // The thickness is specified in local space.
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`), n = new Y(`
float applyIorToRoughness( float roughness, float ior ) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	} `), s = new Y(`
vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        float lod = applyIorToRoughness(roughness, ior);

        return blur(transmissionSamplerMap, fragCoord, vec2(lod / (transmissionSamplerSize.x / 2.)), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
	}`, [n, t]), a = new Y(`
vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
        vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
        unrefractedCoords += 1.0;
        unrefractedCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
        // Get the specular component.
        return vec4( ( 1.0 ) * transmittedLight.rgb, transmittedLight.a );
    }`, [s, o]);
  return { transmission: new Y(`
            vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec4 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                float lalpha = alpha;

                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return transmission.rgb;
            }`, [a]) };
}();
var on = class extends ae {
  constructor(e, t, o, n, s, a, l, c, u, m, p, d) {
    super("v3");
    this.nodeType = "Depth";
    this.gradientType = e, this.smooth = t, this.near = o, this.far = n, this.isVector = s, this.isWorldSpace = a, this.origin = l, this.direction = c, this.colors = u, this.steps = m, this.num = p, this.alpha = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    let o = `g${this.uuid.toString().replace(/-/g, "")}`, n = new Y(`vec3 ${o}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${o}_MAX_COLORS], float steps[${o}_MAX_COLORS], float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${o}_IS_VECTOR
                   #ifdef ${o}_LINEAR
                       #ifdef ${o}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${o}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${o}_SMOOTH
				for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a;
               calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			   accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
               return color.rgb;
			}`, [on.Nodes.vectorLinearWorldSpaceDepth, on.Nodes.vectorLinearObjectSpaceDepth, on.Nodes.vectorSphericalObjectSpaceDepth, on.Nodes.vectorSphericalWorldSpaceDepth]);
    if (e.isShader("fragment")) {
      e.define(`${o}_MAX_COLORS`, this.num.value + 1), this.smooth.value && e.define(`${o}_SMOOTH`), this.isVector.value > 0.5 && e.define(`${o}_IS_VECTOR`), this.gradientType.value === 0 && e.define(`${o}_LINEAR`), this.isWorldSpace.value > 0.5 && e.define(`${o}_WORLDSPACE`), e.require("worldPosition"), e.addFragmentVariable(this.calpha, "float");
      let s = e.include(n), a = [];
      return a.push(this.near.build(e, "f")), a.push(this.far.build(e, "f")), a.push(this.origin.build(e, "v3")), a.push(this.direction.build(e, "v3")), a.push(this.colors.build(e, "v4[]")), a.push(this.steps.build(e, "f[]")), a.push(this.alpha.build(e, "f")), a.push(this.calpha), e.format(s + "(" + a.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("DepthNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ii = on;
ii.Nodes = function() {
  let e = new Y(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), t = new Y(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), o = new Y(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`), n = new Y(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);
  return { vectorLinearWorldSpaceDepth: e, vectorLinearObjectSpaceDepth: t, vectorSphericalWorldSpaceDepth: o, vectorSphericalObjectSpaceDepth: n };
}();
var si = class extends ae {
  constructor(e, t, o, n) {
    super("v3");
    this.nodeType = "Blend";
    this.a = e, this.b = t, this.alpha = o, this.mode = n;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = [];
      return o.push(this.a.build(e, "c")), o.push(this.b.build(e, "c")), o.push(this.alpha.build(e, "f")), o.push(this.mode.build(e, "i")), e.format("spe_blend(" + o.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("BlendNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var Ol = ((e) => (e.NOISE = "noise", e.MAP = "map", e))(Ol || {});
var _l = class extends ae {
  constructor(e = new fe(0), t, o, n, s, a) {
    super("v3");
    this.nodeType = "VertexDisplacement";
    this.displacementTypeIndex = e, this.intensity = t, this.movementOrTexture = o, Object.values(Ol)[this.displacementTypeIndex.value] === "map" && (this.mat = new rn(this.movementOrTexture.value.matrix)), this.cropOrOffset = n, this.scale = s, this.noiseFunctionIndex = a;
  }
  generate(e, t) {
    if (e.isShader("vertex")) {
      e.define("USE_LAYER_DISPLACE");
      let o, n = [];
      switch (n.push("displaced_position"), n.push("displaced_normal"), Object.values(Ol)[this.displacementTypeIndex.value]) {
        case "map": {
          o = e.include(_l.Nodes.map), n.push(this.movementOrTexture.getTexture(e, "t")), n.push("uv"), n.push(this.cropOrOffset.build(e, "f")), this.mat && n.push(this.mat.build(e, "mat3"));
          break;
        }
        case "noise": {
          let a = Object.values(Zn)[this.noiseFunctionIndex.value], l = new Y(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`), c = new Y(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement) {
							return p + n * ${a}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
						}`, [ot.simplex, ot.simplexFractal, ot.simplexAshima, ot.fbm, ot.perlin]), u = new Y(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`, [c, l]);
          o = e.include(u), n.push(this.scale.build(e, "f")), n.push(this.cropOrOffset.build(e, "v3")), n.push(this.movementOrTexture.build(e, "f"));
          break;
        }
      }
      return n.push(this.intensity.build(e, "f")), n.push("displaced_normal"), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("VertexDisplacementNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var nn = _l;
nn.Nodes = function() {
  let e = new Y(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`), t = new Y(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);
  return { map: new Y(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`, [e, t]) };
}();
var Dl = class extends ae {
  constructor(e, t, o, n, s, a, l, c) {
    super("v3");
    this.nodeType = "Gradient";
    this.gradientType = e, this.smooth = t, this.colors = o, this.steps = n, this.offset = s, this.morph = a, this.angle = l, this.alpha = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      e.define("GRAD_MAX", 10), e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Dl.Nodes.gradient), n = [];
      return n.push(this.gradientType.build(e, "i")), n.push(this.smooth.build(e, "b")), n.push(this.colors.build(e, "v4[]")), n.push(this.steps.build(e, "f[]")), n.push(this.offset.build(e, "v2")), n.push(this.morph.build(e, "v2")), n.push(this.angle.build(e, "f")), n.push(this.alpha.build(e, "f")), n.push(this.calpha), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("GradientNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ai = Dl;
ai.Nodes = function() {
  return { gradient: new Y(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return color.xyz;
			}`) };
}();
var ci = class extends ae {
  constructor(e, t, o, n, s, a, l, c, u, m) {
    super("v3");
    this.nodeType = "CustomTexture";
    this.firstTime = true, this.texture = e, this.textureSize = t, this.crop = o, this.projection = n, this.axis = s, this.side = a, this.size = l, this.mat = c, this.alpha = u, this.mode = m, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    e.require("position"), e.require("normal"), e.require("uv"), e.requires.uv = [true], e.extensions.shaderTextureLOD = true, e.extensions.derivatives = true;
    let o = `g${this.uuid.toString().replace(/-/g, "")}`, n;
    switch (this.projection.value) {
      case 3:
        n = e.include(ci.Nodes.cylindrical);
        break;
      case 2:
        n = e.include(ci.Nodes.spherical);
        break;
      case 1:
        let a = ["vec3(1.0, 0.0, 0.0)", "vec3(0.0, 1.0, 0.0)", "vec3(0.0, 0.0, 1.0)"][this.axis.value], l = new Y(`
		vec3 ${o}_planarTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( (${o}_vCustomUv * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${this.side.value === 2 ? "" : `lalpha *= step(0.0, ${this.side.value === 1 ? "-1.0 * " : ""}dot(vObjectNormal, mat * ${a}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
        n = e.include(l);
        break;
      default:
        n = e.include(ci.Nodes.uv);
        break;
    }
    if (this.projection.value === 1 && this.firstTime) {
      e.addVertexParsCode(`varying vec2 ${o}_vCustomUv;`), e.addFragmentParsCode(`varying vec2 ${o}_vCustomUv;`);
      let a = ["zy", "xz", "xy"][this.axis.value];
      e.addVertexFinalCode(`${o}_vCustomUv = (1. + (transformed.${a})) / 2.;`);
    }
    e.addFragmentVariable(this.calpha, "float");
    let s = [];
    return s.push(this.texture.generate(e, "t")), s.push(this.textureSize.build(e, "v2")), s.push(this.crop.build(e, "f")), s.push(this.mat.build(e, "mat3")), s.push(this.size.build(e, "v2")), s.push(this.alpha.build(e, "f")), s.push(this.mode.build(e, "i")), s.push(this.calpha), this.firstTime = !this.firstTime, e.format(n + "(" + s.join(",") + ")", this.getType(e), t);
  }
};
var li = ci;
li.Nodes = function() {
  let e = new Y(`
vec3 cylindricalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`), t = new Y(`
vec3 sphericalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`), o = new Y(`vec3 uvTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
  return { cylindrical: e, spherical: t, uv: o };
}();
var El = class extends ae {
  constructor(e, t) {
    super("v3");
    this.nodeType = "CustomNormal";
    this.cnormal = e, this.alpha = t;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = e.include(El.Nodes.customNormal), n = [];
      return n.push(this.cnormal.build(e, "v3")), n.push("normal"), n.push(this.alpha.build(e, "f")), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("CustomNormalNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ui = El;
ui.Nodes = function() {
  return { customNormal: new Y(`vec3 customNormal(vec3 cnormal, vec3 norm, float alpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return normal;
			}`) };
}();
function vd(i, r) {
  switch (i.type) {
    case "fresnel":
      return PS(i, r);
    case "gradient":
      return AS(i);
    case "depth":
      return MS(i);
    case "normal":
      return OS(i);
    case "noise":
      return _S(i, r);
    case "rainbow":
      return DS(i);
    case "toon":
      return ES(i, r);
    case "outline":
      return BS(i, r);
    case "transmission":
      return GS(i, r);
    case "displace":
      return RS(i);
    case "color":
      return IS(i, r);
  }
}
function bd(i) {
  return { type: i.type };
}
function ir(i) {
  let { alpha: r, mode: e } = i;
  return __spreadProps(__spreadValues({}, bd(i)), { alpha: r, mode: e });
}
function IS(i, r) {
  return __spreadProps(__spreadValues({}, ir(i)), { color: ze(i.color, r) });
}
function PS(i, r) {
  let { bias: e, scale: t, intensity: o, factor: n, color: s } = i;
  return __spreadProps(__spreadValues({}, ir(i)), { color: ze(s, r), bias: e, scale: t, intensity: o, factor: n });
}
function AS(i) {
  let { gradientType: r, smooth: e, colors: t, steps: o, angle: n, offset: s, morph: a } = i;
  return __spreadProps(__spreadValues({}, ir(i)), { gradientType: r, smooth: e, colors: t.map((l) => new Vector4(l[0], l[1], l[2], l[3])), num: t.length, steps: o, offset: new Vector2(...s), morph: new Vector2(...a), angle: n });
}
function MS(i) {
  let { gradientType: r, near: e, far: t, isVector: o, isWorldSpace: n, origin: s, direction: a, colors: l, steps: c, smooth: u, num: m } = i;
  return __spreadProps(__spreadValues({}, ir(i)), { gradientType: r, near: e, far: t, isVector: o, isWorldSpace: n, origin: new Vector3(...s), direction: a ? new Vector3(...a) : new Vector3(1, 0, 0), num: m, colors: l.map((p) => new Vector4(p[0], p[1], p[2], p[3])), steps: c, smooth: u });
}
function OS(i) {
  let { cnormal: r } = i;
  return __spreadProps(__spreadValues({}, ir(i)), { cnormal: new Vector3(r[0], r[1], r[2]) });
}
function _S(i, r) {
  return __spreadProps(__spreadValues({}, ir(i)), { scale: i.scale, move: i.move, fA: new Vector2(...i.fA), fB: new Vector2(...i.fB), size: new Vector3(...i.size), distortion: new Vector2(...i.distortion), colorA: ze(i.colorA, r), colorB: ze(i.colorB, r), colorC: ze(i.colorC, r), colorD: ze(i.colorD, r), noiseType: i.noiseType });
}
function DS(i) {
  return __spreadProps(__spreadValues({}, ir(i)), { filmThickness: i.filmThickness, movement: i.movement, wavelengths: new Vector3(...i.wavelengths), noiseStrength: i.noiseStrength, noiseScale: i.noiseScale, offset: new Vector3(...i.offset) });
}
function ES(i, r) {
  return __spreadProps(__spreadValues({}, ir(i)), { positioning: i.positioning, colors: i.colors.map((e) => new Vector4(e[0], e[1], e[2], e[3])), num: i.colors.length, steps: i.steps, source: new Vector3(...i.source), isWorldSpace: i.isWorldSpace, noiseStrength: i.noiseStrength, noiseScale: i.noiseScale, shadowColor: ze(i.shadowColor, r), offset: new Vector3(...i.offset) });
}
function BS(i, r) {
  return __spreadProps(__spreadValues({}, ir(i)), { outlineColor: ze(i.outlineColor, r), contourColor: ze(i.contourColor, r), outlineWidth: i.outlineWidth, contourWidth: i.contourWidth, outlineThreshold: i.outlineThreshold, contourThreshold: i.contourThreshold, outlineSmoothing: i.outlineSmoothing, contourFrequency: i.contourFrequency, contourDirection: i.contourDirection, positionalLines: i.positionalLines, compensation: i.compensation, resolution: r.resolutionNode, normalMap: r.normalMap, depthMap: r.normalRenderTarget.depthTexture, pixelRatio: r.pixelRatioNode });
}
function GS(i, r) {
  return __spreadProps(__spreadValues({}, ir(i)), { thickness: i.thickness, ior: i.ior, roughness: i.roughness, transmissionSamplerMap: r.transmissionSamplerMap, transmissionDepthMap: r.transmissionDepthMap });
}
function RS(i) {
  let r = __spreadProps(__spreadValues({}, bd(i)), { intensity: i.intensity });
  if (i.displacementType === "noise")
    return __spreadProps(__spreadValues({}, r), { offset: new Vector3(...i.offset), scale: i.scale, movement: i.movement, noiseType: i.noiseType });
  {
    let e = new Texture(), t = new Matrix3().setUvTransform(0, 0, 1, 1, 0, 0, 0);
    return __spreadProps(__spreadValues({}, r), { texture: e, mat: t, crop: i.crop });
  }
}
var kr = class extends Qe {
};
var Gl = new Map();
var mi = { url: "head", time: 0, data: null, next: null, prev: null };
var sn = { url: "tail", time: 1 / 0, data: null, next: null, prev: null };
mi.next = sn;
sn.prev = mi;
var Sd = 0;
function wd(i) {
  if (typeof i == "string")
    return i;
  let r = Date.now(), e = Gl.get(i);
  return e === void 0 ? (e = { url: URL.createObjectURL(new Blob([i])), data: i, time: r, next: null, prev: null }, Gl.set(i, e)) : (e.time = r, e.prev.next = e.next, e.next.prev = e.prev), e.prev = sn.prev, e.next = sn, sn.prev.next = e, sn.prev = e, r - Sd > 1e3 * 10 && (Sd = r + 1e3, setTimeout(() => {
    let t = Date.now(), o = mi.next;
    for (; o.time < t - 1e3 * 10; )
      URL.revokeObjectURL(o.url), Gl.delete(o.data), o = o.next, o.prev = mi, mi.next = o;
  }, 900)), e.url;
}
var an = class {
  constructor(r, e) {
    this.data = r;
    this.onImageLoad = e;
    this.loaded = false;
    this.updateSrc(r.data);
  }
  updateSrc(r) {
    this.dispose(), this.loaded = false, this.img = new Image(), this.img.src = wd(r), this.img.onload = () => {
      this.loaded = true;
      let e = [1e3, 1001, 1002];
      for (let t of e) {
        let o = this[t];
        o && (o.image = this.img, o.needsUpdate = true);
      }
      this.onImageLoad && this.onImageLoad();
    };
  }
  getTexture(r) {
    let e = this[r];
    if (e)
      return e;
    {
      let t = new Texture(this.img, void 0, r, r);
      return this.loaded && (t.needsUpdate = true), this[r] = t, t;
    }
  }
  dispose() {
    var _a2, _b2, _c2;
    (_a2 = this[1e3]) == null ? void 0 : _a2.dispose(), this[1e3] = void 0, (_b2 = this[1001]) == null ? void 0 : _b2.dispose(), this[1001] = void 0, (_c2 = this[1002]) == null ? void 0 : _c2.dispose(), this[1002] = void 0;
  }
};
var oo = class extends an {
};
function VS(i, r) {
  switch (i.type) {
    case "noise":
      return r === "noiseType";
    case "texture":
      return r === "projection" || r === "axis" || r === "side";
    case "displace":
      return r === "noiseType";
    case "depth":
      return r === "num" || r === "smooth" || r === "isWorldSpace" || r === "gradientType" || r === "isVector";
    default:
      return false;
  }
}
function Rl(i, r, e, t) {
  let o = e.uniforms[`f${e.id}_texture`];
  if (!o)
    return false;
  let n = false, s = i;
  if ("image" in s) {
    let a = s.image, l = r.image(a), c = o;
    c instanceof oo || c.image.dispose(), c.image = l;
  }
  if ("wrapping" in s) {
    let a = o;
    a.wrap = s.wrapping;
  }
  if ("repeat" in s || "offset" in s) {
    let a = "mat";
    e.uniforms[`f${e.id}_${a}`].value.setUvTransform(t.offset[0], t.offset[1], t.repeat[0], t.repeat[1], 0, 0, 0);
  }
  return n;
}
function Td(i, r, e, t) {
  let o = false;
  for (let [n, s] of Object.entries(i)) {
    if (!n || s === void 0 || zl(n, e, t))
      continue;
    e.visible = t.visible;
    let a = e.uniforms[`f${e.id}_${n}`];
    if (!!a)
      switch (a.constructor) {
        case we:
          if (typeof s == "string") {
            let l = r.getColor(s);
            l && (a.value = l);
            break;
          } else {
            let l = s;
            a.value instanceof kr ? a.value = new Qe(l.r, l.g, l.b, l.a) : a.setRGBA(l);
            break;
          }
        case Pt:
          if (typeof s == "string") {
            let l = r.getColor(s);
            l && (a.value = l);
            break;
          } else {
            let l = s;
            a.value instanceof kr ? a.value = new Qe(l.r, l.g, l.b, l.a) : a.value.setRGBA(l.r, l.g, l.b, l.a);
            break;
          }
        case ke: {
          let l = s;
          a.value.setX(l[0]), a.value.setY(l[1]);
          break;
        }
        case Je: {
          let l = s;
          a.value.setX(l[0]), a.value.setY(l[1]), a.value.setZ(l[2]);
          break;
        }
        case lt: {
          let l = s;
          Rl(l, r, e, l);
          break;
        }
        case Bt: {
          s.forEach((l, c) => {
            a.value[c].setX(l[0]), a.value[c].setY(l[1]), a.value[c].setZ(l[2]), a.value[c].setW(l[3]);
          });
          break;
        }
        default: {
          o = o || VS(e, n), a.value = s;
          break;
        }
      }
  }
  return o;
}
var Vl = class extends ae {
  constructor(e, t, o) {
    super("v3");
    this.nodeType = "Matcap";
    this.texture = e, this.alpha = t, this.mode = o, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Vl.Nodes.matcap);
      e.require("normal"), e.requires.normal = true;
      let n = [];
      return n.push(this.texture.generate(e, "t")), n.push("normal"), n.push(this.alpha.build(e, "f")), n.push(this.mode.build(e, "i")), n.push(this.calpha), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("MatcapNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var di = Vl;
di.Nodes = function() {
  return { matcap: new Y(`vec3 matcap(sampler2D matcapTex, vec3 normal, float alpha, int mode, out float calpha) {
                vec3 viewDir = normalize( vViewPosition );
                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
                vec3 y = cross( viewDir, x );
                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
                vec4 matcapColor = texture2D( matcapTex, uv );

                calpha =  alpha / clamp( alpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;
                
                return matcapColor.rgb;
            }
            `) };
}();
var fi = class extends Ne {
  constructor(e, t) {
    super("t");
    this.image = e;
    this.wrap = t;
  }
  get value() {
    return this.image.getTexture(this.wrap);
  }
};
var Ks = class extends Ne {
  constructor(e) {
    super("v3");
    this.image = e;
    this._value = new Vector3();
  }
  get value() {
    return this._value.x = this.image.img.width, this._value.y = this.image.img.height, this._value;
  }
};
var Fl = class extends ae {
  constructor(e, t, o, n, s, a, l, c, u, m) {
    super("v3");
    this.nodeType = "Toon";
    this.positioning = e, this.colors = t, this.steps = o, this.source = n, this.isWorldSpace = s, this.noiseStrength = a, this.noiseScale = l, this.shadowColor = c, this.offset = u, this.alpha = m, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("worldNormal"), e.require("worldPosition"), e.isShader("fragment")) {
      e.define("COLORS_MAX", 10), e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Fl.Nodes.toon), n = [];
      return n.push(this.positioning.build(e, "i")), n.push(this.colors.build(e, "v4[]")), n.push(this.steps.build(e, "f[]")), n.push(this.source.build(e, "v3")), n.push(this.isWorldSpace.build(e, "b")), n.push(this.noiseStrength.build(e, "f")), n.push(this.noiseScale.build(e, "f")), n.push(this.shadowColor.build(e, "v4")), n.push(this.offset.build(e, "v3")), n.push(this.alpha.build(e, "f")), n.push(this.calpha), e.format(o + "(" + n.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("ToonNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var hi = Fl;
hi.Nodes = function() {
  let e = new Y(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`), t = new Y(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`), o = new Y(`float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`, [t]), n = new Y(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`), s = new Y(`vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`, [n]);
  return { toon: new Y(`vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`, [ot.simplex, e, o, s]) };
}();
var ar = class {
  constructor(r, e, t, o) {
    this.type = r;
    this.id = e;
    this.uuid = t;
    this.uniforms = {};
    for (let n in o)
      this.uniforms[`f${this.id}_${n}`] = o[n];
  }
  static create(r, e, t, o) {
    var _a2, _b2, _c2, _d2, _e, _f, _g2;
    if (t.type === "light")
      return lr.createLigherLayer(r, e, t, o);
    if (t.type === "texture") {
      let n = o.image(t.texture.image), s = new fi(n, t.texture.wrapping), a = new Ks(n), l = new Matrix3().setUvTransform(t.texture.offset[0], t.texture.offset[1], t.texture.repeat[0], t.texture.repeat[1], 0, 0, 0), c = new rn(l), u = new W(t.crop ? 1 : 0), m = new fe((_a2 = t.projection) != null ? _a2 : 0), p = new fe((_b2 = ["x", "y", "z"].indexOf(t.axis)) != null ? _b2 : 0), d = new fe((_c2 = t.side) != null ? _c2 : 0), f = new ke(t.size ? new Vector2(t.size[0], t.size[1]) : new Vector2(100, 100)), g = new W((_d2 = t.alpha) != null ? _d2 : 1), x = new fe((_e = t.mode) != null ? _e : 0), y = new li(s, a, u, m, p, d, f, c, g, x), v = new ve(y.calpha, "f");
      return new We("texture", r, e, { texture: s, textureSize: a, crop: u, projection: m, axis: p, side: d, size: f, mat: c, alpha: g, mode: x }, y, x, v);
    } else if (t.type === "matcap") {
      let n = o.image(t.texture.image), s = new fi(n, t.texture.wrapping), a = new W((_f = t.alpha) != null ? _f : 1), l = new fe((_g2 = t.mode) != null ? _g2 : 0), c = new di(s, a, l), u = new ve(c.calpha, "f");
      return new We("matcap", r, e, { texture: s, alpha: a, mode: l }, c, l, u);
    } else {
      let n = kS(r, e, t, o);
      for (let s in t)
        zl(s, n, t);
      return n;
    }
  }
  updateByOp(r, e, t) {
    let o = r;
    if (o.path[0] === void 0) {
      if (o.type === 0)
        return "type" in o.props || "category" in o.props ? true : Td(o.props, t, this, e);
    } else if (o.path[0] === "texture")
      return "texture" in e ? Rl(o.props, t, this, e.texture) : true;
    return false;
  }
  dispose() {
  }
  hasValueByKey(r) {
    return this.uniforms[r] !== void 0;
  }
  hasValue(r) {
    return this.hasValueByKey(`f${this.id}_${r}`);
  }
  setValue(r, e) {
    let t = `f${this.id}_${r}`;
    this.hasValueByKey(t) && e !== void 0 && (this.uniforms[t].value = e);
  }
  getValue(r) {
    let e = `f${this.id}_${r}`;
    if (this.hasValueByKey(e))
      return this.uniforms[e].value;
  }
  getName(r) {
    let t = /f\d+_(.*)/.exec(r);
    if (t && t.length > 1)
      return t[1];
    console.log(`Layer.getName: error ${r}`);
  }
  getNames() {
    let r = [];
    for (let e in this.uniforms) {
      let t = this.getName(e);
      t && r.push(t);
    }
    return r;
  }
};
var We = class extends ar {
  constructor(e, t, o, n, s, a, l) {
    super(e, t, o, n);
    this.color = s;
    this.mode = a;
    this.alpha = l;
  }
};
var cn = class extends ar {
  constructor(e, t, o, n, s) {
    super(e, t, o, n);
    this.position = s;
  }
};
var lr = class extends ar {
  constructor(e, t, o, n) {
    super("light", e, t, { alpha: n.shadingAlpha, mode: n.shadingBlend });
    this.data = o;
    this.node = n;
  }
  static createLigherLayer(e, t, o, n) {
    var _a2, _b2, _c2, _d2, _e, _f, _g2, _h2;
    let s, a = new W(o.alpha), l = new fe(o.mode);
    return o.category === "lambert" ? (s = new Kn(), s.emissive = new we((_a2 = n.color(o.emissive)) != null ? _a2 : 0)) : o.category === "phong" ? (s = new Ys(), s.shininess = new W((_b2 = o.shininess) != null ? _b2 : 30), s.specular = new we((_c2 = n.color(o.specular)) != null ? _c2 : 1118481)) : o.category === "toon" ? (s = new Jn(), s.shininess = new W((_d2 = o.shininess) != null ? _d2 : 30), s.specular = new we((_e = n.color(o.specular)) != null ? _e : 1118481)) : o.category === "physical" ? (s = new Qn(), s.roughness = new W((_f = o.roughness) != null ? _f : 0.3), s.metalness = new W((_g2 = o.metalness) != null ? _g2 : 0), s.reflectivity = new W((_h2 = o.reflectivity) != null ? _h2 : 0.5)) : s = new Ur(), s.alpha = new W(1), s.shadingAlpha = a, s.shadingBlend = l, new lr(e, t, o, s);
  }
};
function Nd(i) {
  let r = i instanceof ar ? i.type : i;
  return r === "texture" || r === "displace_map" || r === "matcap";
}
function jS(i, r, e, t) {
  var _a2, _b2, _c2, _d2, _e, _f, _g2, _h2, _i2, _j, _k, _l2, _m, _n2, _o2, _p2, _q, _r2, _s, _t2, _u2, _v, _w, _x2, _y2, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S2, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga, _ha, _ia, _ja, _ka, _la, _ma, _na, _oa, _pa, _qa, _ra, _sa, _ta, _ua, _va, _wa, _xa, _ya, _za, _Aa, _Ba, _Ca, _Da, _Ea, _Fa, _Ga, _Ha, _Ia, _Ja, _Ka, _La, _Ma, _Na;
  switch (i) {
    case "color": {
      let o = new we((_a2 = t.color) != null ? _a2 : 5855577), n = new W((_b2 = t.alpha) != null ? _b2 : 1), s = new ve("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
      s.keywords.alpha = n;
      let a = new fe((_c2 = t.mode) != null ? _c2 : 0);
      return o.alpha = n, new We(i, r, e, { color: o, alpha: n, mode: a }, o, a, s);
    }
    case "fresnel": {
      let o = new we((_d2 = t.color) != null ? _d2 : 16777215), n = new W((_e = t.bias) != null ? _e : 0.1), s = new W((_f = t.scale) != null ? _f : 1), a = new W((_g2 = t.intensity) != null ? _g2 : 2), l = new W((_h2 = t.factor) != null ? _h2 : 1), c = new W((_i2 = t.alpha) != null ? _i2 : 1), u = new fe((_j = t.mode) != null ? _j : 0), m = new ti(o, n, s, a, l, c, u), p = new ve(m.calpha, "f");
      return new We(i, r, e, { color: o, bias: n, scale: s, intensity: a, factor: l, alpha: c, mode: u }, m, u, p);
    }
    case "rainbow": {
      let o = new W((_k = t.filmThickness) != null ? _k : 30), n = new W((_l2 = t.movement) != null ? _l2 : 0), s = new Je((_m = t.wavelengths) != null ? _m : new Vector3(0, 0, 0)), a = new W((_n2 = t.noiseStrength) != null ? _n2 : 0), l = new W((_o2 = t.noiseScale) != null ? _o2 : 1), c = new Je((_p2 = t.offset) != null ? _p2 : new Vector3(0, 0, 0)), u = new W((_q = t.alpha) != null ? _q : 1), m = new ri(o, n, s, a, l, c, u), p = new ve(m.calpha, "f"), d = new fe((_r2 = t.mode) != null ? _r2 : 0);
      return new We(i, r, e, { filmThickness: o, movement: n, wavelengths: s, noiseStrength: a, noiseScale: l, offset: c, alpha: u, mode: d }, m, d, p);
    }
    case "transmission": {
      let o = new W((_s = t.thickness) != null ? _s : 10), n = new W((_t2 = t.ior) != null ? _t2 : 1.5), s = new W((_u2 = t.roughness) != null ? _u2 : 0.5), a = new ke((_v = t.transmissionSamplerSize) != null ? _v : new Vector2(2048, 2048)), l = (_w = t.transmissionSamplerMap) != null ? _w : new Texture(), c = (_x2 = t.transmissionDepthMap) != null ? _x2 : new Texture(), u = new lt(l), m = new lt(c), p = window.innerWidth, d = window.innerHeight, f = p >= d ? new ke(d / p, 1) : new ke(1, p / d), g = new W((_y2 = t.alpha) != null ? _y2 : 1), x = new ni(o, n, s, a, u, m, f, g), y = new ve(x.calpha, "f"), v = new fe((_z = t.mode) != null ? _z : 0);
      return new We(i, r, e, { thickness: o, ior: n, roughness: s, transmissionSamplerSize: a, transmissionSamplerMap: u, transmissionDepthMap: m, aspectRatio: f, alpha: g, mode: v }, x, v, y);
    }
    case "toon": {
      let o = new fe((_A = t.positioning) != null ? _A : 0), n;
      t.colors ? n = new Bt(t.colors.length, t.colors) : (n = new Bt(10, new Vector4(0, 0, 0, 1)), n.value[1] = new Vector4(1, 1, 1, 1));
      let s;
      t.steps ? s = new He(t.steps.length, t.steps) : (s = new He(10, 1), s.value[0] = 0);
      let a = new Je((_B = t.source) != null ? _B : new Vector3(0, 0, 0)), l = new jr((_C = t.isWorldSpace) != null ? _C : true), c = new W((_D = t.noiseStrength) != null ? _D : 0), u = new W((_E = t.noiseScale) != null ? _E : 1), m = new Pt(t.shadowColor), p = new Je((_F = t.offset) != null ? _F : new Vector3(0, 0, 0)), d = new W((_G = t.alpha) != null ? _G : 1), f = new hi(o, n, s, a, l, c, u, m, p, d), g = new ve(f.calpha, "f"), x = new fe((_H = t.mode) != null ? _H : 0);
      return new We(i, r, e, { positioning: o, colors: n, steps: s, source: a, isWorldSpace: l, noiseStrength: c, noiseScale: u, shadowColor: m, offset: p, alpha: d, mode: x }, f, x, g);
    }
    case "outline": {
      let o = new we((_I = t.outlineColor) != null ? _I : 16777215), n = new we((_J = t.contourColor) != null ? _J : 16777215), s = new W((_K = t.outlineWidth) != null ? _K : 0.1), a = new W((_L = t.contourWidth) != null ? _L : 0.1), l = new W((_M = t.outlineThreshold) != null ? _M : 0.1), c = new W((_N = t.contourThreshold) != null ? _N : 0.1), u = new W((_O = t.outlineSmoothing) != null ? _O : 0.1), m = new W((_P = t.contourFrequency) != null ? _P : 0.1), p = new Je((_Q = t.contourDirections) != null ? _Q : new Vector3(0, 1, 0)), d = new jr((_R = t.positionalLines) != null ? _R : false), f = new jr((_S2 = t.compensation) != null ? _S2 : true), g = (_T = t.normalMap) != null ? _T : new Texture(), x = new lt(g), y = (_U = t.depthMap) != null ? _U : new Texture(), v = new lt(y), P = (_V = t.pixelRatio) != null ? _V : new W(window.devicePixelRatio), S = (_W = t.resolution) != null ? _W : new ke(new Vector2(1, 1)), b = new W((_X = t.alpha) != null ? _X : 1), E = new oi(o, n, s, a, l, c, u, m, p, d, f, S, x, v, P, b), w = new ve(E.calpha, "f"), h = new fe((_Y = t.mode) != null ? _Y : 0);
      return new We(i, r, e, { outlineColor: o, contourColor: n, outlineWidth: s, contourWidth: a, outlineThreshold: l, contourThreshold: c, outlineSmoothing: u, contourFrequency: m, contourDirection: p, positionalLines: d, compensation: f, resolution: S, normalMap: x, depthMap: v, pixelRatio: P, alpha: b, mode: h }, E, h, w);
    }
    case "depth": {
      let o = new fe((_Z = t.gradientType) != null ? _Z : 0), n = new jr((__ = t.smooth) != null ? __ : false), s = new W((_$ = t.near) != null ? _$ : 50), a = new W((_aa = t.far) != null ? _aa : 200), l = new W((_ba = t.isVector) != null ? _ba : 1), c = new W((_ca = t.isWorldSpace) != null ? _ca : 0), u = new Je((_da = t.origin) != null ? _da : new Vector3()), m = new Je((_ea = t.direction) != null ? _ea : new Vector3()), p = new fe((_fa = t.num) != null ? _fa : 0), d;
      t.colors ? d = new Bt(p.value + 1, t.colors) : (d = new Bt(p.value + 1, new Vector4(0, 0, 0, 1)), d.value[1] = new Vector4(1, 1, 1, 1));
      let f;
      t.steps ? f = new He(p.value + 1, t.steps) : (f = new He(p.value + 1, 1), f.value[0] = 0);
      let g = new W((_ga = t.alpha) != null ? _ga : 1), x = new fe((_ha = t.mode) != null ? _ha : 0), y = new ii(o, n, s, a, l, c, u, m, d, f, p, g), v = new ve(y.calpha, "f");
      return new We(i, r, e, { gradientType: o, smooth: n, near: s, far: a, isVector: l, isWorldSpace: c, origin: u, direction: m, colors: d, steps: f, num: p, alpha: g, mode: x }, y, x, v);
    }
    case "noise": {
      let o = new W((_ia = t.scale) != null ? _ia : 1), n = new Je((_ja = t.size) != null ? _ja : new Vector3(100, 100, 100)), s = new W((_ka = t.move) != null ? _ka : 1), a = new ke((_la = t.fA) != null ? _la : new Vector2(1.7, 9.2)), l = new ke((_ma = t.fB) != null ? _ma : new Vector2(8.3, 2.8)), c = new ke((_na = t.distortion) != null ? _na : new Vector2(1, 1)), u = new Pt(t.colorA), m = new Pt(t.colorB), p = new Pt(t.colorC), d = new Pt(t.colorD), f = new W((_oa = t.alpha) != null ? _oa : 1), g = new fe((_pa = t.mode) != null ? _pa : 0), x = new fe((_qa = t.noiseType) != null ? _qa : 0), y = new ei(o, n, s, a, l, c, u, m, p, d, f, x), v = new ve(y.calpha, "f");
      return new We(i, r, e, { scale: o, size: n, move: s, fA: a, fB: l, distortion: c, colorA: u, colorB: m, colorC: p, colorD: d, alpha: f, mode: g, noiseType: x }, y, g, v);
    }
    case "normal": {
      let o = new Je((_ra = t.cnormal) != null ? _ra : new Vector3(1, 1, 1)), n = new W((_sa = t.alpha) != null ? _sa : 1), s = new fe((_ta = t.mode) != null ? _ta : 0), a = new ui(o, n), l = new ve("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
      return l.keywords.alpha = n, new We(i, r, e, { cnormal: o, alpha: n, mode: s }, a, s, l);
    }
    case "gradient": {
      let o = new fe((_ua = t.gradientType) != null ? _ua : 0), n = new jr((_va = t.smooth) != null ? _va : false), s;
      t.colors ? s = new Bt(t.colors.length, t.colors) : (s = new Bt(10, new Vector4(0, 0, 0, 1)), s.value[1] = new Vector4(1, 1, 1, 1));
      let a;
      t.steps ? a = new He(t.steps.length, t.steps) : (a = new He(10, 1), a.value[0] = 0);
      let l = new ke((_wa = t.offset) != null ? _wa : new Vector2(0, 0)), c = new ke((_xa = t.morph) != null ? _xa : new Vector2(0, 0)), u = new W((_ya = t.angle) != null ? _ya : 0), m = new W((_za = t.alpha) != null ? _za : 1), p = new fe((_Aa = t.mode) != null ? _Aa : 0), d = new ai(o, n, s, a, l, c, u, m), f = new ve(d.calpha, "f");
      return new We(i, r, e, { gradientType: o, smooth: n, colors: s, steps: a, offset: l, morph: c, angle: u, alpha: m, mode: p }, d, p, f);
    }
    case "displace": {
      let o = new fe((_Ba = t.displacementType) != null ? _Ba : 0);
      if (o.value === 0) {
        let n = new Je((_Ca = t.offset) != null ? _Ca : new Vector3(0, 0, 0)), s = new W((_Da = t.scale) != null ? _Da : 10), a = new W((_Ea = t.intensity) != null ? _Ea : 8), l = new W((_Fa = t.movement) != null ? _Fa : 1), c = new W((_Ga = t.alpha) != null ? _Ga : 1), u = new fe((_Ha = t.mode) != null ? _Ha : 0), m = new fe((_Ia = t.noiseType) != null ? _Ia : 0), p = new nn(o, a, l, n, s, m);
        return new cn(i, r, e, { displacementType: o, offset: n, scale: s, intensity: a, movement: l, alpha: c, mode: u, noiseType: m }, p);
      } else {
        let n = (_Ja = t.texture) != null ? _Ja : new Texture(), s = n.matrix;
        t.mat && s.copy(t.mat);
        let a = new W((_Ka = t.intensity) != null ? _Ka : 8), l = new lt(n), c = new W((_La = t.crop) != null ? _La : 0), u = new W((_Ma = t.alpha) != null ? _Ma : 1), m = new fe((_Na = t.mode) != null ? _Na : 0), p = new nn(o, a, l, c);
        return new cn(i, r, e, { displacementType: o, intensity: a, texture: l, crop: c, mat: p.mat, alpha: u, mode: m }, p);
      }
    }
    default: {
      let o = new we(1, 0, 0, 1), n = new W(1), s = new ve("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
      s.keywords.alpha = n;
      let a = new fe(0);
      return o.alpha = n, new We(i, r, e, { color: o, alpha: n, mode: a }, o, a, s);
    }
  }
}
function kS(i, r, e, t) {
  let o = vd(e, t);
  return jS(e.type, i, r, o);
}
function zl(i, r, e) {
  if (e.type === "displace" && (i === "intensity" || i === "visible")) {
    let t = r.uniforms[`f${r.id}_intensity`];
    return t ? (t.value = e.intensity * (e.visible ? 1 : 0), t) : void 0;
  }
  if (e.type !== "displace" && (i === "alpha" || i === "visible")) {
    let t = r.uniforms[`f${r.id}_alpha`];
    if (!t)
      return;
    if (t.value = e.alpha * (e.visible ? 1 : 0), e.type === "outline" && i == "visible") {
      let o = r.uniforms[`f${r.id}_compensation`];
      o && (o.value = e.compensation && e.visible);
    }
    return t;
  }
}
var Gt = class extends ShaderMaterial {
  constructor(e, t) {
    super(void 0);
    var _a2, _b2;
    this.data = e;
    this.layerIdGen = 0;
    this.type = "NodeMaterial";
    this.uniformsBackup = {};
    this.fog = true, this.updaters = [], this.dithering = true, this.vertexColors = true, this.onBeforeCompile = this._onBeforeCompile;
    let o = (_a2 = e.layers) != null ? _a2 : yr.defaultTwoLayerData("phong").layers;
    this.layers = o.map((n) => ar.create(this.layerIdGen++, n.id, n.data, t)), this.layers.reverse(), this.name = (_b2 = e.name) != null ? _b2 : "Untitled Material", this.onUpdate(t);
  }
  get fragment() {
    return this.lightLayer.node;
  }
  get category() {
    return this.lightLayer.data.category;
  }
  getLayersOfType(e) {
    return this.layers.filter((t) => t.type === e);
  }
  getLayerByUuid(e) {
    return this.layers.find((t) => t.uuid === e);
  }
  onUpdate(e) {
    this.lightLayer = this.layers.find((t) => t instanceof lr), this.lightLayer === void 0 && (this.lightLayer = new lr(0, "", Br.defaultData("light", "basic"), new Ur())), this.lightLayer.node instanceof Ur || (this.lightLayer.node.penumbraSize = e.penumbraSizeNode), this.dispose(), this.needsUpdate = true, this.blendColors(), this.blendAfterColors(), this.blendPositions();
  }
  updateByOp(e, t, o) {
    if (this.data = t, e.path[0] === "layers") {
      let n = e.path[1];
      if (n === void 0) {
        if (this.layers.reverse(), e.type === 4) {
          let s = ar.create(this.layerIdGen++, e.id, e.data, o);
          this.layers.splice(e.localIndex, 0, s);
        } else if (e.type === 5)
          this.layers.splice(e.localIndex, 1)[0].dispose();
        else if (e.type === 6) {
          let s = this.layers.findIndex((l) => l.uuid === e.id), a = this.layers[s];
          this.layers.splice(s, 1), this.layers.splice(e.localIndex, 0, a);
        }
        this.layers.reverse(), this.onUpdate(o);
      } else {
        let s = this.layers.find((a) => a.uuid === n);
        if (s) {
          let a = t.layers.data(n);
          if (s.updateByOp(__spreadProps(__spreadValues({}, e), { path: e.path.slice(2) }), a, o)) {
            let c = ar.create(this.layerIdGen++, n, a, o);
            this.layers.splice(this.layers.findIndex((u) => u.uuid === n), 1, c), this.onUpdate(o);
          }
        }
      }
    }
  }
  blendColors() {
    let e = this.layers.findIndex((o) => o instanceof We), t = this.layers.findIndex((o) => o instanceof lr);
    if (e !== -1 && e < t) {
      let o = this.layers[e].color;
      for (let n = e + 1; n < t; ++n) {
        let s = this.layers[n];
        s instanceof We && (o = new si(o, s.color, s.alpha, s.mode));
      }
      this.fragment.color = o;
    } else
      this.fragment.color = void 0;
  }
  blendAfterColors() {
    let e = new ve("outgoingLight", "f"), t = this.layers.findIndex((o) => o instanceof lr);
    if (this.layers.length > t + 1) {
      for (let o = t + 1; o < this.layers.length; ++o) {
        let n = this.layers[o];
        n instanceof We && (e = new si(e, n.color, n.alpha, n.mode));
      }
      this.fragment.afterColor = e;
    } else
      this.fragment.afterColor = void 0;
  }
  blendPositions() {
    let e = this.layers.filter((t) => t instanceof cn);
    if (e.length > 0) {
      let t = e[0].position;
      for (let o = 1; o < e.length; ++o)
        e[o] && (t = new dt(t, e[o].position, dt.ADD), t = new dt(t, new W(0.5).setReadonly(true), dt.MUL));
      this.fragment.position = t;
    } else
      this.fragment.position = void 0;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getVertexShader() {
    return this.vertexShader;
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  _onBeforeCompile(e, t) {
    this.build({ renderer: t }), e.defines = this.defines, e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.extensionDerivatives = this.extensions.derivatives === true, e.extensionFragDepth = this.extensions.fragDepth === true, e.extensionDrawBuffers = this.extensions.drawBuffers === true, e.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === true;
  }
  clampUniformsForPreview(e, t) {
    let o = (n, s, a) => Math.min(Math.max(n, s), a);
    for (let n of this.layers)
      if (n.type == "displace") {
        this.uniformsBackup[`f${n.id}_intensity`] = n.uniforms[`f${n.id}_intensity`].value;
        let s = o(n.uniforms[`f${n.id}_intensity`].value, e, t);
        n.uniforms[`f${n.id}_intensity`].value = s;
      }
  }
  restoreClampedUniforms() {
    for (let e of this.layers)
      e.type == "displace" && (e.uniforms[`f${e.id}_intensity`].value = this.uniformsBackup[`f${e.id}_intensity`]);
  }
  customProgramCacheKey() {
    return this.getHash();
  }
  updateFrame(e) {
    for (let t = 0; t < this.updaters.length; ++t)
      e.updateNode(this.updaters[t]);
  }
  build(e) {
    var _a2;
    e = e != null ? e : {};
    let t = (_a2 = e.builder) != null ? _a2 : new Xs();
    return t.setMaterial(this, e.renderer), t.build(this.fragment, this.fragment), this.vertexShader = t.getCode("vertex"), this.fragmentShader = t.getCode("fragment"), this.defines = t.defines, this.uniforms = t.uniforms, this.extensions = t.extensions, this.updaters = t.updaters, this.fog = t.requires.fog, this.lights = t.requires.lights, this.transparent = t.requires.transparent || this.blending > NormalBlending, this;
  }
  dispose() {
    this.layers.forEach((e) => e.dispose()), super.dispose();
  }
  getHash() {
    let e = "{";
    return e += '"fragment":' + this.fragment.getHash(), e += "}", e;
  }
};
Object.defineProperties(Gt.prototype, { properties: { get: function() {
  return this.fragment.properties;
} }, needsUpdate: { set: function(i) {
  i === true && this.version++, this.needsCompile = i;
}, get: function() {
  return this.needsCompile;
} } });
var no = class extends Gt {
};
function JS(i, r) {
  r.uniforms[`f${r.id}_transmissionSamplerMap`].value = i.texture, r.uniforms[`f${r.id}_transmissionDepthMap`].value = i.depthTexture;
}
function ZS(i, r) {
  r.uniforms[`f${r.id}_normalMap`].value = i.texture, r.uniforms[`f${r.id}_depthMap`].value = i.depthTexture;
}
function ew(i) {
  var _a2, _b2;
  if (i.geometry.attributes.extrudeNormals || !i.geometry.attributes.position)
    return;
  let r = new Map(), e = i.geometry.attributes.position.array, t = i.geometry.attributes.normal.array, o = new Float32Array(e.length);
  for (let n = 0; n < e.length; n += 3) {
    let s = `${e[n]}_${e[n + 1]}_${e[n + 2]}`, a = new Vector3(t[n], t[n + 1], t[n + 2]);
    r.has(s) ? (_a2 = r.get(s)) == null ? void 0 : _a2.normals.push(a) : r.set(s, { normals: [a], result: new Vector3() });
  }
  r.forEach((n, s) => {
    for (let a of n.normals)
      n.result.add(a);
    n.result.divideScalar(n.normals.length);
  });
  for (let n = 0; n < e.length; n += 3) {
    let s = `${e[n]}_${e[n + 1]}_${e[n + 2]}`, a = (_b2 = r.get(s)) == null ? void 0 : _b2.result;
    a && (o[n] = a.x, o[n + 1] = a.y, o[n + 2] = a.z);
  }
  i.geometry.setAttribute("extrudeNormal", new Float32BufferAttribute(o, 3));
}
function tw(i) {
  if (i.geometry.attributes.extrudeNormals || !i.geometry.attributes.position)
    return;
  let r = i.geometry.attributes.position.array, e = new Float32Array(r.length), t = new Vector3();
  for (let o = 0; o < r.length; o += 3)
    t.set(r[o], r[o + 1], r[o + 2]).normalize(), e[o] = t.x, e[o + 1] = t.y, e[o + 2] = t.z;
  i.geometry.setAttribute("extrudeNormal", new Float32BufferAttribute(e, 3));
}
function io(i) {
  if (Array.isArray(i.material)) {
    for (let r of i.material)
      if (r.getLayersOfType("outline").length === 0)
        return;
  } else if (i.material.getLayersOfType("outline").length === 0)
    return;
  i.objectType === "Mesh2D" ? tw(i) : ew(i);
}
function so(i) {
  if (!i.geometry.attributes.position)
    return;
  let r = i.geometry.attributes.position.array, e = new Float32Array(r.length), t = parseInt(i.uuid.replace(/\D/g, "")), o = [MathUtils.seededRandom(t), MathUtils.seededRandom(t + 1e4), MathUtils.seededRandom(t + 2e4)];
  for (let n = 0; n < r.length; n++)
    e[n] = o[n % 3];
  i.geometry.setAttribute("randomColor", new BufferAttribute(e, 3));
}
function Cd(i, r, e) {
  let t = false, o = e.getLayersOfType("transmission"), n = e.getLayersOfType("outline");
  return n.length > 0 && (r.layers.set(8), o.length === 0 && r.layers.enable(3), t = true, i !== void 0 && n.forEach((s) => ZS(i, s)), so(r), io(r)), o.length === 0 && n.length === 0 && r.layers.set(0), t;
}
function Ld(i, r, e) {
  if (!e.layers)
    return false;
  let t = false, o = e.getLayersOfType("transmission"), n = e.getLayersOfType("outline");
  return o.length > 0 && (r.layers.set(3), n.length > 0 && r.layers.enable(8), t = true, i !== void 0 && o.forEach((s) => JS(i, s))), o.length === 0 && n.length === 0 && r.layers.set(0), t;
}
function Ad(i, r) {
  let e = false;
  return r.traverseEntity((t) => {
    if (t instanceof Mesh)
      if (Array.isArray(t.material))
        for (let o = 0; o < t.material.length; o++)
          Cd(i, t, t.material[o]) && (e = true);
      else
        Cd(i, t, t.material) && (e = true);
  }), e;
}
function Md(i, r) {
  let e = false;
  return r.traverseEntity((t) => {
    if (t instanceof Mesh)
      if (Array.isArray(t.material))
        for (let o = 0; o < t.material.length; o++)
          Ld(i, t, t.material[o]) && (e = true);
      else
        Ld(i, t, t.material) && (e = true);
  }), e;
}
function Od(i) {
  "material" in i && rw(i.material), "geometry" in i && i.geometry.dispose();
}
function rw(i) {
  lc(i).forEach((r) => {
    r instanceof no || r.dispose();
  });
}
var ow = new Raycaster();
var nw = new Matrix4();
var iw = new Ray();
function _d(i, r, e) {
  let t = i.cloner;
  if (t)
    for (let o of t.children) {
      let n = nw.copy(o.matrixWorld).invert(), s = iw.copy(r.ray).applyMatrix4(n), a = i.matrixWorld;
      s.applyMatrix4(a);
      let l = ow;
      l.set(s.origin, s.direction), l.near = r.near, l.far = r.far, l.intersectObject(i, false).length > 0 && e.push({ object: i });
    }
}
var Ke = class extends It(Mesh) {
  constructor(e, t) {
    super(e, t);
    this.isAbstractMesh = true;
    this.isBooleanMesh = false;
    this.booleanMeshSetAddress = -1;
    this.booleanWasTransformed = false;
    this.booleanMatrixInvOld = new Matrix4();
    this.booleanExclude = null;
    Array.isArray(t) && e.groups.length === 0 && e.addGroup(0, e.getAttribute("position").count, 0);
  }
  get isGroup() {
    var _a2;
    return ((_a2 = this._cloner) == null ? void 0 : _a2.parameters.hideBase) === true;
  }
  get cloner() {
    return this._cloner;
  }
  set cloner(e) {
    this._cloner && this.remove(this._cloner), e && this.add(e), this._cloner = e;
  }
  updateGeometry(e) {
    let t = this.geometry, o = kl[t.userData.type], n = this.objectType === "NonParametric" ? Object.assign({}, t.userData, { geometry: t }) : t.userData, s = o.build(o.normalizeInputs(e, n)), a = t.uuid;
    this.geometry.dispose(), this.geometry = s, this.geometry.uuid = a, this.geometry.computeBoundingSphere(), io(this), t.getAttribute("randomColor") && so(this);
  }
  clone(e) {
    let t = this.objectType === "NonParametric" ? Object.assign({}, this.geometry.userData, { geometry: this.geometry.clone() }) : this.geometry.userData, o = yi(t), n = this.material;
    return new this.constructor(o, n).copy(this, e);
  }
  copy(e, t = true) {
    return super.copy(e, t), e.cloner && (this.cloner = new eo(e, e.cloner.parameters), this.add(this.cloner)), this;
  }
  setFromClonerState(e) {
    e === null ? this.cloner = void 0 : (this.cloner === void 0 && (this.cloner = new eo(this)), this.cloner.fromClonerState(e));
  }
  fromState(e, t) {
    var _a2, _b2, _c2;
    return super.fromState(e), e.type === "Mesh" && (this.setFromClonerState(e.cloner), this.castShadow = (_a2 = e.castShadow) != null ? _a2 : true, this.receiveShadow = (_b2 = e.receiveShadow) != null ? _b2 : true, this.booleanExclude = (_c2 = e.booleanExclude) != null ? _c2 : null), this;
  }
  freeBooleanPointer() {
    this.booleanMeshSetAddress !== -1 && (Rt.freeMeshSet(this.booleanMeshSetAddress), this.booleanMeshSetAddress = -1);
  }
  invalidateDownstreamBooleanData(e = false) {
    return e ? this.booleanWasTransformed = true : this.freeBooleanPointer(), Jt(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this;
  }
  invalidateUpstreamBooleanData() {
    this.freeBooleanPointer();
    for (let e of this.children)
      Qt(e) && (e.freeBooleanPointer(), Jt(e) && e.invalidateUpstreamBooleanData());
  }
};
var uw = new Vector3(0, 0, 1);
var Dd = new Vector3();
var Ed = new Vector3();
var Bd = new Matrix3();
var un = class extends Ke {
  constructor(e = st.create({}), t) {
    super(e, t);
    var _a2;
    this.recursiveSelection = false;
    this.objectType = "VectorObject";
    this.eventDispatcher = new EventDispatcher();
    this._onShapeUpdate = () => {
      this.updateGeometry({}), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox();
    };
    this.castShadow = true, this.receiveShadow = true, this.forceComputeSize = true, this.shape = e.userData.shape, (_a2 = this.shape.eventDispatcher) == null ? void 0 : _a2.addEventListener("update", this._onShapeUpdate);
  }
  fromState(e) {
    return super.fromState(e), this.shape.update(), this;
  }
  setHelperVisibility() {
  }
  updateGeometry(e) {
    if (super.updateGeometry(e), "userData" in this.geometry) {
      let t = this.geometry.userData.parameters;
      this.eventDispatcher.dispatchEvent({ type: "geometryUpdate", parameters: t });
    }
  }
  setShape(e) {
    var _a2, _b2;
    this.shape && ((_a2 = this.shape.eventDispatcher) == null ? void 0 : _a2.removeEventListener("update", this._onShapeUpdate)), this.shape = e, (_b2 = this.shape.eventDispatcher) == null ? void 0 : _b2.addEventListener("update", this._onShapeUpdate);
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), Bd.getNormalMatrix(this.matrixWorld), Dd.copy(uw).applyMatrix3(Bd).normalize(), Ed.setFromMatrixPosition(this.matrixWorld), this.shape.plane.setFromNormalAndCoplanarPoint(Dd, Ed);
  }
  clone(e) {
    let t = this.shape.clone(), o = this.material, n = this.geometry.userData, s = st.create(Object.assign({}, n, { shape: t })), a = new un(s, o).copy(this, e);
    return a.shape = t, t.update(), a;
  }
  raycast(e, t) {
    Ke.prototype.raycast.call(this, e, t);
  }
};
function Qs(i, r) {
  return mw(i);
}
function mw(i) {
  let r = { parameters: i, type: i.type };
  if (i.type === "VectorGeometry") {
    let t = Se.createFromState(i.shape, i.width, i.height);
    r.shape = t;
  } else
    i.type === "NonParametricGeometry" && (i.data.groups && i.data.groups.forEach((t) => {
      var _a2;
      return t.materialIndex = Math.max((_a2 = t.materialIndex) != null ? _a2 : 0, 0);
    }), r.geometry = new BufferGeometryLoader().parse(i));
  let e;
  try {
    e = yi(r);
  } catch (t) {
    console.error(t);
  }
  if (!e) {
    let t = Se.createFromState(Vo.defaultData(), 100, 100);
    r.shape = t, e = yi(r);
  }
  return e;
}
var pe;
ks.then((i) => {
  pe = i;
});
var zd = new Float32Array([10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0]);
var Vd = new Uint32Array([0, 1, 2, 3]);
var Fd = new Uint8Array([4]);
var At = class {
  static build(i, r, e, t, o) {
    var _a2, _b2;
    let n, s, a, l = (_b2 = (_a2 = i == null ? void 0 : i.phongAngle) != null ? _a2 : r == null ? void 0 : r.phongAngle) != null ? _b2 : 35;
    if (t === false && (l = -1), i.positionWASM !== void 0) {
      e && e !== 0 && (pe.free_bvh(e), pe.free_subdivision_surface(e));
      try {
        n = At.allocate(i, o);
      } catch (c) {
        console.error(c, i), n = At.allocate({ positionWASM: zd, indexWASM: Vd, verticesPerFaceWASM: Fd }, o);
      }
      pe.set_destination_refinement_level(n, 0), s = At.buildLevel(n, true, l);
    } else
      n = e, i.phongAngle !== void 0 && (s = At.buildLevel(n, true, l));
    return i.subdivisions !== void 0 && (pe.set_destination_refinement_level(n, i.subdivisions), i.subdivisions > 0 ? a = At.buildLevel(n, false, l) : a = null), { subdivPointer: n, originalGeometry: s, subdividedGeometry: a };
  }
  static primitiveToQuads(i, r) {
    i.widthSegments > 16 && (i.widthSegments = 16), i.heightSegments > 16 && (i.heightSegments = 16), i.depthSegments > 16 && (i.depthSegments = 16), i.radialSegments > 16 && (i.radialSegments = 16), i.type === "DodecahedronGeometry" && (i.detail = 0);
    let e = i.shape !== void 0 ? r.geometry : Qs(i), t, o, n, s;
    return { positions: t, triIndices: s } = Kl(e.getAttribute("position"), e.getIndex()), { indices: o, verticesPerFace: n } = Ql(t, s, e), { positions: t, indices: o, verticesPerFace: n };
  }
  static allocate(i, r) {
    var _a2;
    let e, t, o, n = [], s = [];
    i.positionWASM && i.positionWASM.length > 0 ? (e = i.positionWASM, t = i.indexWASM, o = i.verticesPerFaceWASM) : (e = zd, t = Vd, o = Fd);
    let a = e.length, l = t.length, c = o.length, u = e.length + n.length + s.length, m = t.length + o.length, p = u * Float32Array.BYTES_PER_ELEMENT + m * Uint32Array.BYTES_PER_ELEMENT, d = u * Float32Array.BYTES_PER_ELEMENT, f = m * Uint32Array.BYTES_PER_ELEMENT, g = pe._malloc(p), x = new Float32Array(pe.HEAPF32.buffer, g, u), y = new Uint32Array(pe.HEAPU32.buffer, g + d, m);
    x.set(e, 0), x.set(n, e.length), x.set(s, e.length + n.length), y.set(t, 0), y.set(o, t.length);
    let v;
    ((_a2 = i == null ? void 0 : i.scaleBaked) == null ? void 0 : _a2.some((S) => S !== 1)) && (v = new Matrix4().makeScale(...i.scaleBaked)), r && (v ? v.premultiply(r) : v = r);
    let P = v ? pe.alloc_subdivision_surface2(g, a, g + d, l, g + d + t.length * Uint32Array.BYTES_PER_ELEMENT, c, v.elements) : pe.alloc_subdivision_surface(g, a, g + d, l, g + d + t.length * Uint32Array.BYTES_PER_ELEMENT, c);
    return pe._free(g), P;
  }
  static buildLevel(i, r, e, t, o) {
    let n = o ? pe.get_mesh_data2(i, r ? pe.Level.CONTROL : pe.Level.REFINED, e, o.elements) : pe.get_mesh_data(i, r ? pe.Level.CONTROL : pe.Level.REFINED, e), s = 8, a = pe.HEAPU32.subarray(n >> 2, (n >> 2) + s), l = a.subarray(4, 4 + 4), c = 0, u = pe.HEAPU32[a[c] >> 2], m = pe.HEAPF32.subarray(u >> 2, (u >> 2) + l[c]);
    c++;
    let p = pe.HEAPU32[a[c] >> 2], d = pe.HEAPF32.subarray(p >> 2, (p >> 2) + l[c]);
    c++;
    let f = pe.HEAPU32[a[c] >> 2], g = pe.HEAPU32.subarray(f >> 2, (f >> 2) + l[c]);
    c++;
    let x = pe.HEAPU32[a[c] >> 2], y = pe.HEAPU32.subarray(x >> 2, (x >> 2) + l[c]);
    if (c++, t === void 0) {
      let v = new BufferGeometry();
      if (v.setIndex(new Uint32BufferAttribute(y, 1)), v.setAttribute("position", new Float32BufferAttribute(m, 3)), v.setAttribute("normal", new Float32BufferAttribute(d, 3)), r) {
        v.setAttribute("faceMap", new Uint32BufferAttribute(g, 1));
        let P = new Float32Array(d.length / 3 * 4).fill(0);
        v.setAttribute("color", new BufferAttribute(P, 4));
      }
      return pe.free_mesh_data(n), v.userData.type = "SubdivGeometry", v;
    }
    t.getAttribute("position").copyArray(m), t.getAttribute("normal").copyArray(d), t.attributes.position.needsUpdate = true, t.attributes.normal.needsUpdate = true, pe.free_mesh_data(n);
  }
  static buildControlCageWireframe(i, r, e) {
    let t = pe.get_wireframe_data_for_base_level(i), o = 4, n = pe.HEAPU32.subarray(t >> 2, (t >> 2) + o), s = n.subarray(2, 2 + 2), a = 0, l = pe.HEAPU32[n[a] >> 2], c = pe.HEAPF32.subarray(l >> 2, (l >> 2) + s[a]);
    a++;
    let u = pe.HEAPU32[n[a] >> 2], m = pe.HEAPU32.subarray(u >> 2, (u >> 2) + s[a]);
    if (r === void 0) {
      let p = new BufferGeometry();
      p.setAttribute("position", new Float32BufferAttribute(c, 3));
      let d = new Float32Array(c.length);
      for (let f = 0, g = c.length; f < g; )
        d[f++] = e.r, d[f++] = e.g, d[f++] = e.b;
      return p.setAttribute("color", new BufferAttribute(d, 3)), p.setIndex(new Uint32BufferAttribute(m, 1)), pe.free_wireframe_data_for_base_level(t), p;
    }
    r.getAttribute("position").copyArray(c), r.attributes.position.needsUpdate = true, pe.free_wireframe_data_for_base_level(t);
  }
  static updateCollabMesh(i, r, e) {
    r || pe.set_destination_refinement_level(i, 1);
    let t = e ? pe.get_topological_data2(i, r ? pe.Level.CONTROL : pe.Level.REFINED, e.elements) : pe.get_topological_data(i, r ? pe.Level.CONTROL : pe.Level.REFINED), o = 6, n = pe.HEAPU32.subarray(t >> 2, (t >> 2) + o), s = n.subarray(3, 3 + 3), a = 0, l = pe.HEAPU32[n[a] >> 2], c = new Float32Array(pe.HEAPF32.subarray(l >> 2, (l >> 2) + s[a]));
    a++;
    let u = pe.HEAPU32[n[a] >> 2], m = new Uint32Array(pe.HEAPU32.subarray(u >> 2, (u >> 2) + s[a]));
    a++;
    let p = pe.HEAPU32[n[a] >> 2], d = new Uint8Array(pe.HEAPU32.subarray(p >> 2, (p >> 2) + s[a]));
    return pe.free_topological_data(t), { positions: c, indices: m, verticesPerFace: d };
  }
};
var Ud = ["getX", "getY", "getZ"];
function Kl(i, r) {
  let e = {}, t = r ? r.count : i.count, o = 0, n = [], s = [], a = 1e4;
  for (let c = 0; c < t; c++) {
    let u = r ? r.getX(c) : c, m = "";
    for (let p = 0; p < 3; p++)
      m += `${~~(i[Ud[p]](u) * a)},`;
    if (m in e)
      n.push(e[m]);
    else {
      for (let p = 0; p < 3; p++)
        s.push(i[Ud[p]](u));
      e[m] = o, n.push(o), o++;
    }
  }
  let l = [];
  for (let c = 0; c < n.length; c += 3)
    n[c] === n[c + 1] || n[c] === n[c + 2] || n[c + 1] === n[c + 2] || l.push(n[c], n[c + 1], n[c + 2]);
  return { positions: s, triIndices: l };
}
var Js = new Vector3();
var $l = new Vector3();
var Xl = new Vector3();
var Yl = new Vector3();
function Ql(i, r, e) {
  var _a2;
  let t = [], o = [];
  if (e.userData.shape !== void 0 && e.userData.parameters.depth === 0 && e.userData.shape.shapeHoles.length === 0) {
    let n = e.userData.shape.extractShapePointsToFlatArray([]), s = 0;
    for (let l = 0; l < n.length; l += 2)
      s += (n[l] - n[(l === 0 ? n.length : l) - 2]) * (n[l + 1] + n[(l === 0 ? n.length : l) - 1]);
    i.length = 0;
    let a = 0;
    if (s < 0)
      for (let l = 0; l < n.length; l += 2)
        i.push(n[l], n[l + 1], 0), t.push(a++);
    else
      for (let l = n.length - 2; l >= 0; l -= 2)
        i.push(n[l], n[l + 1], 0), t.push(a++);
    return o.push(a), { indices: t, verticesPerFace: o };
  }
  for (let n = 0, s = (_a2 = e.capStartIndex) != null ? _a2 : r.length; n < s; )
    if (r[n + 1] === r[n + 3] && r[n + 2] === r[n + 5] || r[n + 0] === r[n + 3] && r[n + 2] === r[n + 4]) {
      Js.set(i[r[n] * 3], i[r[n] * 3 + 1], i[r[n] * 3 + 2]), $l.set(i[r[n + 1] * 3], i[r[n + 1] * 3 + 1], i[r[n + 1] * 3 + 2]), Xl.set(i[r[n + 4] * 3], i[r[n + 4] * 3 + 1], i[r[n + 4] * 3 + 2]), Yl.set(i[r[n + 5] * 3], i[r[n + 5] * 3 + 1], i[r[n + 5] * 3 + 2]), $l.sub(Js).normalize(), Xl.sub(Js).normalize(), Yl.sub(Js).normalize();
      let a = $l.cross(Xl).dot(Yl);
      Math.abs(a) > 5e-3 ? (t.push(r[n], r[n + 1], r[n + 2]), o.push(3), n += 3) : (t.push(r[n], r[n + 1], r[n + 4], r[n + 5]), o.push(4), n += 6);
    } else
      t.push(r[n], r[n + 1], r[n + 2]), o.push(3), n += 3;
  if (e.capStartIndex !== void 0) {
    let n = [], s = [], a = 0;
    for (let l = 0, c = 0; l < i.length; l += 3, c++)
      i[l + 2] === 0 && (n.push(c), a++), i[l + 2] === e.userData.parameters.depth && s.push(c);
    if (e.userData.parameters.extrudeBevelSize === 0) {
      let l = s[0];
      s[0] = s[1], s[1] = l;
    }
    n.reverse(), t.push(...n, ...s), o.push(a, a);
  }
  return { indices: t, verticesPerFace: o };
}
var Rt = {};
Hf(Rt, { calcBoolean: () => xw, calcBooleanTopological: () => yw, freeMeshSet: () => Sw, getMeshSet: () => vw, transformMeshSet: () => bw });
var fw;
var jd = new Promise((i) => {
  fw = i;
});
var ge;
var pn;
jd.then((i) => ge = i);
function gw(i, r) {
  let e, { positions: t, triIndices: o } = Kl(i.getAttribute("position"), i.getIndex()), n;
  if (r) {
    let { indices: s, verticesPerFace: a } = Ql(t, o, i);
    n = a.length, e = [];
    for (let l = 0, c = 0; l < n; l++) {
      e.push(a[l]);
      for (let u = 0; u < a[l]; u++)
        e.push(s[c++]);
    }
  } else {
    let s = o.length;
    e = Array(s + s / 3), n = 0;
    for (let a = 0, l = 0; l < e.length; )
      e[l++] = 3, n++, e[l++] = o[a++], e[l++] = o[a++], e[l++] = o[a++];
  }
  return { positions: t, faceIndices: e, nFaces: n };
}
function Hd(i) {
  let r = i.length, e = r * Uint32Array.BYTES_PER_ELEMENT, t = r * Float32Array.BYTES_PER_ELEMENT, o = Number.isInteger(i[0]) ? e : t, n = ge._malloc(o);
  return (Number.isInteger(i[0]) ? new Uint32Array(ge.HEAPU32.buffer, n, r) : new Float32Array(ge.HEAPF32.buffer, n, r)).set(i, 0), n;
}
function Wd(i) {
  switch (i) {
    case 0:
      return ge.OP.UNION;
    case 1:
      return ge.OP.INTERSECTION;
    case 2:
      return ge.OP.A_MINUS_B;
    case 3:
      return ge.OP.B_MINUS_A;
    case 4:
      return ge.OP.SYMMETRIC_DIFFERENCE;
    case 5:
      return ge.OP.ALL;
    default:
      throw new Error("Unknown boolean operation " + i);
  }
}
function yw(i, r) {
  pn === void 0 && (pn = ge.init_csg());
  let e = Hd(i), t = ge.csg_calc_topological(pn, e, i.length, Wd(r));
  ge._free(e);
  let o = 6, n = ge.HEAPU32.subarray(t >> 2, (t >> 2) + o), s = n.subarray(3, 3 + 3), a = 0, l = ge.HEAPU32[n[a] >> 2], c = new Float32Array(ge.HEAPF32.subarray(l >> 2, (l >> 2) + s[a]));
  a++;
  let u = ge.HEAPU32[n[a] >> 2], m = new Uint32Array(ge.HEAPU32.subarray(u >> 2, (u >> 2) + s[a]));
  a++;
  let p = ge.HEAPU32[n[a] >> 2], d = new Uint8Array(ge.HEAPU32.subarray(p >> 2, (p >> 2) + s[a]));
  return ge.free_mesh_data(t), { positions: c, indices: m, verticesPerFace: d };
}
function xw(i, r, e, t) {
  pn === void 0 && (pn = ge.init_csg());
  let o = Hd(i), n = ge.csg_calc(pn, o, i.length, t, Wd(r));
  ge._free(o);
  let s = 5, a = ge.HEAPU32.subarray(n >> 2, (n >> 2) + s), l = a.subarray(2, 2 + 3), c = 0, u = ge.HEAPU32[a[c] >> 2], m = ge.HEAPF32.subarray(u >> 2, (u >> 2) + l[c]);
  c++;
  let p = ge.HEAPU32[a[c] >> 2], d = ge.HEAPF32.subarray(p >> 2, (p >> 2) + l[c]);
  c++;
  let f = l[c];
  e.setAttribute("position", new Float32BufferAttribute(m, 3)), e.setAttribute("normal", new Float32BufferAttribute(d, 3));
  let g = ge.HEAPF32.subarray((n >> 2) + 5, (n >> 2) + 5 + 6);
  return e.boundingSphere === null && (e.boundingSphere = new Sphere()), e.boundingSphere.center.set(g[0], g[1], g[2]), e.boundingSphere.radius = (g[3] ** 2 + g[4] ** 2 + g[5] ** 2) ** 0.5, e.userData.parameters = { width: g[3] * 2, height: g[4] * 2, depth: g[5] * 2 }, ge.free_mesh_data(n), f;
}
function vw(i, r) {
  if (ge === void 0)
    return -1;
  let e, t, o;
  if (r && i.userData.positions !== void 0) {
    let g = i.userData;
    o = g.verticesPerFace.length, e = g.positions, t = Array(g.verticesPerFace.reduce((x, y) => x + y, 0) + o);
    for (let x = 0, y = 0, v = 0; x < g.verticesPerFace.length; x++) {
      t[v++] = g.verticesPerFace[x];
      for (let P = 0; P < g.verticesPerFace[x]; P++)
        t[v++] = g.indices[y++];
    }
  } else
    ({ positions: e, faceIndices: t, nFaces: o } = gw(i, r));
  let n = e.length, s = t.length, a = e.length, l = t.length, c = a * Float32Array.BYTES_PER_ELEMENT + l * Uint32Array.BYTES_PER_ELEMENT, u = a * Float32Array.BYTES_PER_ELEMENT, m = l * Uint32Array.BYTES_PER_ELEMENT, p = ge._malloc(c), d = new Float32Array(ge.HEAPF32.buffer, p, a), f = new Uint32Array(ge.HEAPU32.buffer, p + u, l);
  return d.set(e, 0), f.set(t, 0), ge.get_csg_mesh(p, n, p + u, s, o);
}
function bw(i, r) {
  ge.transform_csg_mesh(i, r.elements);
}
function Sw(i) {
  ge.free_csg_mesh(i);
}
var kl = { ConeGeometry: Zp, CubeGeometry: em, CylinderGeometry: Jp, DodecahedronGeometry: tm, EllipseGeometry: Pm, HelixGeometry: Dm, IcosahedronGeometry: Em, LatheGeometry: Bm, NonParametricGeometry: km, PolygonGeometry: Hm, PyramidGeometry: Wm, RectangleGeometry: qm, SphereGeometry: $m, PlaneGeometry: Xm, BackdropGeometry: Ym, StarGeometry: Km, TextFrameGeometry: js, TorusGeometry: Qm, TorusKnotGeometry: Jm, TriangleGeometry: Zm, VectorGeometry: st };
var yi = (i) => kl[i.type].create(i);
var $d = new Matrix4();
var ea = class extends Ke {
  constructor(e = new BufferGeometry(), t) {
    super(e, t);
    this.booleanOp = 2;
    this.phongAngle = 35;
    this.meshSetAddresses = [];
    this.needsTransformForDownstream = false;
    this.isBooleanMesh = true, this.castShadow = true, this.receiveShadow = true, this.geometry.userData.parameters = { width: 0, height: 0, depth: 0 }, this.onAfterRender = this.recomputeBoolean.bind(this);
  }
  reInit() {
    this.isBooleanMesh = true, this.meshSetAddresses = [], this.needsTransformForDownstream = false, this.geometry.userData.parameters = { width: 0, height: 0, depth: 0 }, this.onAfterRender = this.recomputeBoolean.bind(this);
  }
  recomputeBoolean(e) {
    var _a2;
    if (this.booleanMeshSetAddress !== -1)
      return;
    for (let o = 0; o < this.children.length; o++) {
      let n = this.children[o];
      Jt(n) && n.recomputeBoolean(e === true);
    }
    this.meshSetAddresses = [];
    for (let o = 0; o < this.children.length; o++) {
      let n = this.children[o];
      if (ld(n) && n.booleanExclude === false && ((_a2 = n.geometry.attributes.position) == null ? void 0 : _a2.count) > 0 && n.geometry.drawRange.count > 0) {
        if (n.booleanMeshSetAddress === -1) {
          if (n.booleanMeshSetAddress = Rt.getMeshSet(n.geometry, e === true), n.booleanMeshSetAddress === -1)
            return;
          Rt.transformMeshSet(n.booleanMeshSetAddress, n.matrix), n.booleanMatrixInvOld.copy(n.matrix).invert(), n.booleanWasTransformed = false;
        } else
          Jt(n) && n.needsTransformForDownstream === true ? (Rt.transformMeshSet(n.booleanMeshSetAddress, n.matrix), n.needsTransformForDownstream = false) : n.booleanWasTransformed === true && ($d.multiplyMatrices(n.matrix, n.booleanMatrixInvOld), Rt.transformMeshSet(n.booleanMeshSetAddress, $d), n.booleanMatrixInvOld.copy(n.matrix).invert(), n.booleanWasTransformed = false);
        this.meshSetAddresses.push(n.booleanMeshSetAddress);
      }
    }
    if (this.meshSetAddresses.length === 0) {
      this.geometry.setDrawRange(0, 0);
      return;
    }
    if (e === true)
      return Rt.calcBooleanTopological(this.meshSetAddresses, this.booleanOp);
    let t = this.geometry;
    t.dispose(), this.geometry = new BufferGeometry(), this.geometry.userData = t.userData, this.geometry.boundingSphere = t.boundingSphere;
    try {
      this.booleanMeshSetAddress = Rt.calcBoolean(this.meshSetAddresses, this.booleanOp, this.geometry, this.phongAngle);
    } catch (o) {
      this.booleanMeshSetAddress = 0, console.error(o);
    }
    this.booleanMatrixInvOld.copy(this.matrix).invert(), this.needsTransformForDownstream = true, io(this), so(this);
  }
  updateGeometry(e) {
    let t = e.parameters;
    t.operation !== void 0 && (this.booleanOp = t.operation), t.phongAngle !== void 0 && (this.phongAngle = t.phongAngle), this.invalidateDownstreamBooleanData().recomputeBoolean();
  }
};
var cr = (i) => {
  var r;
  return r = class extends i {
    constructor() {
      super(...arguments);
      this.isObjectHelper = true;
    }
  }, r.geometryHelper = new BoxGeometry(30, 30, 30), r;
};
var ta = new Ray();
var Jl = new Sphere();
var Xd = new Matrix4();
var ur = (i, r, e, t, o = false) => {
  let n = r, s = i.matrixWorld;
  if (n.boundingSphere === null && n.computeBoundingSphere(), Jl.copy(n.boundingSphere), Jl.applyMatrix4(s), e.ray.intersectsSphere(Jl) === false || (Xd.copy(s).invert(), ta.copy(e.ray).applyMatrix4(Xd), n.boundingBox !== null && ta.intersectsBox(n.boundingBox) === false))
    return;
  let a, l, c, u, m = n.index, p = n.attributes.position, d = n.drawRange, f, g;
  if (o === false) {
    let y = Math.max(0, d.start), v = Math.min(m.count, d.start + d.count);
    for (f = y, g = v; f < g; f += 3)
      if (l = m.getX(f), c = m.getX(f + 1), u = m.getX(f + 2), a = x(i, e, ta, p, l, c, u), a) {
        a.faceIndex = Math.floor(f / 3), t.push(a);
        return;
      }
  } else {
    let v = n.attributes.position, P = new Vector3(), S = new Vector3(), b = new Vector3(), E = new Vector3(), w = 2, _ = 1 / ((i.scale.x + i.scale.y + i.scale.z) / 3), N = _ * _, I = Math.max(0, d.start), L = Math.min(v.count, d.start + d.count);
    for (let A = I, k = L - 1; A < k; A += w) {
      if (P.fromBufferAttribute(v, A), S.fromBufferAttribute(v, A + 1), ta.distanceSqToSegment(P, S, E, b) > N)
        continue;
      E.applyMatrix4(i.matrixWorld);
      let oe = e.ray.origin.distanceTo(E);
      oe < e.near || oe > e.far || t.push({ distance: oe, point: b.clone().applyMatrix4(i.matrixWorld), object: i });
    }
  }
  function x(y, v, P, S, b, E, w) {
    let h = new Vector3(), _ = new Vector3(), N = new Vector3(), I = new Vector3(), L = new Vector3();
    if (h.fromBufferAttribute(S, b), _.fromBufferAttribute(S, E), N.fromBufferAttribute(S, w), P.intersectTriangle(h, _, N, false, I) === null)
      return null;
    L.copy(I), L.applyMatrix4(y.matrixWorld);
    let k = v.ray.origin.distanceTo(L);
    return k < v.near || k > v.far ? null : { faceIndex: 1, distance: k, point: L.clone(), object: y };
  }
};
var ra = new Vector3();
var Mt = new Camera();
var ec = class extends LineSegments {
  constructor(e) {
    let t = new BufferGeometry(), o = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false }), n = [], s = [], a = {}, l = new Color(15711266), c = new Color(15711266), u = new Color(2857471);
    m("n1", "n2", l), m("n2", "n4", l), m("n4", "n3", l), m("n3", "n1", l), m("f1", "f2", l), m("f2", "f4", l), m("f4", "f3", l), m("f3", "f1", l), m("n1", "f1", l), m("n2", "f2", l), m("n3", "f3", l), m("n4", "f4", l), m("p", "n1", c), m("p", "n2", c), m("p", "n3", c), m("p", "n4", c), m("u1", "u2", u), m("u2", "u3", u), m("u3", "u1", u);
    function m(d, f, g) {
      p(d, g), p(f, g);
    }
    function p(d, f) {
      n.push(0, 0, 0), s.push(f.r, f.g, f.b), a[d] === void 0 && (a[d] = []), a[d].push(n.length / 3 - 1);
    }
    t.setAttribute("position", new Float32BufferAttribute(n, 3)), t.setAttribute("color", new Float32BufferAttribute(s, 3));
    super(t, o);
    this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = a, this.update();
  }
  update() {
    let e = this.geometry, t = this.pointMap, o = true;
    Mt.projectionMatrixInverse.elements = [0.5112609807824982, -0, -0, -0, -0, 0.41421356237309503, -0, -0, -0, -0, -0, -0.099999, -0, -0, -1.0000000000000002, 0.100001];
    let n = 1, s = 1, a = o ? 0.8 : 1e-4;
    zt("n1", t, e, Mt, -n, -s, a), zt("n2", t, e, Mt, n, -s, a), zt("n3", t, e, Mt, -n, s, a), zt("n4", t, e, Mt, n, s, a);
    let l = a;
    zt("f1", t, e, Mt, -n, -s, l), zt("f2", t, e, Mt, n, -s, l), zt("f3", t, e, Mt, -n, s, l), zt("f4", t, e, Mt, n, s, l);
    let c = l, u = 0.5;
    zt("u1", t, e, Mt, n * 0.7 * u, s * 1.1, c), zt("u2", t, e, Mt, -n * 0.7 * u, s * 1.1, c), zt("u3", t, e, Mt, 0, s * (1.1 + 0.9 * u), c), e.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
function zt(i, r, e, t, o, n, s) {
  ra.set(o, n, s).unproject(t);
  let a = r[i];
  if (a !== void 0) {
    let l = e.getAttribute("position");
    for (let c = 0, u = a.length; c < u; c++)
      l.setXYZ(a[c], ra.x, ra.y, ra.z);
  }
}
var oa = class extends cr(ec) {
  constructor(e) {
    super(e);
    this.object = e;
    this.object = e, this.name = `CombinedCameraHelper: ${e.uuid}`;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.updateTarget();
  }
  updateTarget() {
    let e = this.object.getTarget();
    this.updateWorldMatrix(true, false), this.worldToLocal(e);
  }
  raycast(e, t) {
    ur(this.object, this.geometry, e, t, true);
  }
};
var mn = class extends cr(DirectionalLightHelper) {
  constructor(e, t = 15, o = 10066329) {
    super(e, t, o);
    this.object = e;
    this.added = false;
    this.name = `DirectionalLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    ur(this.object, mn.geometryHelper, e, t);
  }
};
var dn = class extends cr(AxesHelper) {
  constructor(e, t = 15) {
    super(t);
    this.object = e;
    this.object.updateMatrixWorld(), this.name = `EmptyObjectHelper: ${e.uuid}`, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
  }
  raycast(e, t) {
    ur(this.object, dn.geometryHelper, e, t);
  }
  update() {
  }
};
var fn = class extends cr(PointLightHelper) {
  constructor(e, t = 15, o = 6710886) {
    super(e, t, o);
    this.object = e;
    this.name = `PointLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    ur(this.object, fn.geometryHelper, e, t);
  }
};
var na = class extends cr(SpotLightHelper) {
  constructor(e, t = 6710886) {
    super(e, t);
    this.object = e;
    this.name = `SpotLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    ur(this.object, na.geometryHelper, e, t);
  }
  update() {
    if (this.object !== void 0) {
      let e = na._vector, t = this.object.distance ? this.object.distance : 1e3, o = t * Math.tan(this.object.angle);
      this.cone.scale.set(o, o, t), e.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(e);
      let n = this.color !== void 0 ? this.color : this.light.color;
      if (this.cone.material instanceof Array)
        for (let s = 0, a = this.cone.material.length; s < a; s++)
          this.cone.material[s].color.set(n);
      else
        this.cone.material.color.set(n);
    }
  }
};
var xi = na;
xi._vector = new Vector3();
var pr = (i, r) => class extends i {
  constructor() {
    super(...arguments);
    this.objectHelper = new r(this);
    this.enableHelper = false;
  }
  set visibility(o) {
    this.visible = o, this.setHelperVisibility(o), this.setHelperChildrenVisibility(o);
  }
  get visibility() {
    return this.visible;
  }
  get geometryHelper() {
    return r.geometryHelper;
  }
  setHelperVisibility(o) {
    this.objectHelper.visible = o;
  }
  setHelperChildrenVisibility(o) {
    for (let n of this.children)
      Dt(n) && n.traverseEntity((s) => {
        wr(s) && s.visible && (s.objectHelper.visible = o);
      });
  }
  raycast(o, n) {
    this.objectHelper.raycast(o, n);
  }
  fromLightState(o, n) {
    if (this.objectType === "LightDirectional" || this.objectType === "LightPoint" || this.objectType === "LightSpot") {
      let s = this;
      o.color !== void 0 && (s.color = ze(o.color, n)), o.intensity !== void 0 && (s.intensity = o.intensity), o.depth !== void 0 && (s.shadow.camera.far = o.depth, s.shadow.needsUpdate = true), o.shadows !== void 0 && (this.castShadow = o.shadows), o.helper !== void 0 && (this.enableHelper = o.helper, s.gizmos.shadowmap.visible = o.helper);
    }
    return this;
  }
};
var hn = new Vector3();
var tc = new Vector3();
var Cr = class extends pr(It(Camera), oa) {
  constructor(e = window.innerWidth, t = window.innerHeight, o = 45, n, s = 1e5) {
    super();
    this.objectType = "CombinedCamera";
    this._cameraType = "OrthographicCamera";
    this.targetOffset = Yr.DefaultTargetOffset;
    this.isUpVectorFlipped = false;
    this.angleOffsetFromUp = 0;
    this.width = e, this.height = t, this.orthoCamera = new OrthographicCamera(e * -0.5, e * 0.5, t * 0.5, t * -0.5, n != null ? n : -5e4, s), this.perspCamera = new PerspectiveCamera(o, e / t, n != null ? n : 50, s), this.left = this.orthoCamera.left, this.right = this.orthoCamera.right, this.top = this.orthoCamera.top, this.bottom = this.orthoCamera.bottom, this.far = this.orthoCamera.far, this.view = this.orthoCamera.view, this.aspect = this.perspCamera.aspect, this.fov = this.perspCamera.fov, this.focus = this.perspCamera.focus, this.filmGauge = this.perspCamera.filmGauge, this.filmOffset = this.perspCamera.filmOffset, this.toOrthographic(true);
  }
  static createFromState(e, t) {
    let o = new Cr().fromState(t);
    return o.enableHelper = true, o.objectHelper.update(), o.uuid = e, o;
  }
  get isPerspectiveCamera() {
    return this.cameraType === "PerspectiveCamera";
  }
  get isOrthographicCamera() {
    return !this.isPerspectiveCamera;
  }
  get cameraType() {
    return this._cameraType;
  }
  setNear(e, t) {
    e === "PerspectiveCamera" ? this.perspCamera.near = t : this.orthoCamera.near = t;
  }
  setZoom(e, t) {
    t >= 0 && (e === "PerspectiveCamera" ? this.perspCamera.zoom = t : this.orthoCamera.zoom = t);
  }
  set cameraType(e) {
    e === "PerspectiveCamera" ? this.toPerspective() : e === "OrthographicCamera" && this.toOrthographic();
  }
  get near() {
    return this._cameraType === "PerspectiveCamera" ? this.perspCamera.near : this.orthoCamera.near;
  }
  set near(e) {
    this._cameraType === "PerspectiveCamera" ? this.perspCamera.near = e : this.orthoCamera.near = e;
  }
  get zoom() {
    return this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom : this.orthoCamera.zoom;
  }
  set zoom(e) {
    e >= 0 && (this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom = e : this.orthoCamera.zoom = e);
  }
  lookAt(e) {
    super.lookAt(e), this.getWorldPosition(hn), this.targetOffset = hn.distanceTo(e);
  }
  getTarget(e = new Vector3()) {
    return this.getWorldDirection(tc), this.getWorldPosition(hn), tc.multiplyScalar(this.targetOffset), e.copy(hn).add(tc), e;
  }
  getDistanceToTarget() {
    let e = this.getTarget();
    return this.getWorldPosition(hn), hn.distanceTo(e);
  }
  updateUp() {
    let e = this.getWorldQuaternion(new Quaternion()), t = new Vector3(0, 0, 1).applyQuaternion(e), o = new Vector3().copy(Object3D.DefaultUp);
    this.isUpVectorFlipped && o.negate(), o.applyQuaternion(e);
    let n = new Vector3().copy(Object3D.DefaultUp).projectOnPlane(t), s = new Vector3().crossVectors(n, o).dot(t) >= 0 ? 1 : -1;
    this.angleOffsetFromUp = n.angleTo(o) * s;
  }
  getViewFrontToObject(e) {
    let t = e.getWorldPosition(new Vector3()), n = e.getWorldDirection(new Vector3()).multiplyScalar(this.targetOffset);
    return { position: t.clone().add(n), target: t };
  }
  getViewToObject(e) {
    let t = e.getWorldPosition(new Vector3()), n = this.getWorldDirection(new Vector3()).multiplyScalar(this.targetOffset);
    return { position: t.clone().sub(n), target: t };
  }
  setViewplaneSize(e, t) {
    this.left = -e * 0.5, this.right = e * 0.5, this.top = t * 0.5, this.bottom = -t * 0.5, this.aspect = e / t, this.updateProjectionMatrix();
  }
  toOrthographic(e) {
    this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", (this.enableHelper === true || e === true) && this.objectHelper.update();
  }
  toPerspective(e) {
    this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", (this.enableHelper === true || e === true) && this.objectHelper.update();
  }
  setFocalLength(e) {
    this.perspCamera.setFocalLength(e), this.toPerspective();
  }
  getFocalLength() {
    return this.perspCamera.getFocalLength();
  }
  getEffectiveFOV() {
    return this.perspCamera.getEffectiveFOV();
  }
  getFilmWidth() {
    return this.perspCamera.getFilmWidth();
  }
  getFilmHeight() {
    return this.perspCamera.getFilmHeight();
  }
  setViewOffset(e, t, o, n, s, a) {
    this._cameraType === "PerspectiveCamera" ? this.perspCamera.setViewOffset(e, t, o, n, s, a) : this.orthoCamera.setViewOffset(e, t, o, n, s, a);
  }
  clearViewOffset() {
    this._cameraType === "PerspectiveCamera" ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
  }
  updateProjectionMatrix(e) {
    this._cameraType === "PerspectiveCamera" ? this.toPerspective(e) : this._cameraType === "OrthographicCamera" && this.toOrthographic(e);
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  copy(e, t) {
    return super.copy(e, t), this.orthoCamera.copy(e.orthoCamera), this.perspCamera.copy(e.perspCamera), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.far = e.far, this.view = e.view === null ? null : Object.assign({}, e.view), this._cameraType = e._cameraType, this.aspect = e.aspect, this.fov = e.fov, this.focus = e.focus, this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this.targetOffset = e.targetOffset, this.updateProjectionMatrix(), this;
  }
  toCameraState(e = []) {
    let t = { type: this.cameraType, far: this.far, orthographic: { near: this.orthoCamera.near, zoom: this.orthoCamera.zoom }, perspective: { near: this.perspCamera.near, fov: this.perspCamera.fov, zoom: this.perspCamera.zoom }, up: this.up.toArray(), targetOffset: this.targetOffset, isUpVectorFlipped: this.isUpVectorFlipped };
    return _o(t, e);
  }
  fromCameraState(e) {
    let { orthographic: t, perspective: o } = e;
    return e.type !== void 0 && (this.cameraType = e.type), e.far !== void 0 && (this.far = e.far), t !== void 0 && (t.near !== void 0 && (this.orthoCamera.near = t.near), t.zoom !== void 0 && (this.orthoCamera.zoom = t.zoom)), o !== void 0 && (o.near !== void 0 && (this.perspCamera.near = o.near), o.fov !== void 0 && (this.perspCamera.fov = o.fov), o.zoom !== void 0 && (this.perspCamera.zoom = o.zoom)), e.up !== void 0 && this.up.fromArray(e.up), e.targetOffset !== void 0 && (this.targetOffset = e.targetOffset), e.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = e.isUpVectorFlipped), this.updateProjectionMatrix(), this;
  }
  toState(e) {
    return __spreadProps(__spreadValues(__spreadValues({}, super.toState(e)), this.toCameraState(e)), { type: this.cameraType });
  }
  fromState(e) {
    return super.fromState(e), this.fromCameraState(e), this;
  }
};
var ao = class extends pr(It(Group), dn) {
  constructor() {
    super(...arguments);
    this.objectType = "EmptyObject";
  }
  static createFromState(e, t) {
    let o = new ao().fromState(t);
    return o.uuid = e, o.enableHelper = true, o.objectHelper.update(), o;
  }
};
var gn = class extends pr(It(DirectionalLight), mn) {
  constructor(...e) {
    super(...e);
    this.objectType = "LightDirectional";
    this._gizmos = {};
    this.castShadow = true, this.shadow.mapSize.width = 2048, this.shadow.mapSize.height = 2048, this.shadow.normalBias = 1;
    let o = this.shadow.camera;
    o.top = 1250, o.bottom = -1250, o.right = 1250, o.left = -1250, o.near = -1e4, o.far = 2500;
    let n = new CameraHelper(this.shadow.camera);
    n.visible = false, this._gizmos.shadowmap = n, this.update();
  }
  static createFromState(e, t, o) {
    let n = new gn().fromState(t, o);
    return n.uuid = e, n;
  }
  get gizmos() {
    return this._gizmos;
  }
  showGizmos() {
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof CameraHelper && (t.visible = true);
    }
  }
  hideGizmos() {
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof CameraHelper && (t.visible = false);
    }
  }
  update() {
    this.shadow.camera.updateProjectionMatrix();
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof CameraHelper && t.update();
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.enableHelper === true && this.objectHelper.visible === true && this.objectHelper.update();
  }
  fromDirectionalLightState(e, t) {
    let o = e.depth !== void 0 && e.depth !== this.shadow.camera.far || e.size !== void 0 && e.size / 2 !== this.shadow.camera.right;
    return super.fromLightState(e, t), e.size !== void 0 && od(this, e.size), e.shadowRadius !== void 0 && (this.shadow.radius = e.shadowRadius), e.shadowResolution !== void 0 && (this.shadow.mapSize.set(e.shadowResolution, e.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), o && this.update(), this;
  }
  fromState(e, t) {
    return super.fromState(e), this.fromDirectionalLightState(e, t), this;
  }
};
var yn = class extends pr(It(PointLight), fn) {
  constructor(...e) {
    super(...e);
    this.objectType = "LightPoint";
    this._gizmos = {};
    this.castShadow = true, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1;
    let o = this.shadow.camera;
    o.fov = 90, o.aspect = 1, o.near = 100, o.far = 2500;
    let n = new Vector3(-o.far + this.position.x, -o.far + this.position.y, -o.far + this.position.z), s = new Vector3(o.far + this.position.x, o.far + this.position.y, o.far + this.position.z), a = new Box3(n, s), l = new Box3Helper(a, new Color(16755200));
    l.visible = false, this._gizmos.shadowmap = l, this.update();
  }
  static createFromState(e, t, o) {
    let n = new yn().fromState(t, o);
    return n.uuid = e, n;
  }
  get gizmos() {
    return this._gizmos;
  }
  showGizmos() {
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof Box3Helper && (t.visible = true);
    }
  }
  hideGizmos() {
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof Box3Helper && (t.visible = false);
    }
  }
  update() {
    if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this._gizmos))
      for (let e in this._gizmos) {
        let t = this._gizmos[e];
        if (t instanceof Box3Helper) {
          let o = this.shadow.camera, n = new Vector3(-o.far + this.position.x, -o.far + this.position.y, -o.far + this.position.z), s = new Vector3(o.far + this.position.x, o.far + this.position.y, o.far + this.position.z);
          t.box.set(n, s), t.updateMatrixWorld(true);
        }
      }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.enableHelper === true && this.objectHelper.visible === true && this.objectHelper.update();
  }
  fromPointLightState(e, t) {
    return super.fromLightState(e, t), e.distance !== void 0 && (this.distance = e.distance), e.decay !== void 0 && (this.decay = e.decay), e.shadowRadius !== void 0 && (this.shadow.radius = e.shadowRadius), e.shadowResolution !== void 0 && (this.shadow.mapSize.set(e.shadowResolution, e.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), this;
  }
  fromState(e, t) {
    return super.fromState(e), this.fromPointLightState(e, t), this;
  }
};
var Qd = new Vector3();
var Jd = new Vector3();
var Zd = new Quaternion();
var xn = class extends pr(It(SpotLight), xi) {
  constructor(...e) {
    super(...e);
    this.objectType = "LightSpot";
    this._gizmos = {};
    this.castShadow = true, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1;
    let o = this.shadow.camera;
    o.fov = MathUtils.RAD2DEG * 2 * this.angle, o.aspect = 1, o.near = 100, o.far = 2500;
    let n = new CameraHelper(this.shadow.camera);
    n.visible = false, this._gizmos.shadowmap = n, this.update();
  }
  static createFromState(e, t, o) {
    let n = new xn().fromState(t, o);
    return n.uuid = e, n;
  }
  get gizmos() {
    return this._gizmos;
  }
  showGizmos() {
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof CameraHelper && (t.visible = true);
    }
  }
  hideGizmos() {
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof CameraHelper && (t.visible = false);
    }
  }
  update() {
    this.shadow.camera.updateProjectionMatrix();
    for (let e in this._gizmos) {
      let t = this._gizmos[e];
      t instanceof CameraHelper && t.update();
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), Jd.setFromMatrixPosition(this.matrixWorld), Zd.setFromRotationMatrix(this.matrixWorld), Qd.copy(this.up).applyQuaternion(Zd).negate().multiplyScalar(this.distance), this.target.position.copy(Jd).add(Qd), this.target.updateMatrixWorld(), this.enableHelper === true && this.objectHelper.visible === true && this.objectHelper.update();
  }
  fromSpotLightState(e, t) {
    return super.fromLightState(e, t), e.distance !== void 0 && (this.distance = e.distance), e.decay !== void 0 && (this.decay = e.decay), e.angle !== void 0 && (this.angle = e.angle), e.penumbra !== void 0 && (this.penumbra = e.penumbra), e.shadowRadius !== void 0 && (this.shadow.radius = e.shadowRadius), e.shadowResolution !== void 0 && (this.shadow.mapSize.set(e.shadowResolution, e.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), this;
  }
  fromState(e, t) {
    return super.fromState(e), this.fromSpotLightState(e, t), this;
  }
};
var tf = (i) => i.tagName === "VIDEO";
var vn = class {
  static resize(r, e, t) {
    let o = r / e, n;
    if (!t.image)
      return;
    let s = t.image;
    tf(s) ? n = s.videoWidth / s.videoHeight : n = s.width / s.height, o > n && (t.imageType == "WEBCAM" ? t.repeat.set(-1, 1 * n / o) : t.repeat.set(1, 1 * n / o)), o < n && (t.imageType == "WEBCAM" ? t.repeat.set(1 * o / n * -1, 1) : t.repeat.set(1 * o / n, 1)), o == n && (t.imageType == "WEBCAM" ? t.repeat.set(-1, 1) : t.repeat.set(1, 1));
  }
  static resizeTextureLayer(r, e, t) {
    let o = r / e, n = t.image !== void 0 ? t.image.width / t.image.height : 1, s;
    o > n ? s = { x: 1, y: n / o } : o < n ? s = { x: o / n, y: 1 } : s = { x: 1, y: 1 }, t.repeat.set(s.x, s.y), t.updateMatrix();
  }
  static resizeTextureLayers(r, e, t) {
    let o = t.layers;
    for (let n = 0; n < o.length; n++) {
      let s = o[n];
      Nd(s) && vn.resizeTextureLayer(r, e, s.uniforms[`f${s.id}_texture`].value);
    }
  }
  static resizeComplex(r, e, t, o) {
    let n = r / e, s, a = t.image;
    tf(a) ? s = a.videoWidth / a.videoHeight : s = a.width / a.height, o.geometry.type.includes("Shape") ? (n > s && (t.imageType == "WEBCAM" ? t.repeat.set(1 / r * -1, 1 / e * s / n) : t.repeat.set(1 / r, 1 / e * s / n)), n < s && (t.imageType == "WEBCAM" ? t.repeat.set(1 / r * n / s * -1, 1 / e) : t.repeat.set(1 / r * n / s, 1 / e)), n == s && (t.imageType == "WEBCAM" ? t.repeat.set(1 / r * -1, 1 / e) : t.repeat.set(1 / r, 1 / e))) : (n > s && (t.imageType == "WEBCAM" ? t.repeat.set(-1, 1 * s / n) : t.repeat.set(1, 1 * s / n)), n < s && (t.imageType == "WEBCAM" ? t.repeat.set(1 * n / s * -1, 1) : t.repeat.set(1 * n / s, 1)), n == s && (t.imageType == "WEBCAM" ? t.repeat.set(-1, 1) : t.repeat.set(1, 1)));
  }
};
var ca = class extends Ke {
  constructor(e, t) {
    super(e, t);
    this.objectType = "Mesh2D";
    this.castShadow = true, this.receiveShadow = true;
  }
  updateGeometry(e) {
    super.updateGeometry(e), this.material.layers && vn.resizeTextureLayers(this.geometry.userData.parameters.width, this.geometry.userData.parameters.height, this.material);
  }
};
var bn = class extends Ke {
  constructor(e, t) {
    super(e, t);
    this.objectType = "Mesh3D";
    this.castShadow = true, this.receiveShadow = true;
  }
};
var ua = class extends bn {
  constructor(e, t) {
    super(e, t);
    this.objectType = "NonParametric";
  }
};
var Ee = class extends Mesh {
  constructor({ char: e, originalChar: t, fontFamily: o, letterSpacing: n, fontSize: s, LOD: a = 16 }, l = new MeshBasicMaterial({ color: 0, opacity: 1, visible: true, transparent: true, side: DoubleSide })) {
    let c = Ee.loadChar(e, o, a);
    super(c.geometry, l);
    this.char = e, this.originalChar = t != null ? t : e, this.fontFamily = o, this.letterSpacing = n, this.fontSize = s, this.LOD = a, this.resolution = c.resolution, this.glyphsHa = c.glyphsHa, this.localPosition = new Vector2(), this.charSize = 0, this.geometry.userData = { type: "CharacterGeometry", parameters: { char: this.char, fontFamily: this.fontFamily, letterSpacing: this.letterSpacing, fontSize: this.fontSize, lod: this.LOD, resolution: this.resolution, charSize: this.charSize, localPosition: this.localPosition } }, this.updateFontSize(this.fontSize);
  }
  static get FONTS_PATH() {
    return Ee._fontPath;
  }
  static set FONTS_PATH(e) {
    Ee._fontPath = e;
  }
  updatePosition(e, t) {
    this.localPosition.copy(e);
    let o = new Vector3(this.localPosition.x, -this.localPosition.y, 0);
    this.position.copy(o).add(t);
  }
  updateFontSize(e) {
    let t = e / this.resolution;
    this.fontSize = e, this.scale.set(this.fontSize, this.fontSize, 1), this.charSize = this.glyphsHa * t * this.letterSpacing;
  }
  updateFontFamily(e) {
    if (this.fontFamily === e)
      return;
    this.fontFamily = e;
    let t = Ee.loadChar(this.char, e, this.LOD);
    this.geometry = t.geometry, this.resolution = t.resolution, this.glyphsHa = t.glyphsHa, this.geometry.userData = { type: "CharacterGeometry", parameters: { char: this.char, fontFamily: this.fontFamily, letterSpacing: this.letterSpacing, fontSize: this.fontSize, lod: this.LOD, resolution: this.resolution, charSize: this.charSize, localPosition: this.localPosition } }, this.updateFontSize(this.fontSize);
  }
  updateChar(e) {
    if (this.char === e)
      return;
    this.char = e;
    let t = Ee.loadChar(e, this.fontFamily, this.LOD);
    this.geometry = t.geometry, this.resolution = t.resolution, this.glyphsHa = t.glyphsHa, this.geometry.userData = { type: "CharacterGeometry", parameters: { char: this.char, fontFamily: this.fontFamily, letterSpacing: this.letterSpacing, fontSize: this.fontSize, lod: this.LOD, resolution: this.resolution, charSize: this.charSize, localPosition: this.localPosition } }, this.updateFontSize(this.fontSize);
  }
  updateLetterSpacing(e) {
    this.letterSpacing !== e && (this.letterSpacing = e, this.updateFontSize(this.fontSize));
  }
  updateLOD(e) {
    if (this.LOD === e)
      return;
    this.LOD = e;
    let t = Ee.loadChar(this.char, this.fontFamily, this.LOD);
    this.geometry = t.geometry, this.resolution = t.resolution, this.glyphsHa = t.glyphsHa, this.geometry.userData = { type: "CharacterGeometry", parameters: { char: this.char, fontFamily: this.fontFamily, letterSpacing: this.letterSpacing, fontSize: this.fontSize, lod: this.LOD, resolution: this.resolution, charSize: this.charSize, localPosition: this.localPosition } }, this.updateFontSize(this.fontSize);
  }
  clone() {
    let e = { char: this.char, originalChar: this.originalChar, fontFamily: this.fontFamily, letterSpacing: this.letterSpacing, fontSize: this.fontSize, LOD: this.LOD };
    return new Ee(e).copy(this);
  }
  static loadFont(e) {
    return new Promise(function(t, o) {
      Ee.fontCache[e] ? t(Ee.fontCache[e]) : new FontLoader().load(Ee.FONTS_PATH + e + ".json", (s) => {
        Ee.fontCache[e] = s, t(s);
      }, void 0, o);
    });
  }
  static loadChar(e, t, o) {
    if (Ee.charCache[e]) {
      if (Ee.charCache[e][o] && Ee.charCache[e][o].fontFamily === t)
        return Ee.charCache[e][o];
    } else
      Ee.charCache[e] = {};
    let n = Ee.fontCache[t], s = n.generateShapes(e, 1);
    return Ee.charCache[e][o] = { geometry: new ShapeGeometry(s, o), fontFamily: t, resolution: n.data.resolution, glyphsHa: n.data.glyphs[e].ha }, Ee.charCache[e][o];
  }
};
var Ft = Ee;
Ft.charCache = {}, Ft.fontCache = {}, Ft._fontPath = "/_assets/_fonts/";
var pa = new Vector2();
var lo = class {
  constructor(r, e, t) {
    this.message = [];
    this.endLine = true;
    this.yLinePos = r, this.lineHeight = e, this.maxCharSize = t, this.nextChar3DPos = new Vector2(0, this.yLinePos + this.maxCharSize * this.lineHeight), this.align = 1;
  }
  addChar3D(r, e, t = this.message.length) {
    this.message.splice(t, 0, r), r.fontSize > this.maxCharSize ? (this.maxCharSize = r.fontSize, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight, this.fullUpdate(e)) : (r.updatePosition(this.nextChar3DPos, e), this.nextChar3DPos.x += r.charSize);
  }
  deleteChar3D(r = this.message.length - 1) {
    let e = this.message[r];
    if (e)
      return this.message.splice(r, 1), this.nextChar3DPos.x -= e.charSize, e;
  }
  isEndLine(r) {
    this.endLine = r;
  }
  fullUpdate(r, e = 0) {
    this.nextChar3DPos.x = 0;
    for (let t = e, o = this.message.length; t < o; t += 1)
      this.message[t].updatePosition(this.nextChar3DPos, r), this.nextChar3DPos.x += this.message[t].charSize;
  }
  checkOverFlow(r) {
    let e, t = this.message.length - 1;
    if (t <= 0)
      return false;
    for (; t >= 0; ) {
      if (this.message[t].char !== " ") {
        e = this.message[t];
        break;
      }
      t -= 1;
    }
    return !!(t >= 0 && e && e.localPosition.x + e.charSize > r);
  }
  containSpaceOverFlow(r = this.message.length - 1) {
    for (let e = r; e >= 0; e -= 1)
      if (this.message[e].char === " ")
        return true;
    return false;
  }
  containSpace(r = this.message.length - 1) {
    if (this.endLine)
      return true;
    for (let e = r; e >= 0; e -= 1)
      if (this.message[e].char === " ")
        return true;
    return false;
  }
  popWord(r = this.message.length - 1) {
    let e = [], t = true, o;
    for (o = r; o >= 0; o -= 1)
      if (this.message[o].char === " ") {
        t = false, e.length === 0 && (o -= 1, e.splice(0, 0, this.message[o]));
        break;
      } else
        e.splice(0, 0, this.message[o]);
    return t ? e = [] : this.message.splice(o + 1, e.length), e;
  }
  getWord(r = 0, e = 1) {
    let t = [], o = r;
    for (o = r; ; o += e) {
      if (!this.message[o] || this.message[o].char === " ") {
        t.length === 0 && this.message[o] && (t.push(this.message[o]), this.message.splice(o, 1));
        break;
      }
      e > 0 ? (t.push(this.message[o]), this.message.splice(o, 1), o -= e) : (t.splice(0, 0, this.message[o]), this.message.splice(o, 1));
    }
    return t;
  }
  getWordAtIndex(r) {
    let e = [];
    for (let t = r; t < this.message.length && this.message[t].char !== " "; t++)
      e.push(this.message[t]);
    for (let t = r - 1; t >= 0 && this.message[t].char !== " "; t--)
      e.splice(0, 0, this.message[t]);
    return e;
  }
  wordSize(r = 0, e = -1) {
    let t = 0, o = r;
    for (; o >= 0 && o < this.message.length; ) {
      if (this.message[o].char === " ") {
        t === 0 && (t = this.message[o].charSize);
        break;
      }
      t += this.message[o].charSize, o += e;
    }
    return (o < 0 || o >= this.message.length) && !this.endLine ? this.message[r] ? this.message[r].charSize : 999999999 : t === 0 ? 999999999 : t;
  }
  spaceLeft(r) {
    return r - this.nextChar3DPos.x;
  }
  popChar(r = this.message.length - 1) {
    return this.nextChar3DPos.x -= this.message[r].charSize, this.message.splice(r, 1);
  }
  isEmpty() {
    return !this.message.length;
  }
  updateNextCharPosY() {
    this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight;
  }
  updateYLinePos(r) {
    this.yLinePos = r, this.updateNextCharPosY();
  }
  updatelineHeight(r) {
    this.lineHeight = r, this.updateNextCharPosY();
  }
  updateFontSize(r, e = 0, t = this.message.length - 1) {
    for (let o = e; o <= t; o += 1)
      this.message[o].updateFontSize(r);
    this.maxCharSize = r, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight;
  }
  countSpaces() {
    let r = 0;
    for (let e = 0; e < this.message.length; e++)
      this.message[e].char === " " && (r += 1);
    return r;
  }
  alignText(r, e, t, o, n) {
    switch (t) {
      case 1:
        this.leftAlign(r, n);
        break;
      case 3:
        this.centerAlign(this.spaceLeft(e), r, n);
        break;
      case 2:
        this.rightAlign(this.spaceLeft(e), r, n);
        break;
      case 4:
        this.justifyAlign(this.spaceLeft(e), r, n);
        break;
    }
  }
  offsetCharacters(r, e, t) {
    pa.set(e, t);
    let o = this.message.length;
    for (let n = 0; n < o; n++)
      this.message[n].updatePosition(this.message[n].localPosition.add(pa), r);
  }
  leftAlign(r, e) {
    this.align = 1, this.offsetCharacters(r, 0, e);
  }
  centerAlign(r, e, t) {
    this.align = 3, this.offsetCharacters(e, r / 2, t);
  }
  rightAlign(r, e, t) {
    this.align = 2, this.offsetCharacters(e, r, t);
  }
  justifyAlign(r, e, t) {
    if (this.align = 4, this.endLine) {
      this.offsetCharacters(e, 0, t);
      return;
    }
    let o = this.countSpaces();
    if (o === 0) {
      this.offsetCharacters(e, 0, t);
      return;
    }
    let n = r / o, s = 0;
    for (let a = 0; a < this.message.length; a++)
      this.message[a].char === " " && (s += n), pa.set(s, t), this.message[a].updatePosition(this.message[a].localPosition.add(pa), e);
  }
  clone() {
    let r = new lo(this.yLinePos, this.lineHeight, this.maxCharSize);
    r.nextChar3DPos = this.nextChar3DPos.clone(), r.align = this.align, r.endLine = this.endLine;
    for (let e = 0; e < this.message.length; e++)
      r.message.push(this.message[e].clone());
    return r;
  }
};
var rc = class extends Ke {
  constructor(e) {
    super(e, new MeshBasicMaterial({ transparent: true, opacity: 1, visible: false, side: DoubleSide }));
    this.objectType = "TextFrame";
    this.charContainer = new Object3D(), this.add(this.charContainer), this.material.visible = false, this._geometryUserData = e.userData, this.userData.textFrame = { hexColor: null, opacity: 1, visible: true, text: "", fontSize: 16, lineHeight: 1.5, letterSpacing: 1, fontFamily: "roboto_regular", textTransform: 1, horizontalAlignment: 1, verticalAlignment: 1, LOD: 16, maxLineSize: this._geometryUserData.parameters.width, textOrigin: new Vector3(this._geometryUserData.parameters.width * -0.5, this._geometryUserData.parameters.height * 0.5, 0), textLines: [] }, this.createTextLine();
  }
  static createFromState(e, t, o) {
    let n = js.create({ parameters: { width: t.width, height: t.height } }), s = new rc(n).fromState(t, o);
    return s.uuid = e, s;
  }
  async updateText(e) {
    this.clearText();
    let t = this.userData.textFrame, o = t.fontFamily;
    await Ft.loadFont(o), t.text = e;
    let n = t.textOrigin, s = new MeshBasicMaterial({ visible: t.visible, transparent: true, side: DoubleSide }), a = e.split(`
`), l = 0;
    this.userData.textFrame.textLines = a.map((c, u) => {
      let m = new lo(l, t.lineHeight, t.fontSize);
      return m.message = c.split("").map((p) => {
        let d = { char: p, fontFamily: o, letterSpacing: t.letterSpacing, fontSize: t.fontSize, LOD: 16 }, f = s.clone();
        f.color = t.hexColor, f.opacity = t.opacity;
        let g = new Ft(d, f);
        return m.addChar3D(g, n), this.charContainer.add(g), g;
      }), l += m.maxCharSize * m.lineHeight, m;
    }), this.textFullUpdate(), this.checkOverFlow();
  }
  clearText() {
    let e = this.userData.textFrame.textLines;
    for (; this.charContainer.children.length; ) {
      let t = this.charContainer.children[0];
      this.charContainer.remove(t);
    }
    for (; e.length; )
      e.pop();
  }
  raycast(e, t) {
    let o = [];
    if (super.raycast(e, o), o.length > 0) {
      t.push(o[0]);
      return;
    }
    let n = [];
    for (let s = 0, a = this.charContainer.children.length; s < a; ++s)
      if (this.charContainer.children[s] instanceof Ft && (e.intersectObject(this.charContainer.children[s], false, n), n.length > 0)) {
        n[0].object = this, t.push(n[0]);
        return;
      }
  }
  updateGeometry(e) {
    var _a2, _b2, _c2, _d2;
    let t = this.userData, o = this.geometry.userData, n = o.parameters.width, s = o.parameters.height, a = (_b2 = (_a2 = e.parameters) == null ? void 0 : _a2.width) != null ? _b2 : n, l = (_d2 = (_c2 = e.parameters) == null ? void 0 : _c2.height) != null ? _d2 : s, c = t.textFrame;
    super.updateGeometry(e), c.maxLineSize = a, c.textOrigin.set(-0.5 * a, 0.5 * l, 0), l !== s ? (this.checkOverFlow(), this.checkCapacity()) : a !== n && (n < a ? this.checkCapacity() : n > a && this.checkOverFlow());
  }
  checkOverFlow(e = 0) {
    let t = this.userData, o = t.textFrame.textOrigin, n = t.textFrame.textLines;
    for (let s = e; s < n.length; s++) {
      n[s].updateYLinePos(this.getNewLinePosition(s)), n[s].fullUpdate(o);
      let a = [];
      for (; n[s].checkOverFlow(t.textFrame.maxLineSize); )
        n[s].containSpaceOverFlow() ? a.unshift(n[s].getWord(n[s].message.length - 1, -1)) : a.unshift(n[s].popChar());
      if (a.length > 0) {
        n[s + 1] === void 0 ? (n[s].isEndLine(false), this.createTextLine()) : n[s].endLine && (this.createTextLine(s + 1), n[s].isEndLine(false), n[s + 1].isEndLine(true));
        let l = 0;
        for (let c = 0; c < a.length; c += 1)
          for (let u = 0; u < a[c].length; u += 1)
            n[s + 1].addChar3D(a[c][u], o, l), l += 1;
        n[s + 1].fullUpdate(o);
      }
      n[s].fullUpdate(o);
    }
    this.textFullUpdate(e);
  }
  checkCapacity(e = 0) {
    let t = this.userData, o = t.textFrame.textOrigin, n = t.textFrame.maxLineSize, s = t.textFrame.textLines;
    for (let a = e; a < s.length; a += 1)
      if (s[a].updateYLinePos(this.getNewLinePosition(a)), s[a].fullUpdate(o), !!s[a - 1])
        for (; !s[a - 1].endLine; ) {
          let l, c = s[a - 1].spaceLeft(n);
          if (s[a].wordSize(0, 1) <= c) {
            s[a].containSpace() ? l = s[a].getWord(0, 1) : l = s[a].popChar(0);
            for (let u = 0; u < l.length; u += 1)
              l[u] && s[a - 1].addChar3D(l[u], o);
          } else {
            s[a].isEmpty() ? (s[a].endLine && s[a - 1].isEndLine(true), s.splice(a, 1), a -= 1) : (s[a].updateYLinePos(this.getNewLinePosition(a)), s[a].fullUpdate(o));
            break;
          }
        }
    this.textFullUpdate(e);
  }
  createTextLine(e = this.userData.textFrame.textLines.length) {
    let o = this.userData.textFrame;
    o.textLines.splice(e, 0, new lo(this.getNewLinePosition(e), o.lineHeight, o.fontSize));
  }
  textFullUpdate(e = 0) {
    let o = this.userData.textFrame, n = o.textLines, s = this.getVerticalAlignmentOffSet();
    for (let a = e; a < n.length; a++)
      n[a].updateYLinePos(this.getNewLinePosition(a)), n[a].fullUpdate(o.textOrigin), n[a].alignText(o.textOrigin, o.maxLineSize, o.horizontalAlignment, o.verticalAlignment, s);
  }
  getVerticalAlignmentOffSet() {
    switch (this.userData.textFrame.verticalAlignment) {
      case 1:
        return 0;
      case 2:
        return this.getRemainingVerticalSpace() / 2;
      case 3:
        return this.getRemainingVerticalSpace();
      default:
        return 0;
    }
  }
  getRemainingVerticalSpace() {
    let t = this.userData.textFrame.textLines;
    return this.geometry.userData.parameters.height - this.getNewLinePosition(t.length);
  }
  getNewLinePosition(e) {
    let o = this.userData.textFrame.textLines, n = 0;
    for (let s = 0; s < e; s += 1)
      n += o[s].maxCharSize * o[s].lineHeight;
    return n;
  }
  updateColor(e) {
    var _a2;
    let t = this.userData;
    t.textFrame.hexColor = e;
    let o = t.textFrame.textLines;
    for (let n = 0; n < o.length; n++) {
      let s = o[n].message;
      for (let a = 0; a < s.length; a++) {
        let l = s[a].material;
        ((_a2 = l.color) == null ? void 0 : _a2.isColor) && (l.color = e);
      }
    }
  }
  updateOpacity(e) {
    let t = this.userData;
    t.textFrame.opacity = e;
    let o = t.textFrame.textLines;
    for (let n = 0; n < o.length; n++) {
      let s = o[n].message;
      for (let a = 0; a < s.length; a++) {
        let l = s[a].material;
        l.opacity = e;
      }
    }
  }
  updateVisible(e) {
    let t = this.userData;
    t.textFrame.visible = e;
    let o = t.textFrame.textLines;
    for (let n = 0; n < o.length; n++) {
      let s = o[n].message;
      for (let a = 0; a < s.length; a++) {
        let l = s[a].material;
        l.visible = e;
      }
    }
  }
  async updateFontFamily(e) {
    await Ft.loadFont(e);
    let o = this.userData.textFrame, n = o.textLines;
    o.fontFamily = e;
    for (let s = 0; s < n.length; s++) {
      let a = n[s].message;
      for (let l = 0; l < a.length; l++)
        a[l].updateFontFamily(e);
    }
    this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
  }
  updateFontSize(e) {
    let o = this.userData.textFrame, n = o.textLines, s = o.fontSize;
    o.fontSize = e;
    for (let a = 0; a < n.length; a++)
      n[a].updateFontSize(e);
    this.textFullUpdate(), e > s ? this.checkOverFlow() : e < s && this.checkCapacity();
  }
  async updateTextTransform(e) {
    let o = this.userData.textFrame;
    await Ft.loadFont(o.fontFamily);
    let n = o.textLines;
    switch (o.textTransform = e, e) {
      case 2:
        for (let s = 0; s < n.length; s++) {
          let a = n[s].message;
          for (let l = 0; l < a.length; l++)
            n[s].message[l].updateChar(a[l].char.toUpperCase());
        }
        break;
      case 3:
        for (let s = 0; s < n.length; s++) {
          let a = n[s].message;
          for (let l = 0; l < a.length; l++)
            n[s].message[l].updateChar(a[l].char.toLowerCase());
        }
        break;
      default:
        for (let s = 0; s < n.length; s++) {
          let a = n[s].message;
          for (let l = 0; l < a.length; l++)
            n[s].message[l].updateChar(a[l].originalChar);
        }
    }
    this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
  }
  updateLetterSpacing(e) {
    let t = this.userData, o = t.textFrame.textLines;
    t.textFrame.letterSpacing = e;
    for (let n = 0; n < o.length; n++) {
      let s = o[n].message;
      for (let a = 0; a < s.length; a++)
        s[a].updateLetterSpacing(e);
    }
    this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
  }
  updateLOD(e) {
    let t = this.userData;
    t.textFrame.LOD = e;
    let o = t.textFrame.textLines;
    for (let n = 0; n < o.length; n++)
      ;
    this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
  }
  updateLineHeight(e) {
    let t = this.userData, o = t.textFrame.textLines;
    t.textFrame.lineHeight = e;
    for (let n = 0; n < o.length; n++)
      o[n].updatelineHeight(e);
    this.textFullUpdate();
  }
  updateVerticalAlignment(e) {
    let t = this.userData;
    t.textFrame.verticalAlignment = e, this.textFullUpdate();
  }
  updateHorizontalAlignment(e) {
    let t = this.userData;
    t.textFrame.horizontalAlignment = e, this.textFullUpdate();
  }
  fromTextFrameData(e, t) {
    if (e.color !== void 0) {
      let o = ze(e.color, t);
      this.updateColor(o), this.updateOpacity(o.a);
    }
    e.alpha !== void 0 && this.updateOpacity(e.alpha), e.font !== void 0 && this.updateFontFamily(e.font), e.horizontalAlign !== void 0 && this.updateHorizontalAlignment(e.horizontalAlign), e.verticalAlign !== void 0 && this.updateVerticalAlignment(e.verticalAlign), e.textTransform !== void 0 && this.updateTextTransform(e.textTransform), e.fontSize !== void 0 && this.updateFontSize(e.fontSize), e.lineHeight !== void 0 && this.updateLineHeight(e.lineHeight), e.letterSpacing !== void 0 && this.updateLetterSpacing(e.letterSpacing), e.text !== void 0 && e.text !== "" && this.updateText(e.text), (e.width !== void 0 || e.height !== void 0) && this.updateGeometry({ parameters: { width: e.width, height: e.height } });
  }
  fromState(e, t) {
    return super.fromState(e), this.fromTextFrameData(e, t), this;
  }
};
var co = rc;
co.VerticalAlign = ja, co.HorizontalAlign = Ua, co.TextTransform = ka;
var vi = class {
  constructor(r) {
    this.deletedMaterial = new no(yr.defaultTwoLayerData("basic"), this);
    this.deletedImage = new oo(Is.emptyImage);
    this.materials = {};
    this.images = {};
    this.colors = {};
    this.onImageLoad = () => {
      this._onImageLoad && this._onImageLoad();
    };
    this.transmissionRenderTarget = new WebGLRenderTarget(2048, 2048, { generateMipmaps: true, minFilter: LinearMipmapLinearFilter, magFilter: LinearFilter, wrapS: ClampToEdgeWrapping, wrapT: ClampToEdgeWrapping }), this.transmissionRenderTarget.depthTexture = new DepthTexture(2048, 2048), this.normalRenderTarget = new WebGLRenderTarget(1024, 1024, { generateMipmaps: false, minFilter: NearestFilter, magFilter: NearestFilter, type: FloatType }), this.normalRenderTarget.depthTexture = new DepthTexture(1024, 1024), this.penumbraSizeNode = new He(5, r.penumbraSize), this.resolutionNode = new ke(1, 1), this.pixelRatioNode = new W(window.devicePixelRatio), this.reset(r);
  }
  setOnImageLoad(r) {
    this._onImageLoad = r;
  }
  reset(r) {
    for (let [e, t] of Object.entries(r.images))
      this.addImage(e, t);
    for (let [e, t] of Object.entries(r.colors))
      this.addColor(e, t);
    for (let [e, t] of Object.entries(r.materials))
      this.addMaterial(e, new no(t, this));
  }
  get transmissionSamplerMap() {
    return this.transmissionRenderTarget.texture;
  }
  get transmissionDepthMap() {
    return this.transmissionRenderTarget.depthTexture;
  }
  get normalMap() {
    return this.normalRenderTarget.texture;
  }
  addMaterial(r, e) {
    e.uuid = r, this.materials[r] = e;
  }
  deleteMaterial(r) {
    this.materials[r] && (this.materials[r].dispose(), delete this.materials[r]);
  }
  getMaterial(r) {
    let e = this.materials[r];
    return e;
  }
  getMaterialOrDeletedPlaceholder(r) {
    var _a2;
    return (_a2 = this.materials[r]) != null ? _a2 : this.deletedMaterial;
  }
  material(r) {
    return typeof r == "string" ? this.getMaterialOrDeletedPlaceholder(r) : new Gt(r, this);
  }
  getMaterials() {
    return this.materials;
  }
  addImage(r, e) {
    return this.images[r] ? (this.images[r].updateSrc(e.data), true) : (this.images[r] = new oo(e, this.onImageLoad), false);
  }
  deleteImage(r) {
    this.images[r] && delete this.images[r];
  }
  getDefaultImage() {
    return this.images.image_0;
  }
  getImage(r) {
    var _a2;
    return (_a2 = this.images[r]) != null ? _a2 : this.deletedImage;
  }
  image(r) {
    return typeof r == "string" ? this.getImage(r) : new an(r, this.onImageLoad);
  }
  getImages() {
    return this.images;
  }
  addColor(r, e) {
    return this.colors[r] ? ("a" in e ? this.colors[r].setRGBA(e.r, e.g, e.b, e.a) : this.colors[r].setRGBA(e.r, e.g, e.b, 1), true) : ("a" in e ? this.colors[r] = new kr(e.r, e.g, e.b, e.a) : this.colors[r] = new kr(e.r, e.g, e.b, 1), false);
  }
  updateColor(r, e) {
    var _a2, _b2, _c2, _d2;
    if (this.colors[r]) {
      let t = this.colors[r];
      return this.colors[r].r = (_a2 = e.r) != null ? _a2 : t.r, this.colors[r].g = (_b2 = e.g) != null ? _b2 : t.g, this.colors[r].b = (_c2 = e.b) != null ? _c2 : t.b, this.colors[r].a = (_d2 = e.a) != null ? _d2 : t.a, true;
    }
    return false;
  }
  deleteColor(r) {
    this.colors[r] && delete this.colors[r];
  }
  getColor(r) {
    return this.colors[r];
  }
  color(r) {
    let e;
    if (typeof r == "string") {
      let t = this.getColor(r);
      t ? e = t : (console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"), e = new Qe(0, 0, 0, 0));
    } else
      return "a" in r ? new Qe(r.r, r.g, r.b, r.a) : new Qe(r.r, r.g, r.b, 1);
    return e;
  }
  dispose() {
    Object.keys(this.materials).forEach((e) => this.deleteMaterial(e)), this.transmissionRenderTarget.depthTexture.dispose(), this.transmissionRenderTarget.dispose(), this._onImageLoad = void 0;
  }
};
var C4 = new vi(Ls.emptyData());
var Hr;
function c1() {
  return Hr || (Hr = new DRACOLoader(), Hr.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload()), Hr.decoderPending;
}
async function u1(i) {
  if (Hr) {
    let r = { attributeIDs: Hr.defaultAttributeIDs, attributeTypes: Hr.defaultAttributeTypes, useUniqueIDs: false }, e;
    try {
      e = await Hr.decodeGeometry(new Int8Array(i).buffer, r);
    } catch (t) {
      console.error(t);
    }
    if (e)
      return { index: e.index ? { array: e.index.array } : void 0, attributes: Object.entries(e.attributes).map(([t, o]) => ({ name: t, itemSize: o.itemSize, array: o.array })) };
  }
  return null;
}
async function uf(i, r) {
  let [e, t] = Na(xs.deserialize(new Uint8Array(i))), o = [];
  e.scene.objects.traverse((n, s) => {
    s.type === "Mesh" && s.geometry.type === "NonParametricGeometry" && s.geometry.data.draco !== void 0 && o.push(s);
  }), o.length && await c1();
  for (let n of o) {
    let s = await u1(La(n.geometry.data.draco));
    if (s) {
      s.index && (n.geometry.data.index = { array: s.index.array, itemSize: 1, normalized: false, type: "Uint32Array" });
      let a = {};
      s.attributes.forEach(({ name: l, array: c, itemSize: u }) => {
        a[l] = { array: c, itemSize: u, type: "Float32Array", normalized: false };
      }), n.geometry.data.attributes = a, n.geometry.data.draco = void 0;
    }
  }
  return r && r(e), t.result().data;
}
var hf = qf(mf());
var oc;
ks.then((i) => {
  oc = i;
});
var gf = new Matrix4();
var d1 = new Matrix4();
var f1 = new Matrix4();
var Ut = new Box3();
var Wr = new Vector3();
var h1 = new Matrix4();
var g1 = new Matrix4();
var Sn = class extends Ke {
  constructor(e, t, o, n) {
    super(o != null ? o : t, n);
    this.subdivPointer = e;
    this.originalGeometry = t;
    this.subdividedGeometry = o;
    this.objectType = "SubdivObject";
    this.hiddenMatrixOld = new Matrix4();
    this.smoothShading = true;
    this.phongAngle = 35;
    this.matrixWorldRigid = new Matrix4();
    this.castShadow = true, this.receiveShadow = true, this.forceComputeSize = false;
  }
  static createFromState(e, t, o) {
    let { subdivPointer: n, originalGeometry: s, subdividedGeometry: a } = At.build(t.geometry, void 0, void 0, !t.flatShading), l = o.material(t.material), c = new Sn(n, s, a || void 0, l);
    return t.geometry.phongAngle !== void 0 && (c.phongAngle = t.geometry.phongAngle), c.calcBoundingBox(), c.freeSubdivPointer(), c.uuid = e, c.fromState(t), c;
  }
  buildFromStore(e, t) {
    var _a2, _b2, _c2;
    let { originalGeometry: o, subdividedGeometry: n, subdivPointer: s } = At.build(e, t, this.subdivPointer, this.smoothShading, this.shearScale);
    e.phongAngle !== void 0 && (this.phongAngle = e.phongAngle), this.subdivPointer = s, o !== void 0 && ((_a2 = this.originalGeometry) == null ? void 0 : _a2.dispose(), this.originalGeometry = o), n !== void 0 && ((_b2 = this.subdividedGeometry) == null ? void 0 : _b2.dispose(), this.subdividedGeometry = n != null ? n : void 0), this.geometry = (_c2 = this.subdividedGeometry) != null ? _c2 : this.originalGeometry, io(this), so(this), e.width && (this.geometry.userData.parameters = { width: e.width, height: e.height, depth: e.depth });
  }
  updateMesh(e = false) {
    At.buildLevel(this.subdivPointer, true, this.smoothShading ? this.phongAngle : -1, this.originalGeometry, e ? this.shearScaleInv : void 0), this.subdividedGeometry && At.buildLevel(this.subdivPointer, false, this.smoothShading ? this.phongAngle : -1, this.subdividedGeometry, e ? this.shearScaleInv : void 0);
  }
  updateTopology() {
    var _a2;
    this.originalGeometry.dispose(), this.originalGeometry = At.buildLevel(this.subdivPointer, true, this.smoothShading ? this.phongAngle : -1), this.subdividedGeometry && (this.subdividedGeometry.dispose(), this.subdividedGeometry = At.buildLevel(this.subdivPointer, false, this.smoothShading ? this.phongAngle : -1)), this.geometry = (_a2 = this.subdividedGeometry) != null ? _a2 : this.originalGeometry;
  }
  raycast(e, t) {
    var _a2;
    this.geometry = this.originalGeometry, Ke.prototype.raycast.call(this, e, t), this.geometry = (_a2 = this.subdividedGeometry) != null ? _a2 : this.originalGeometry;
  }
  updateMatrixWorldSVD() {
    let e = this.matrixWorld.elements, t = [[e[0], e[4], e[8]], [e[1], e[5], e[9]], [e[2], e[6], e[10]]], { u: o, v: n, q: s } = (0, hf.SVD)(t), a = gf.set(o[0][0], o[0][1], o[0][2], 0, o[1][0], o[1][1], o[1][2], 0, o[2][0], o[2][1], o[2][2], 0, 0, 0, 0, 1), l = d1.set(n[0][0], n[0][1], n[0][2], 0, n[1][0], n[1][1], n[1][2], 0, n[2][0], n[2][1], n[2][2], 0, 0, 0, 0, 1), c = f1.copy(l).transpose();
    this.shearScale = h1.makeScale(s[0], s[1], s[2]).multiply(c).premultiply(l), this.shearScaleInv = g1.copy(this.shearScale).invert(), this.matrixWorldRigid.multiplyMatrices(a, c), s.every((u) => Math.abs(s[0] - u) < 0.01) && (this.shearScale = void 0, this.shearScaleInv = void 0);
  }
  activateSVDCompensation() {
    this.shearScale !== void 0 && (this.matrixAutoUpdate = false, this.matrix.copy(this.matrixWorldRigid).copyPosition(this.matrixWorld), this.hiddenMatrixOld.copy(this.hiddenMatrix), this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
  }
  deactivateSVDCompensation() {
    this.shearScale !== void 0 && (this.shearScale = void 0, this.shearScaleInv = void 0, this.matrixAutoUpdate = true, this.hiddenMatrix.copy(this.hiddenMatrixOld));
  }
  calcBoundingBox() {
    let e = this.originalGeometry;
    e.boundingSphere === null && (e.boundingSphere = new Sphere());
    let t = e.attributes.position, o = e.boundingSphere.center;
    Ut.setFromBufferAttribute(t), Ut.getCenter(o), e.boundingSphere.radius = o.distanceTo(Ut.max), isNaN(e.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), Ut.getSize(Wr);
    let n = { width: Wr.x, height: Wr.y, depth: Wr.z };
    return this.geometry.userData.parameters = n, n;
  }
  updateBoundingBox(e) {
    let t = this.originalGeometry;
    Ut.min.set(e[0], e[2], e[4]), Ut.max.set(e[1], e[3], e[5]), this.shearScaleInv && (Ut.min.applyMatrix4(this.shearScaleInv), Ut.max.applyMatrix4(this.shearScaleInv)), t.boundingSphere === null && (t.boundingSphere = new Sphere());
    let o = t.boundingSphere.center;
    Ut.getCenter(o), t.boundingSphere.radius = o.distanceTo(Ut.max), isNaN(t.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), Ut.getSize(Wr);
    let n = { width: Wr.x, height: Wr.y, depth: Wr.z };
    return this.geometry.userData.parameters = n, n;
  }
  freeSubdivPointer() {
    this.subdivPointer && (oc.free_bvh(this.subdivPointer), oc.free_subdivision_surface(this.subdivPointer), this.subdivPointer = 0);
  }
  updateGeometry(e) {
    this.geometry.userData.scale || (this.geometry.userData.scale = Array(3)), this.geometry.userData.scale[0] = this.geometry.userData.parameters.width === 0 ? 1 : e.parameters.width / this.geometry.userData.parameters.width, this.geometry.userData.scale[1] = this.geometry.userData.parameters.height === 0 ? 1 : e.parameters.height / this.geometry.userData.parameters.height, this.geometry.userData.scale[2] = this.geometry.userData.parameters.depth === 0 ? 1 : e.parameters.depth / this.geometry.userData.parameters.depth, ff(this.originalGeometry.attributes, ...this.geometry.userData.scale), this.originalGeometry.attributes.position.needsUpdate = true, this.originalGeometry.attributes.normal.needsUpdate = true, this.subdividedGeometry && (ff(this.subdividedGeometry.attributes, ...this.subdividedGeometry.userData.scale), this.subdividedGeometry.attributes.position.needsUpdate = true, this.subdividedGeometry.attributes.normal.needsUpdate = true), this.geometry.userData.parameters = __spreadValues({}, e.parameters);
  }
};
function ff(i, r, e, t) {
  let o = i.position.array, n = i.normal.array, s = gf.makeScale(r, e, t).invert().elements, a, l, c;
  for (var u = 0, m = o.length; u < m; u += 3)
    o[u] *= r, o[u + 1] *= e, o[u + 2] *= t, a = n[u], l = n[u + 1], c = n[u + 2], n[u] = s[0] * a + s[4] * l + s[8] * c, n[u + 1] = s[1] * a + s[5] * l + s[9] * c, n[u + 2] = s[2] * a + s[6] * l + s[10] * c;
}
function yf(i, r) {
  r.flatShading !== void 0 && (i.flatShading = r.flatShading, i.needsUpdate = true), r.wireframe !== void 0 && (i.wireframe = r.wireframe), r.side !== void 0 && (r.side === 0 ? i.side = FrontSide : r.side === 1 ? i.side = BackSide : i.side = DoubleSide);
}
function S1(i, r) {
  if (Array.isArray(i.material))
    for (let e of i.material)
      yf(e, r);
  else {
    let e = i.material;
    yf(e, r);
  }
  i.objectType === "SubdivObject" && r.flatShading !== void 0 && (i.material.flatShading = false, i.smoothShading = !r.flatShading, i.updateMesh());
}
function xf(i, r, e) {
  let t;
  if (r.geometry.type === "SubdivGeometry")
    t = Sn.createFromState(i, r, e);
  else {
    let o = r.geometry.type === "BooleanGeometry" ? new BufferGeometry() : Qs(r.geometry, e), n = "materials" in r ? r.materials.map((s) => e.material(s)) : e.material(r.material);
    Ts.is2DParametricMesh(o.userData.type) ? t = new ca(o, n) : (o == null ? void 0 : o.userData.type) === "VectorGeometry" ? t = new un(o, n) : r.geometry.type === "NonParametricGeometry" ? t = new ua(o, n) : r.geometry.type === "BooleanGeometry" ? (t = new ea(void 0, n), t.booleanOp = r.geometry.operation, r.geometry.phongAngle !== void 0 && (t.phongAngle = r.geometry.phongAngle)) : t = new bn(o, n), t.uuid = i, t.fromState(r, e);
  }
  return S1(t, r), t;
}
function vf(i, r, e) {
  return r.type === "Mesh" ? xf(i, r, e) : r.type === "TextFrame" ? co.createFromState(i, r, e) : r.type === "Empty" ? ao.createFromState(i, r) : r.type === "PointLight" ? yn.createFromState(i, r, e) : r.type === "SpotLight" ? xn.createFromState(i, r, e) : r.type === "DirectionalLight" ? gn.createFromState(i, r, e) : Do.is(r.type) ? Cr.createFromState(i, r) : (console.error(r), new ao());
}
var Sf = new Vector3();
var nc = class extends Hs(Scene) {
  constructor(e, t) {
    super();
    this.objectType = "Scene";
    this.alpha = 1;
    this.backupFog = new Fog(16777215, 0.1, 2e3);
    this.fogUseBGColor = false;
    this.wireframeState = false;
    this.needsTransmissionDirty = true;
    this.needsNormalDirty = true;
    this._needsTransmission = false;
    this._needsNormal = false;
    this._color = new Color(1, 0, 0);
    this.bgColor = new Color(1, 1, 1);
    this.entityByUuid = {};
    this.ambientLight = new HemisphereLight(13882323, 8553090, 0.75), this.ambientLight.name = "Default Ambient Light", this.personalCamera = this.createPersonalCamera(), this.activeCamera = this.personalCamera, this.init(e, t);
  }
  needsTransmission(e) {
    return this.needsTransmissionDirty && (this._needsTransmission = Md(e, this), e !== void 0 && (this.needsTransmissionDirty = false)), this._needsTransmission;
  }
  needsNormal(e) {
    return this.needsNormalDirty && (this._needsNormal = Ad(e, this), e !== void 0 && (this.needsNormalDirty = false)), this._needsNormal;
  }
  find(e) {
    if (e === "" || e === void 0)
      return;
    let t = this.entityByUuid[e];
    return t === void 0 ? this.getObjectByProperty("uuid", e) : t;
  }
  get color() {
    return this._color;
  }
  set color(e) {
    this.fogUseBGColor === true && this.backupFog.color.copy(e), this._color.copy(e);
  }
  get enableFog() {
    return this.fog !== null;
  }
  set enableFog(e) {
    this.fog = e === true ? this.backupFog : null;
  }
  init(e, t) {
    if (this.createChildrenObjects(e.objects, this, t), this.personalCamera.removeFromParent(), this.add(this.personalCamera), this.ambientLight.removeFromParent(), this.add(this.ambientLight), this.setBackgroundColor(ze(e.backgroundColor, t)), this.updateFog(e.fog, t), this.updateAmbientLight(e.environment.ambientLight, t), this.activeCamera = this.personalCamera, e.publish.playCamera !== null) {
      let o = this.find(e.publish.playCamera);
      o instanceof Cr && this.switchActiveCamera(o);
    }
    this.traverse((o) => {
      Jt(o) && o.recomputeBoolean();
    });
  }
  clearScene() {
    this.traverseEntity((e) => {
      Od(e);
    });
    for (let e of this.children)
      Dt(e) && e.removeFromParent();
  }
  resetAfterClear(e, t) {
    this.init(e, t);
  }
  createPersonalCamera() {
    let e = Cr.createFromState(nc.PERSONAL_CAMERA_ID, __spreadProps(__spreadValues({}, Cs.defaultData), { name: "Personal Camera" }));
    return e.enableHelper = false, e.objectHelper.visible = false, delete e.isEntity, this.registerObjectCreatedInLegacy(e), e;
  }
  raycast(e) {
    let t = [], o = (n) => {
      for (let s of n.children)
        Dt(s) && !s.raycastLock && s.visible && ((Qt(s) || wr(s) && s.enableHelper && s.objectHelper.parent) && (e.intersectObject(s, false, t), _d(s, e, t)), o(s));
    };
    return o(this), t;
  }
  traverseEntity(e) {
    for (let t of this.children)
      Dt(t) && t.traverseEntity(e);
  }
  updateFog(e, t) {
    this.enableFog = e.enabled, this.fogUseBGColor = e.useBackgroundColor, e.useBackgroundColor ? this.backupFog.color.set(this.bgColor) : this.backupFog.color = ze(e.color, t), this.backupFog.near = e.near, this.backupFog.far = e.far;
  }
  dispose() {
    this.clearScene();
  }
  updateAmbientLight(e, t) {
    rd(this.ambientLight, e, t), e.groundColor !== void 0 && (this.ambientLight.groundColor = ze(e.groundColor, t)), e.enabled !== void 0 && (this.ambientLight.visible = e.enabled);
  }
  switchActiveCamera(e) {
    this.activeCamera !== this.personalCamera && (this.activeCamera.enableHelper = true), this.activeCamera = e, e.enableHelper = false;
  }
  setBackgroundColor(e) {
    this.bgColor = e, this.alpha = e.a;
  }
  createChildrenObjects(e, t, o) {
    for (let n of e)
      this.createChildObject(n.id, n.data, n.children, t, o);
  }
  registerObjectCreatedInLegacy(e) {
    this.entityByUuid[e.uuid] = e;
  }
  unregisterObject(e) {
    delete this.entityByUuid[e.uuid];
    for (let t of e.children)
      this.unregisterObject(t);
  }
  createChildObject(e, t, o, n, s) {
    let a = vf(e, t, s);
    return a && (this.entityByUuid[e] = a, n.add(a), Jt(n) && Qt(a) && (a.prevBooleanObjectParent = n), this.createChildrenObjects(o, a, s)), a;
  }
  getCenter(e) {
    let t = [];
    for (let n = 0, s = e.length; n < s; ++n) {
      let { id: a, recursive: l } = e[n], c = this.find(a), u = l ? c.recursiveBBox : c.singleBBox;
      t.push(...u.vertices);
    }
    let o = new Box3();
    return o.setFromPoints(t), o.getCenter(Sf), Sf;
  }
  copyMatrixWorld(e, t) {
    if (e === null) {
      t.identity();
      return;
    }
    let o = this.find(e);
    o ? t.copy(o.matrixWorld) : t.identity();
  }
  copyParentMatrixWorld(e, t) {
    var _a2;
    if (e === null) {
      t.identity();
      return;
    }
    let o = (_a2 = this.find(e)) == null ? void 0 : _a2.parent;
    o ? t.copy(o.matrixWorld) : t.identity();
  }
  traverseMaterial(e) {
    this.traverseEntity((t) => {
      if (t instanceof Ke)
        if (Array.isArray(t.material))
          for (let o = 0; o < t.material.length; o++)
            t.material[o] instanceof Gt && e(t.material[o]);
        else
          t.material instanceof Gt && e(t.material);
    });
  }
  updateCanvasSize(e, t) {
    this.activeCamera.setViewplaneSize(e, t);
    let o, n;
    e >= t ? (o = t / e, n = 1) : (o = 1, n = e / t), this.traverseMaterial((s) => {
      s.getLayersOfType("transmission").forEach((l) => {
        l.uniforms[`f${l.id}_aspectRatio`].value.x = o, l.uniforms[`f${l.id}_aspectRatio`].value.y = n;
      });
    });
  }
};
var bi = nc;
bi.PERSONAL_CAMERA_ID = "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera";
function wf(i) {
  let r;
  if (!!i.index)
    for (let e = 0; e < i.index.array.length; e += 3)
      r = i.index.array[e], i.index.array[e] = i.index.array[e + 2], i.index.array[e + 2] = r;
}
function Nf(i) {
  let r = new Set();
  return i.traverse((e) => {
    if (Qt(e))
      if (Re(e.material))
        e.material.forEach((t) => {
          let o = t;
          r.has(o) || r.add(o);
        });
      else {
        let t = e.material;
        r.has(t) || r.add(t);
      }
  }), r.forEach((e) => {
    if (e instanceof Array)
      return;
    let t = e.onBeforeCompile.bind(e);
    P1(e) ? (Object.assign(e, { isMeshStandardMaterial: true, isMeshPhysicalMaterial: true, transmission: 1, attenuationColor: new Color(), specularColor: new Color() }), e.onBeforeCompile = (o, n) => {
      t && t(o, n), o.uniforms = Object.assign(ShaderLib.physical.uniforms, o.uniforms), e.getLayersOfType("transmission").forEach((s) => {
        o.uniforms.transmissionSamplerMap.value && (s.uniforms["f" + s.id + "_transmissionSamplerMap"].value = o.uniforms.transmissionSamplerMap.value, s.uniforms["f" + s.id + "_transmissionSamplerSize"].value = o.uniforms.transmissionSamplerSize.value);
      });
    }) : A1(e) || (e.onBeforeCompile = (o, n) => {
      t && t(o, n), e.transparent = false;
    });
  }), i;
}
function P1(i) {
  return i.getLayersOfType("transmission").length > 0;
}
function A1(i) {
  let r = 0;
  return i.layers.forEach((e) => {
    if (e.type !== "light" && e.type !== "fresnel") {
      let t = e.uniforms["f" + e.id + "_alpha"];
      t && (r += (1 - r) * t.value);
    }
  }), r < 1;
}
function Cf(i) {
  return i.traverse((r) => {
    if (r.type === "Camera") {
      let e = r;
      e.type = e.cameraType;
    }
  }), i;
}
function Lf(i) {
  let r = [], e = (t, o = 0) => {
    let n = o > 0 ? t + o : t;
    return r.includes(n) ? e(t, o + 1) : n;
  };
  return i.traverse((t) => {
    if (r.includes(t.name)) {
      let o = t.name, n = e(t.name);
      if (t.name = n, t.isMesh) {
        let s = t;
        s.material instanceof Array ? s.material.forEach((a) => {
          a.name = a.name.replace(o, n);
        }) : s.material.isAsset || (s.material.name = s.material.name.replace(o, n));
      }
    }
    r.push(t.name);
  }), i;
}
function If(i) {
  let r = [];
  return i.traverse((e) => {
    e instanceof eo && r.push(e);
  }), r.forEach((e) => {
    let t = e.object, o = e.children, n = o.map((a) => {
      a.updateMatrix();
      let l = a.geometry.clone().applyMatrix4(a.matrix);
      return a.matrix.determinant() < 0 && wf(l), l;
    }), s = mergeBufferGeometries(e.parameters.hideBase ? n : [t.geometry, ...n]);
    t.geometry = s, t.material = o[0].material, t.remove(e);
  }), i;
}
function Pf(i) {
  return i.traverse((r) => {
    r.matrixAutoUpdate = true;
  }), i;
}
function Af(i) {
  Object.values(i.shared.materials).forEach((r) => {
    ic(r);
  }), i.scene.objects.traverse((r, e) => {
    "material" in e ? ic(e.material) : "materials" in e && e.materials.forEach((t) => {
      ic(t);
    });
  });
}
function ic(i) {
  if (typeof i == "string")
    return;
  let r = [];
  i.layers.forEach((e, t) => {
    e.type === "outline" && r.push(t);
  }), r.reverse().forEach((e) => {
    i.layers.delete(e);
  }), r.length && console.warn("The Spline Loader currently does not support the outline layer.");
}
var Mf = "The SplineLoader only accepts .splinecode files that are generated from Spline export panel.";
var sc = class extends Loader {
  load(r, e, t, o = console.error) {
    let n = new FileLoader(this.manager);
    n.setPath(this.path), n.setResponseType("arraybuffer"), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials), r.endsWith(".spline") ? console.warn(Mf + " The .spline files are only meant to be used by the Editor.") : r.endsWith(".splinecode") || console.warn(Mf), n.load(r, async (s) => {
      try {
        if (typeof s == "string")
          throw new Error("The .spline file is not binary!");
        let a = await this.parse(s);
        e(a);
      } catch (a) {
        o(a);
      }
    }, t, o);
  }
  async parse(r) {
    let e = await uf(r, Af), t = new vi(e.shared);
    Object.values(t.getMaterials()).forEach((s) => Object.assign(s, { isAsset: true }));
    let o = new bi(e.scene, t);
    o.remove(o.personalCamera), e.scene.environment.ambientLight.enabled || o.remove(o.ambientLight);
    let n = e.scene.publish.playCamera;
    if (n) {
      let s = o.find(n);
      s && td(s) && Object.assign(s, { makeDefault: true });
    }
    return o = If(o), o = Nf(o), o = Cf(o), o = Lf(o), o = Pf(o), o;
  }
};

// dep:@splinetool_loader
var splinetool_loader_default = sc;
export {
  splinetool_loader_default as default
};
//# sourceMappingURL=@splinetool_loader.js.map
